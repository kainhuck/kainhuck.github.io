<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="获取文件信息FileInfo接口在os包中有一个FileInfo接口它包含了一个文件的基本信息,如下 123456789&#x2F;&#x2F; A FileInfo describes a file and is returned by Stat and Lstat.type FileInfo interface &amp;#123;	Name() string       &#x2F;&#x2F; base name of the file">
<meta property="og:type" content="article">
<meta property="og:title" content="从源码解读golang文件操作">
<meta property="og:url" content="https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/index.html">
<meta property="og:site_name" content="Kainhuck&#39;s blog">
<meta property="og:description" content="获取文件信息FileInfo接口在os包中有一个FileInfo接口它包含了一个文件的基本信息,如下 123456789&#x2F;&#x2F; A FileInfo describes a file and is returned by Stat and Lstat.type FileInfo interface &amp;#123;	Name() string       &#x2F;&#x2F; base name of the file">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-16T14:10:40.000Z">
<meta property="article:modified_time" content="2020-09-01T09:48:37.200Z">
<meta property="article:author" content="KainHuck">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>从源码解读golang文件操作</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/06/18/golang%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/05/27/python-%E5%A0%86%E6%8E%92%E5%BA%8F/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&text=从源码解读golang文件操作"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&title=从源码解读golang文件操作"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&is_video=false&description=从源码解读golang文件操作"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=从源码解读golang文件操作&body=Check out this article: https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&title=从源码解读golang文件操作"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&title=从源码解读golang文件操作"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&title=从源码解读golang文件操作"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&title=从源码解读golang文件操作"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&name=从源码解读golang文件操作&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&t=从源码解读golang文件操作"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">1.</span> <span class="toc-text">获取文件信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FileInfo%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text">FileInfo接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fileStat%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.</span> <span class="toc-text">fileStat结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.</span> <span class="toc-text">查看文件信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.</span> <span class="toc-text">文件路径</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%EF%BC%88%E7%9B%AE%E5%BD%95%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">文件创建删除（目录）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">2.1.</span> <span class="toc-text">检查文件是否存在</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">2.2.</span> <span class="toc-text">创建目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#os-MKdir"><span class="toc-number">2.2.1.</span> <span class="toc-text">os.MKdir()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#os-MKdirAll"><span class="toc-number">2.2.2.</span> <span class="toc-text">os.MKdirAll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#os-Creat"><span class="toc-number">2.2.3.</span> <span class="toc-text">os.Creat()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%EF%BC%88%E7%9B%AE%E5%BD%95%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">删除文件（目录）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#os-Remove"><span class="toc-number">2.3.1.</span> <span class="toc-text">os.Remove()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#os-RemoveAll"><span class="toc-number">2.3.2.</span> <span class="toc-text">os.RemoveAll()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">读写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">打开关闭文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80"><span class="toc-number">3.1.1.</span> <span class="toc-text">打开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD"><span class="toc-number">3.1.2.</span> <span class="toc-text">关闭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">读文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#f-Write"><span class="toc-number">3.3.1.</span> <span class="toc-text">f.Write()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#f-WriteString"><span class="toc-number">3.3.2.</span> <span class="toc-text">f.WriteString()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ioutil"><span class="toc-number">4.</span> <span class="toc-text">ioutil</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bufio"><span class="toc-number">5.</span> <span class="toc-text">bufio</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bufio-Reader"><span class="toc-number">5.1.</span> <span class="toc-text">bufio.Reader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bufio-Writer"><span class="toc-number">5.2.</span> <span class="toc-text">bufio.Writer</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        从源码解读golang文件操作
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Kainhuck's blog</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-06-16T14:10:40.000Z" itemprop="datePublished">2020-06-16</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/golang/" rel="tag">golang</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h1><h2 id="FileInfo接口"><a href="#FileInfo接口" class="headerlink" title="FileInfo接口"></a>FileInfo接口</h2><p>在<code>os</code>包中有一个<code>FileInfo</code>接口它包含了一个文件的基本信息,如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A FileInfo describes a file and is returned by Stat and Lstat.</span></span><br><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">	Name() <span class="keyword">string</span>       <span class="comment">// base name of the file</span></span><br><span class="line">	Size() <span class="keyword">int64</span>        <span class="comment">// length in bytes for regular files; system-dependent for others</span></span><br><span class="line">	Mode() FileMode     <span class="comment">// file mode bits</span></span><br><span class="line">	ModTime() time.Time <span class="comment">// modification time</span></span><br><span class="line">	IsDir() <span class="keyword">bool</span>        <span class="comment">// abbreviation for Mode().IsDir()</span></span><br><span class="line">	Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// underlying data source (can return nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面描述可以看到FileInfo描述一个文件并且被Stat和Lstat方法返回</p>
<p>从<code>os</code>包中可以看到这两个函数的定义,记住里面的两个函数<code>statNolog</code>和<code>lstatNolog</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stat returns a FileInfo describing the named file.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(FileInfo, error)</span></span> &#123;</span><br><span class="line">	testlog.Stat(name)</span><br><span class="line">	<span class="keyword">return</span> statNolog(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lstat returns a FileInfo describing the named file.</span></span><br><span class="line"><span class="comment">// If the file is a symbolic link, the returned FileInfo</span></span><br><span class="line"><span class="comment">// describes the symbolic link. Lstat makes no attempt to follow the link.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lstat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(FileInfo, error)</span></span> &#123;</span><br><span class="line">	testlog.Stat(name)</span><br><span class="line">	<span class="keyword">return</span> lstatNolog(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="fileStat结构体"><a href="#fileStat结构体" class="headerlink" title="fileStat结构体"></a>fileStat结构体</h2><p>同样在os包中定义了<code>fileState</code>结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A fileStat is the implementation of FileInfo returned by Stat and Lstat.</span></span><br><span class="line"><span class="keyword">type</span> fileStat <span class="keyword">struct</span> &#123;</span><br><span class="line">	name    <span class="keyword">string</span></span><br><span class="line">	size    <span class="keyword">int64</span></span><br><span class="line">	mode    FileMode</span><br><span class="line">	modTime time.Time</span><br><span class="line">	sys     syscall.Stat_t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>types_unix.go</code>文件中定义了如下方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int64</span></span>        &#123; <span class="keyword">return</span> fs.size &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">Mode</span><span class="params">()</span> <span class="title">FileMode</span></span>     &#123; <span class="keyword">return</span> fs.mode &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">ModTime</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123; <span class="keyword">return</span> fs.modTime &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">Sys</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;   &#123; <span class="keyword">return</span> &amp;fs.sys &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>types.go</code>中还定义以下两个方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> fs.name &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">IsDir</span><span class="params">()</span> <span class="title">bool</span></span>  &#123; <span class="keyword">return</span> fs.Mode().IsDir() &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个结构体刚好实现了<code>FileInfo</code>接口</p>
<p>实际上,进入<code>statNolog</code>和<code>lstatNolog</code>可知,<code>Stat</code>和<code>Lsate</code>函数就是返回了指向<code>fileStat</code>的指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// statNolog stats a file with no test logging.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">statNolog</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(FileInfo, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> fs fileStat</span><br><span class="line">	err := syscall.Stat(name, &amp;fs.sys)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, &amp;PathError&#123;<span class="string">&quot;stat&quot;</span>, name, err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fillFileStatFromSys(&amp;fs, name)</span><br><span class="line">	<span class="keyword">return</span> &amp;fs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lstatNolog lstats a file with no test logging.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lstatNolog</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(FileInfo, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> fs fileStat</span><br><span class="line">	err := syscall.Lstat(name, &amp;fs.sys)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, &amp;PathError&#123;<span class="string">&quot;lstat&quot;</span>, name, err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fillFileStatFromSys(&amp;fs, name)</span><br><span class="line">	<span class="keyword">return</span> &amp;fs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以本质上就是利用<code>fileStat</code>结构体存放文件相关信息,并做操作</p>
<h2 id="查看文件信息"><a href="#查看文件信息" class="headerlink" title="查看文件信息"></a>查看文件信息</h2><p>介绍了这么多,写一个golang读取文件信息的例子,(当前目录下的go.mod文件)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileInfo, err := os.Stat(<span class="string">&quot;go.mod&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;读取文件出错&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件名:&quot;</span>, fileInfo.Name())</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件大小:&quot;</span>, fileInfo.Size())</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件权限:&quot;</span>, fileInfo.Mode())</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件修改时间:&quot;</span>, fileInfo.ModTime())</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件是否是目录:&quot;</span>, fileInfo.IsDir())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件名: go.mod</span><br><span class="line">文件大小: 24</span><br><span class="line">文件权限: -rw-r--r--</span><br><span class="line">文件修改时间: 2020-06-16 09:04:23.418186928 +0800 CST</span><br><span class="line">文件是否是目录: false</span><br></pre></td></tr></table></figure>

<p>其实上面方法就是对应<code>FileInfo</code>接口中的方法，但是少了一个<code>Sys</code>方法，通过这个方法你可以获得更加详细的信息，这个比较特殊，如果你直接打印会得到类似如下的输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(fileInfo.Sys())</span><br><span class="line"><span class="comment">// &amp;&#123;2064 23337987 1 33188 1000 1000 0 0 24 4096 8 &#123;1592269464 801520234&#125; &#123;1592269463 418186928&#125; &#123;1592269463 418186928&#125; [0 0 0]&#125;</span></span><br></pre></td></tr></table></figure>

<p>其实<code>Sys</code>方法就是返回了<code>fileStat</code>的<code>sys</code>属性,上面我们已经看过<code>fileStat</code>的定义,可以发现<code>sys</code>属性就是一个<code>syscall.Stat_t</code>类型</p>
<p>这是<code>Stat_t</code>的定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stat_t <span class="keyword">struct</span> &#123;</span><br><span class="line">	Dev       <span class="keyword">uint64</span></span><br><span class="line">	Ino       <span class="keyword">uint64</span></span><br><span class="line">	Nlink     <span class="keyword">uint64</span></span><br><span class="line">	Mode      <span class="keyword">uint32</span></span><br><span class="line">	Uid       <span class="keyword">uint32</span></span><br><span class="line">	Gid       <span class="keyword">uint32</span></span><br><span class="line">	X__pad0   <span class="keyword">int32</span></span><br><span class="line">	Rdev      <span class="keyword">uint64</span></span><br><span class="line">	Size      <span class="keyword">int64</span></span><br><span class="line">	Blksize   <span class="keyword">int64</span></span><br><span class="line">	Blocks    <span class="keyword">int64</span></span><br><span class="line">	Atim      Timespec</span><br><span class="line">	Mtim      Timespec</span><br><span class="line">	Ctim      Timespec</span><br><span class="line">	X__unused [<span class="number">3</span>]<span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过反射来获取上述属性的信息,以获取 Ctim 为例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileInfo, err := os.Stat(<span class="string">&quot;go.mod&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;读取文件出错&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Ctim := reflect.ValueOf(fileInfo.Sys()).Elem().FieldByName(<span class="string">&quot;Ctim&quot;</span>).Field(<span class="number">0</span>)</span><br><span class="line">	fmt.Println(Ctim) <span class="comment">// 1592269463</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>也许有人会奇怪,为什么<code>fileStat</code>结构体里没有文件路径相关信息,其实者不难理解,我们既然能够打开一个文件,前提就是我们知道这个文件放在哪里.而我接下来要做的操作知识针对文件路径,而不是文件本身.</p>
<p>针对路径golang中有一个专门的包<code>path</code></p>
<p>常用方法如下</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>filepath.IsAbs()</td>
<td>判断是否为绝对路径</td>
</tr>
<tr>
<td>filepath.Rel()</td>
<td>获取相对路径</td>
</tr>
<tr>
<td>filepath.Abs()</td>
<td>获取绝对路径</td>
</tr>
<tr>
<td>path.Join()</td>
<td>拼接路径</td>
</tr>
</tbody></table>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;path&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	path1 := <span class="string">&quot;/home/kain/Documents/code/go_module/file_io/main.go&quot;</span></span><br><span class="line">	path2 := <span class="string">&quot;./go.mod&quot;</span></span><br><span class="line">	path3 := <span class="string">&quot;go.mod&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(filepath.IsAbs(path1))	<span class="comment">// true</span></span><br><span class="line">	fmt.Println(filepath.IsAbs(path2))  <span class="comment">// false</span></span><br><span class="line">	fmt.Println(filepath.IsAbs(path3))  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(filepath.Rel(<span class="string">&quot;/home/kain&quot;</span>, path1))  <span class="comment">// Documents/code/go_module/file_io/main.go &lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(filepath.Abs(path1))	<span class="comment">// /home/kain/Documents/code/go_module/file_io/main.go &lt;nil&gt;</span></span><br><span class="line">	fmt.Println(filepath.Abs(path2))    <span class="comment">// /home/kain/Documents/code/go_module/file_io/go.mod &lt;nil&gt;</span></span><br><span class="line">	fmt.Println(filepath.Abs(path3))    <span class="comment">// /home/kain/Documents/code/go_module/file_io/go.mod &lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(path.Join(path1, <span class="string">&quot;.&quot;</span>))  <span class="comment">// /home/kain/Documents/code/go_module/file_io/main.go</span></span><br><span class="line">	fmt.Println(path.Join(path1, <span class="string">&quot;..&quot;</span>)) <span class="comment">// /home/kain/Documents/code/go_module/file_io</span></span><br><span class="line">	fmt.Println(path.Join(<span class="string">&quot;/home&quot;</span>, path2)) <span class="comment">// /home/go.mod</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="文件创建删除（目录）"><a href="#文件创建删除（目录）" class="headerlink" title="文件创建删除（目录）"></a>文件创建删除（目录）</h1><h2 id="检查文件是否存在"><a href="#检查文件是否存在" class="headerlink" title="检查文件是否存在"></a>检查文件是否存在</h2><p>golang中通过<code>Stat</code>返回的错误,然后调用<code>IsExist</code>或<code>IsNotExist</code>来判断是否存在</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(PathExist(<span class="string">&quot;test.txt&quot;</span>))    	<span class="comment">// true</span></span><br><span class="line">	<span class="built_in">println</span>(PathExist(<span class="string">&quot;go.mod&quot;</span>))       <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PathExist</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">	_, err := os.Stat(path)</span><br><span class="line">	<span class="keyword">return</span> os.IsNotExist(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><h3 id="os-MKdir"><a href="#os-MKdir" class="headerlink" title="os.MKdir()"></a>os.MKdir()</h3><p>该函数用于创建一层目录,定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mkdir creates a new directory with the specified name and permission</span></span><br><span class="line"><span class="comment">// bits (before umask).</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mkdir</span><span class="params">(name <span class="keyword">string</span>, perm FileMode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> runtime.GOOS == <span class="string">&quot;windows&quot;</span> &amp;&amp; isWindowsNulName(name) &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;PathError&#123;<span class="string">&quot;mkdir&quot;</span>, name, syscall.ENOTDIR&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	e := syscall.Mkdir(fixLongPath(name), syscallMode(perm))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;PathError&#123;<span class="string">&quot;mkdir&quot;</span>, name, e&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// mkdir(2) itself won&#x27;t handle the sticky bit on *BSD and Solaris</span></span><br><span class="line">	<span class="keyword">if</span> !supportsCreateWithStickyBit &amp;&amp; perm&amp;ModeSticky != <span class="number">0</span> &#123;</span><br><span class="line">		e = setStickyBit(name)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">			Remove(name)</span><br><span class="line">			<span class="keyword">return</span> e</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := os.MKdir(<span class="string">&quot;demo&quot;</span>, <span class="number">0777</span>)</span><br></pre></td></tr></table></figure>

<h3 id="os-MKdirAll"><a href="#os-MKdirAll" class="headerlink" title="os.MKdirAll()"></a>os.MKdirAll()</h3><p>该函数用于创建多层目录,定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MkdirAll</span><span class="params">(path <span class="keyword">string</span>, perm FileMode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Fast path: if we can tell whether path is a directory or file, stop with success or error.</span></span><br><span class="line">	dir, err := Stat(path)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> dir.IsDir() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;PathError&#123;<span class="string">&quot;mkdir&quot;</span>, path, syscall.ENOTDIR&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Slow path: make sure parent exists and then call Mkdir for path.</span></span><br><span class="line">	i := <span class="built_in">len</span>(path)</span><br><span class="line">	<span class="keyword">for</span> i &gt; <span class="number">0</span> &amp;&amp; IsPathSeparator(path[i<span class="number">-1</span>]) &#123; <span class="comment">// Skip trailing path separator.</span></span><br><span class="line">		i--</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	j := i</span><br><span class="line">	<span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; !IsPathSeparator(path[j<span class="number">-1</span>]) &#123; <span class="comment">// Scan backward over element.</span></span><br><span class="line">		j--</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> j &gt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="comment">// Create parent.</span></span><br><span class="line">		err = MkdirAll(fixRootDirectory(path[:j<span class="number">-1</span>]), perm)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Parent now exists; invoke Mkdir and use its result.</span></span><br><span class="line">	err = Mkdir(path, perm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Handle arguments like &quot;foo/.&quot; by</span></span><br><span class="line">		<span class="comment">// double-checking that directory doesn&#x27;t exist.</span></span><br><span class="line">		dir, err1 := Lstat(path)</span><br><span class="line">		<span class="keyword">if</span> err1 == <span class="literal">nil</span> &amp;&amp; dir.IsDir() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := os.MkdirAll(<span class="string">&quot;dir1/dir2/dir3&quot;</span>, os.ModePerm) <span class="comment">// os.ModePerm = 0777</span></span><br></pre></td></tr></table></figure>

<p>##　创建文件</p>
<h3 id="os-Creat"><a href="#os-Creat" class="headerlink" title="os.Creat()"></a>os.Creat()</h3><p>用该方法创建文本文件，如果文件已经存在，会将其覆盖，定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，他就是通过打开文件的方式来创建文件，通过 <code>O_TRUNC</code>标志，来覆盖原文件．</p>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Create(<span class="string">&quot;test.txt&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="删除文件（目录）"><a href="#删除文件（目录）" class="headerlink" title="删除文件（目录）"></a>删除文件（目录）</h2><h3 id="os-Remove"><a href="#os-Remove" class="headerlink" title="os.Remove()"></a>os.Remove()</h3><p>该方法用于删除文件或者空目录,定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// System call interface forces us to know</span></span><br><span class="line">	<span class="comment">// whether name is a file or directory.</span></span><br><span class="line">	<span class="comment">// Try both: it is cheaper on average than</span></span><br><span class="line">	<span class="comment">// doing a Stat plus the right one.</span></span><br><span class="line">	e := syscall.Unlink(name)</span><br><span class="line">	<span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	e1 := syscall.Rmdir(name)</span><br><span class="line">	<span class="keyword">if</span> e1 == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Both failed: figure out which error to return.</span></span><br><span class="line">	<span class="comment">// OS X and Linux differ on whether unlink(dir)</span></span><br><span class="line">	<span class="comment">// returns EISDIR, so can&#x27;t use that. However,</span></span><br><span class="line">	<span class="comment">// both agree that rmdir(file) returns ENOTDIR,</span></span><br><span class="line">	<span class="comment">// so we can use that to decide which error is real.</span></span><br><span class="line">	<span class="comment">// Rmdir might also return ENOTDIR if given a bad</span></span><br><span class="line">	<span class="comment">// file path, like /etc/passwd/foo, but in that case,</span></span><br><span class="line">	<span class="comment">// both errors will be ENOTDIR, so it&#x27;s okay to</span></span><br><span class="line">	<span class="comment">// use the error from unlink.</span></span><br><span class="line">	<span class="keyword">if</span> e1 != syscall.ENOTDIR &#123;</span><br><span class="line">		e = e1</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;PathError&#123;<span class="string">&quot;remove&quot;</span>, name, e&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := os.Remove(<span class="string">&quot;demo&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="os-RemoveAll"><a href="#os-RemoveAll" class="headerlink" title="os.RemoveAll()"></a>os.RemoveAll()</h3><p>该方法用于删除目录下面所有子节点,定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RemoveAll removes path and any children it contains.</span></span><br><span class="line"><span class="comment">// It removes everything it can but returns the first error</span></span><br><span class="line"><span class="comment">// it encounters. If the path does not exist, RemoveAll</span></span><br><span class="line"><span class="comment">// returns nil (no error).</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveAll</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> removeAll(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>removeAll()</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeAll</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> path == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// fail silently to retain compatibility with previous behavior</span></span><br><span class="line">		<span class="comment">// of RemoveAll. See issue 28830.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The rmdir system call does not permit removing &quot;.&quot;,</span></span><br><span class="line">	<span class="comment">// so we don&#x27;t permit it either.</span></span><br><span class="line">	<span class="keyword">if</span> endsWithDot(path) &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;PathError&#123;<span class="string">&quot;RemoveAll&quot;</span>, path, syscall.EINVAL&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Simple case: if Remove works, we&#x27;re done.</span></span><br><span class="line">	err := Remove(path)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> || IsNotExist(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// RemoveAll recurses by deleting the path base from</span></span><br><span class="line">	<span class="comment">// its parent directory</span></span><br><span class="line">	parentDir, base := splitPath(path)</span><br><span class="line"></span><br><span class="line">	parent, err := Open(parentDir)</span><br><span class="line">	<span class="keyword">if</span> IsNotExist(err) &#123;</span><br><span class="line">		<span class="comment">// If parent does not exist, base cannot exist. Fail silently</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> parent.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := removeAllFrom(parent, base); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> pathErr, ok := err.(*PathError); ok &#123;</span><br><span class="line">			pathErr.Path = parentDir + <span class="keyword">string</span>(PathSeparator) + pathErr.Path</span><br><span class="line">			err = pathErr</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := os.RemoveAll(<span class="string">&quot;dir1&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><p>对文件进行读写操作肯定要先打开文件</p>
<h2 id="打开关闭文件"><a href="#打开关闭文件" class="headerlink" title="打开关闭文件"></a>打开关闭文件</h2><h3 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h3><p>前面在创建文件时我们已经了解过了文件的打开,使用函数<code>os.OpenFile()</code>来实现,定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenFile is the generalized open call; most users will use Open</span></span><br><span class="line"><span class="comment">// or Create instead. It opens the named file with specified flag</span></span><br><span class="line"><span class="comment">// (O_RDONLY etc.). If the file does not exist, and the O_CREATE flag</span></span><br><span class="line"><span class="comment">// is passed, it is created with mode perm (before umask). If successful,</span></span><br><span class="line"><span class="comment">// methods on the returned File can be used for I/O.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line">   testlog.Open(name)</span><br><span class="line">   f, err := openFileNolog(name, flag, perm)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   f.appendMode = flag&amp;O_APPEND != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的内部是调用<code>openFileNolog</code>函数来实现,有兴趣的同学可以去了解一下</p>
<p>它接收的三个参数分别是文件路径,标志和权限,</p>
<p>标志就是打开方式,可以一种或多种,golang中的标志如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flags to OpenFile wrapping those of the underlying system. Not all</span></span><br><span class="line"><span class="comment">// flags may be implemented on a given system.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.</span></span><br><span class="line">	O_RDONLY <span class="keyword">int</span> = syscall.O_RDONLY <span class="comment">// open the file read-only.</span></span><br><span class="line">	O_WRONLY <span class="keyword">int</span> = syscall.O_WRONLY <span class="comment">// open the file write-only.</span></span><br><span class="line">	O_RDWR   <span class="keyword">int</span> = syscall.O_RDWR   <span class="comment">// open the file read-write.</span></span><br><span class="line">	<span class="comment">// The remaining values may be or&#x27;ed in to control behavior.</span></span><br><span class="line">	O_APPEND <span class="keyword">int</span> = syscall.O_APPEND <span class="comment">// append data to the file when writing.</span></span><br><span class="line">	O_CREATE <span class="keyword">int</span> = syscall.O_CREAT  <span class="comment">// create a new file if none exists.</span></span><br><span class="line">	O_EXCL   <span class="keyword">int</span> = syscall.O_EXCL   <span class="comment">// used with O_CREATE, file must not exist.</span></span><br><span class="line">	O_SYNC   <span class="keyword">int</span> = syscall.O_SYNC   <span class="comment">// open for synchronous I/O.</span></span><br><span class="line">	O_TRUNC  <span class="keyword">int</span> = syscall.O_TRUNC  <span class="comment">// truncate regular writable file when opened.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>权限只在文件不存在时创建文件需要,如果只是普通打开文件,权限填0即可,再如果知识简单得到只读一个已存在的文件,可以使用<code>os.Open()</code>函数来实现,这是它的定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open opens the named file for reading. If successful, methods on</span></span><br><span class="line"><span class="comment">// the returned file can be used for reading; the associated file</span></span><br><span class="line"><span class="comment">// descriptor has mode O_RDONLY.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> OpenFile(name, O_RDONLY, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不知道你们有没有发现,上述介绍的几个函数的第一个返回值是<code>os.File</code>类型的指针,这究竟是什么呢?</p>
<p>让我们来看看它的定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File represents an open file descriptor.</span></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">	*file <span class="comment">// os specific</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它又指向了<code>file</code>类型指针,那就看看这个<code>file</code>吧</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file is the real representation of *File.</span></span><br><span class="line"><span class="comment">// The extra level of indirection ensures that no clients of os</span></span><br><span class="line"><span class="comment">// can overwrite this data, which could cause the finalizer</span></span><br><span class="line"><span class="comment">// to close the wrong file descriptor.</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">	pfd         poll.FD</span><br><span class="line">	name        <span class="keyword">string</span></span><br><span class="line">	dirinfo     *dirInfo <span class="comment">// nil unless directory being read</span></span><br><span class="line">	nonblock    <span class="keyword">bool</span>     <span class="comment">// whether we set nonblocking mode</span></span><br><span class="line">	stdoutOrErr <span class="keyword">bool</span>     <span class="comment">// whether this is stdout or stderr</span></span><br><span class="line">	appendMode  <span class="keyword">bool</span>     <span class="comment">// whether file is opened for appending</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那个<code>FD</code>是文件描述符(file descriptor),有兴趣的同学可以展开看看<code>file</code>结构体的内部</p>
<p>下面我们来看看<code>File</code>结构体都支持哪些操作(这些方法可以在<code>file.go, stat_unix.go, file_unix.g, file_posix.go, dir.go</code>中找到)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">f.Fd()</span><br><span class="line">f.Stat()</span><br><span class="line">f.Name()</span><br><span class="line">f.Close()</span><br><span class="line">f.Write()</span><br><span class="line">f.Chdir()</span><br><span class="line">f.Chmod()</span><br><span class="line">f.Chown()</span><br><span class="line">f.Read()</span><br><span class="line">f.ReadAt()</span><br><span class="line">f.Readdir()</span><br><span class="line">f.Readdirnames()</span><br><span class="line">f.Seek()</span><br><span class="line">f.SetDeadline()</span><br><span class="line">f.SetReadDeadline()</span><br><span class="line">f.Sync()</span><br><span class="line">f.SyscallConn()</span><br><span class="line">f.Truncate()</span><br><span class="line">f.WriteAt()</span><br><span class="line">f.WriteString()</span><br></pre></td></tr></table></figure>

<p>虽然方法很多,但是常用的也就几个,无非是读写和关闭.下面我将介绍几个常用的函数,其余的你们有兴趣就去了解吧</p>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p><code>f.Close()</code>关闭一个打开的文件,方法定义如下,</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> f == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrInvalid</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f.file.<span class="built_in">close</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>f.file.close()</code>来关闭文件,这里就不深入了</p>
<h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p><code>f.Read()</code>读取文件内容,方法定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read reads up to len(b) bytes from the File.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes read and any error encountered.</span></span><br><span class="line"><span class="comment">// At end of file, Read returns 0, io.EOF.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := f.checkValid(<span class="string">&quot;read&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	n, e := f.read(b)</span><br><span class="line">	<span class="keyword">return</span> n, f.wrapErr(<span class="string">&quot;read&quot;</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>n代表实际读取的字节数,其本质是调用read函数来实现读取,继续深入发现 <code>read</code>函数调用了<code>f.pfd.Read()</code>,该函数最后调用了<code>fd.eofError()</code>方法,在该方法内部,如果读取到最末尾,返回<code>io.EOF</code>错误.</p>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f *os.File</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int</span>	<span class="comment">// 存放读取字节数</span></span><br><span class="line">	<span class="comment">// 初始化一个切片用于存放读取的数据</span></span><br><span class="line">	bs := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">8</span>, <span class="number">1024</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">	f,err = os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;文件打开失败&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 注意关闭文件</span></span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err = f.Read(bs)</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> || err == io.EOF&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;文件读取结束&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="keyword">string</span>(bs[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><h3 id="f-Write"><a href="#f-Write" class="headerlink" title="f.Write()"></a>f.Write()</h3><p>该方法用字节切片的方式写入文件,定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write writes len(b) bytes to the File.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes written and an error, if any.</span></span><br><span class="line"><span class="comment">// Write returns a non-nil error when n != len(b).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := f.checkValid(<span class="string">&quot;write&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	n, e := f.write(b)</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">		n = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n != <span class="built_in">len</span>(b) &#123;</span><br><span class="line">		err = io.ErrShortWrite</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	epipecheck(f, e)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = f.wrapErr(<span class="string">&quot;write&quot;</span>, e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f *os.File</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int</span>	<span class="comment">// 存放写入字节数</span></span><br><span class="line"></span><br><span class="line">	f, err = os.OpenFile(<span class="string">&quot;test.txt&quot;</span>, os.O_RDWR|os.O_CREATE|os.O_APPEND, os.ModePerm)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;文件打开失败&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 别忘了关闭文件</span></span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	n, err = f.Write([]<span class="keyword">byte</span>(<span class="string">&quot;123abc你好&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;写入文件失败&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;成功写入%d个字节\n&quot;</span>, n)　<span class="comment">// 一个汉字3个字节</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意, 写文件就不能通过<code>Open</code>函数来打开了,<code>Open</code>函数是只读的</p>
<p>利用标志<code>os.O_CREATE</code>,会在文件不存在时创建</p>
<p>利用标志<code>os.O_APPEND</code>,表示追加写入</p>
<h3 id="f-WriteString"><a href="#f-WriteString" class="headerlink" title="f.WriteString()"></a>f.WriteString()</h3><p>该方法用字符串的方式写入文件,定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteString is like Write, but writes the contents of string s rather than</span></span><br><span class="line"><span class="comment">// a slice of bytes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> f.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到他的本质就是给你转换成字节切片,这个示例我就不演示了,相信大家都能看懂</p>
<p>留个思考题:<em>请大家阅读相关源码并说明<code>os.fileState</code>和<code>os.file</code>这两个结构体有何不同,各自的使用场景又是什么?</em></p>
<p> 有答案的可以在评论区留言</p>
<p><strong>如果你看到这里你应该知道了如何使用golang来实现文件的相关操作,但是你们肯定和我一样,觉得golang的文件读写操作很麻烦.下面我们来了解一下文件操作的另外两种方法 <code>ioutil</code>和<code>bufio</code></strong>,下面内容部分参考了GO语言中文文档,但文档中的有些内容已经过时,我已经将它更新.</p>
<h1 id="ioutil"><a href="#ioutil" class="headerlink" title="ioutil"></a>ioutil</h1><p>正如其名字ioutil这是一个读写操作包,这里举例一些常用的方法</p>
<ul>
<li><p><code>func ReadFile(filename string) ([]byte, error)</code></p>
<p>ReadFile 从filename指定的文件中读取数据并返回文件的内容。成功的调用返回的err为nil而非EOF。因为本函数定义为读取整个文件，它不会将读取返回的EOF视为应报告的错误。</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	f, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="comment">// It&#x27;s a good but not certain bet that FileInfo will tell us exactly how much to</span></span><br><span class="line">	<span class="comment">// read, so let&#x27;s try it but be prepared for the answer to be wrong.</span></span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int64</span> = bytes.MinRead</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fi, err := f.Stat(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// As initial capacity for readAll, use Size + a little extra in case Size</span></span><br><span class="line">		<span class="comment">// is zero, and to avoid another allocation after Read has filled the</span></span><br><span class="line">		<span class="comment">// buffer. The readAll call will read into its allocated internal buffer</span></span><br><span class="line">		<span class="comment">// cheaply. If the size was wrong, we&#x27;ll either waste some space off the end</span></span><br><span class="line">		<span class="comment">// or reallocate as needed, but in the overwhelmingly common case we&#x27;ll get</span></span><br><span class="line">		<span class="comment">// it just right.</span></span><br><span class="line">		<span class="keyword">if</span> size := fi.Size() + bytes.MinRead; size &gt; n &#123;</span><br><span class="line">			n = size</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> readAll(f, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出,ReadFile函数本质也是利用os.File结构体,并调用<code>readAll</code>函数处理,这里就不深入了,感兴趣的同学可以去看看,</p>
<p>例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bs, err := ioutil.ReadFile(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;文件打开出错&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(<span class="keyword">string</span>(bs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>func WriteFile(filename string, data []byte, perm os.FileMode) error</code></p>
<p>函数向filename指定的文件中写入数据。如果文件不存在将按给出的权限创建文件，否则在写入数据之前清空文件。</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteFile writes data to a file named by filename.</span></span><br><span class="line"><span class="comment">// If the file does not exist, WriteFile creates it with permissions perm</span></span><br><span class="line"><span class="comment">// (before umask); otherwise WriteFile truncates it before writing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="keyword">string</span>, data []<span class="keyword">byte</span>, perm os.FileMode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	f, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = f.Write(data)</span><br><span class="line">	<span class="keyword">if</span> err1 := f.Close(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">		err = err1</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你没看错这就是这个函数的源码,是不是非常眼熟,这和我们之前写的代码十分相似.</p>
<p>例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := ioutil.WriteFile(<span class="string">&quot;hello.txt&quot;</span>, []<span class="keyword">byte</span>(<span class="string">&quot;hello世界&quot;</span>),os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;文件打开失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>func ReadDir(dirname string) ([]os.FileInfo, error)</code></p>
<p>返回dirname指定的目录的目录信息的有序列表。</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadDir reads the directory named by dirname and returns</span></span><br><span class="line"><span class="comment">// a list of directory entries sorted by filename.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadDir</span><span class="params">(dirname <span class="keyword">string</span>)</span> <span class="params">([]os.FileInfo, error)</span></span> &#123;</span><br><span class="line">	f, err := os.Open(dirname)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	list, err := f.Readdir(<span class="number">-1</span>)</span><br><span class="line">	f.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Slice(list, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> list[i].Name() &lt; list[j].Name() &#125;)</span><br><span class="line">	<span class="keyword">return</span> list, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的底层也是利用<code>os.File</code>结构体,然后调用os.File的Readdir方法,并对结构进行排序输出</p>
<p>例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fs, err := ioutil.ReadDir(<span class="string">&quot;dir1&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;文件打开失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> fs&#123;</span><br><span class="line">		fmt.Println(i, v.Name(), v.IsDir(), v.Size(), v.ModTime())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>func ReadAll(r io.Reader) ([]byte, error)</code></p>
<p>ReadAll读取数据直到EOF或遇到error，返回读取的数据和遇到的错误。成功的调用返回的err为nil而非EOF。因为本函数定义为读取r直到EOF，它不会将读取返回的EOF视为应报告的错误。</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadAll reads from r until an error or EOF and returns the data it read.</span></span><br><span class="line"><span class="comment">// A successful call returns err == nil, not err == EOF. Because ReadAll is</span></span><br><span class="line"><span class="comment">// defined to read from src until EOF, it does not treat an EOF from Read</span></span><br><span class="line"><span class="comment">// as an error to be reported.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> readAll(r, bytes.MinRead)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它接收一个参数类型为<code>io.Reader</code>,通过读源码可以看出它就是一个实现了<code>Read</code>函数的接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经知道<code>os.File</code>就是实现了<code>Read</code>方法,所以我们可以将一个<code>os.File</code>结构体传进去,</p>
<p>例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> bs []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> f *os.File</span><br><span class="line"></span><br><span class="line">	f, err = os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;打开文件失败&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	bs, err = ioutil.ReadAll(f)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;文件读取失败&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(<span class="keyword">string</span>(bs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难发现<code>ReadFile</code>和<code>ReadAll</code>方法非常的像,只不过<code>ReadFile</code>方法内部对文件进打开操作,而<code>ReadAll</code>是在外面手动打开文件然后传进去</p>
</li>
<li><p><code>func TempDir(dir, pattern string) (name string, err error) </code></p>
<p>在dir目录里创建一个新的临时文件夹(其实本质就是普通文件,用作临时存储场景,需要手动删除),该文件夹的命名规则如下,使用将<code>pattern</code>用<code>*</code>分开,取最后一个做后缀,前面的做前缀,中间拼接随机数字,该操作可在其源码中看到,如下</p>
</li>
</ul>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">(dir, pattern <span class="keyword">string</span>)</span> <span class="params">(name <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> dir == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		dir = os.TempDir()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	prefix, suffix := prefixAndSuffix(pattern)</span><br><span class="line"></span><br><span class="line">	nconflict := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		try := filepath.Join(dir, prefix+nextRandom()+suffix)</span><br><span class="line">		err = os.Mkdir(try, <span class="number">0700</span>)</span><br><span class="line">		<span class="keyword">if</span> os.IsExist(err) &#123;</span><br><span class="line">			<span class="keyword">if</span> nconflict++; nconflict &gt; <span class="number">10</span> &#123;</span><br><span class="line">				randmu.Lock()</span><br><span class="line">				rand = reseed()</span><br><span class="line">				randmu.Unlock()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">			<span class="keyword">if</span> _, err := os.Stat(dir); os.IsNotExist(err) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			name = try</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  其中<code>prefixAndSuffix</code>函数定义如下</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prefixAndSuffix</span><span class="params">(pattern <span class="keyword">string</span>)</span> <span class="params">(prefix, suffix <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> pos := strings.LastIndex(pattern, <span class="string">&quot;*&quot;</span>); pos != <span class="number">-1</span> &#123;</span><br><span class="line">		prefix, suffix = pattern[:pos], pattern[pos+<span class="number">1</span>:]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		prefix = pattern</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  举个例子</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	name, err := ioutil.TempDir(<span class="string">&quot;dir1&quot;</span>, <span class="string">&quot;kain*huck&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;文件夹创建失败&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(name) <span class="comment">// dir1/kain037615429huck</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p><code>func TempFile(dir, pattern string) (f *os.File, err error)</code></p>
<p>在dir目录下创建一个新的临时文件,文件名是通过使用pattern并在末尾添加一个随机字符串生成的。如果pattern包含一个“*”，随机字符串将替换最后一个“*”。</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempFile</span><span class="params">(dir, pattern <span class="keyword">string</span>)</span> <span class="params">(f *os.File, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> dir == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		dir = os.TempDir()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	prefix, suffix := prefixAndSuffix(pattern)</span><br><span class="line"></span><br><span class="line">	nconflict := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">		name := filepath.Join(dir, prefix+nextRandom()+suffix)</span><br><span class="line">		f, err = os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, <span class="number">0600</span>)</span><br><span class="line">		<span class="keyword">if</span> os.IsExist(err) &#123;</span><br><span class="line">			<span class="keyword">if</span> nconflict++; nconflict &gt; <span class="number">10</span> &#123;</span><br><span class="line">				randmu.Lock()</span><br><span class="line">				rand = reseed()</span><br><span class="line">				randmu.Unlock()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f, err := ioutil.TempFile(<span class="string">&quot;dir1&quot;</span>, <span class="string">&quot;kain*huck&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;文件创建失败&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(f.Name())	<span class="comment">// dir1/kain115329465huck</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="bufio"><a href="#bufio" class="headerlink" title="bufio"></a>bufio</h1><p>bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，创建另一个也实现了该接口，且同时还提供了缓冲和一些文本I/O的帮助函数的对象。</p>
<h2 id="bufio-Reader"><a href="#bufio-Reader" class="headerlink" title="bufio.Reader"></a><code>bufio.Reader</code></h2><p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reader implements buffering for an io.Reader object.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">	buf          []<span class="keyword">byte</span></span><br><span class="line">	rd           io.Reader <span class="comment">// reader provided by the client</span></span><br><span class="line">	r, w         <span class="keyword">int</span>       <span class="comment">// buf read and write positions</span></span><br><span class="line">	err          error</span><br><span class="line">	lastByte     <span class="keyword">int</span> <span class="comment">// last byte read for UnreadByte; -1 means invalid</span></span><br><span class="line">	lastRuneSize <span class="keyword">int</span> <span class="comment">// size of last rune read for UnreadRune; -1 means invalid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<ul>
<li><p><code>func NewReader(rd io.Reader) *Reader</code></p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewReader returns a new Reader whose buffer has the default size.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewReaderSize(rd, defaultBufSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NewReader调用<code>NewReaderSize</code>创建一个具有默认大小缓冲的Reader指针</p>
<p>defauleBufSize</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	defaultBufSize = <span class="number">4096</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>func NewReaderSize(rd io.Reader, size int) *Reader</code></p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewReaderSize returns a new Reader whose buffer has at least the specified</span></span><br><span class="line"><span class="comment">// size. If the argument io.Reader is already a Reader with large enough</span></span><br><span class="line"><span class="comment">// size, it returns the underlying Reader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="keyword">int</span>)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line">	<span class="comment">// Is it already a Reader?</span></span><br><span class="line">	b, ok := rd.(*Reader)</span><br><span class="line">	<span class="keyword">if</span> ok &amp;&amp; <span class="built_in">len</span>(b.buf) &gt;= size &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> size &lt; minReadBufferSize &#123;</span><br><span class="line">		size = minReadBufferSize</span><br><span class="line">	&#125;</span><br><span class="line">	r := <span class="built_in">new</span>(Reader)</span><br><span class="line">	r.reset(<span class="built_in">make</span>([]<span class="keyword">byte</span>, size), rd)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数就是上述<code>NewReader</code>中被调用的函数,他可以让我们手动的提供缓冲大小,从代码可以看到,所谓缓冲就是一个byte切片,该切片会被赋值给<code>Reader</code>结构体的<code>buf</code>,</p>
<p>reset</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">reset</span><span class="params">(buf []<span class="keyword">byte</span>, r io.Reader)</span></span> &#123;</span><br><span class="line">	*b = Reader&#123;</span><br><span class="line">		buf:          buf,</span><br><span class="line">		rd:           r,</span><br><span class="line">		lastByte:     <span class="number">-1</span>,</span><br><span class="line">		lastRuneSize: <span class="number">-1</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>func (b *Reader) Reset(r io.Reader)</code></p>
<p>Reset丢弃缓冲中的数据，清除任何错误，将b重设为其下层从r读取数据。</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reset discards any buffered data, resets all state, and switches</span></span><br><span class="line"><span class="comment">// the buffered reader to read from r.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Reset</span><span class="params">(r io.Reader)</span></span> &#123;</span><br><span class="line">	b.reset(b.buf, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其内部实现非常简单,就是调用函数<code>reset</code>(这个函数在上面已经看过了),将当前的<code>Reader</code>中的<code>rd</code>属性(io.Reader)重新重设为<code>r</code></p>
</li>
<li><p><code>func (b *Reader) Buffered() int</code></p>
<p>Buffered返回缓冲中现有的可读取的字节数。</p>
<p>定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffered returns the number of bytes that can be read from the current buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> b.w - b.r &#125;</span><br></pre></td></tr></table></figure>

<p>这个就不解释了</p>
</li>
<li><p><code>func (b *Reader) Peek(n int) ([]byte, error)</code></p>
<p>Peek返回输入流的下n个字节，而不会移动读取位置。返回的[]byte只在下一次调用读取操作前合法。如果Peek返回的切片长度比n小，它也会返会一个错误说明原因。如果n比缓冲尺寸还大，返回的错误将是ErrBufferFull。</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Peek</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrNegativeCount</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	b.lastByte = <span class="number">-1</span></span><br><span class="line">	b.lastRuneSize = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> b.w-b.r &lt; n &amp;&amp; b.w-b.r &lt; <span class="built_in">len</span>(b.buf) &amp;&amp; b.err == <span class="literal">nil</span> &#123;</span><br><span class="line">		b.fill() <span class="comment">// b.w-b.r &lt; len(b.buf) =&gt; buffer is not full</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="built_in">len</span>(b.buf) &#123;</span><br><span class="line">		<span class="keyword">return</span> b.buf[b.r:b.w], ErrBufferFull</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0 &lt;= n &lt;= len(b.buf)</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">if</span> avail := b.w - b.r; avail &lt; n &#123;</span><br><span class="line">		<span class="comment">// not enough data in buffer</span></span><br><span class="line">		n = avail</span><br><span class="line">		err = b.readErr()</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			err = ErrBufferFull</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.buf[b.r : b.r+n], err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>别看前面这么多,那都是一些特殊情况的判断处理,看最后一句得知其实该函数就是返回了缓冲区的切</p>
</li>
<li><p><code>func (b *Reader) Read(p []byte) (n int, err error)</code></p>
<p>Read读取数据写入p。本方法返回写入p的字节数。本方法一次调用最多会调用下层Reader接口一次Read方法，因此返回值n可能小于len(p)。读取到达结尾时，返回值n将为0而err将为io.EOF。</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	n = <span class="built_in">len</span>(p)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> b.Buffered() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, b.readErr()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b.r == b.w &#123;</span><br><span class="line">		<span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, b.readErr()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= <span class="built_in">len</span>(b.buf) &#123;</span><br><span class="line">			<span class="comment">// Large read, empty buffer.</span></span><br><span class="line">			<span class="comment">// Read directly into p to avoid copy.</span></span><br><span class="line">			n, b.err = b.rd.Read(p)</span><br><span class="line">			<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(errNegativeRead)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">				b.lastByte = <span class="keyword">int</span>(p[n<span class="number">-1</span>])</span><br><span class="line">				b.lastRuneSize = <span class="number">-1</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> n, b.readErr()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// One read.</span></span><br><span class="line">		<span class="comment">// Do not use b.fill, which will loop.</span></span><br><span class="line">		b.r = <span class="number">0</span></span><br><span class="line">		b.w = <span class="number">0</span></span><br><span class="line">		n, b.err = b.rd.Read(b.buf)</span><br><span class="line">		<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(errNegativeRead)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, b.readErr()</span><br><span class="line">		&#125;</span><br><span class="line">		b.w += n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// copy as much as we can</span></span><br><span class="line">	n = <span class="built_in">copy</span>(p, b.buf[b.r:b.w])</span><br><span class="line">	b.r += n</span><br><span class="line">	b.lastByte = <span class="keyword">int</span>(b.buf[b.r<span class="number">-1</span>])</span><br><span class="line">	b.lastRuneSize = <span class="number">-1</span></span><br><span class="line">	<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中可以看到<code>n, b.err = b.rd.Read(p)</code>,说明这内部是调用io.Read方法.然后将buf中的可用内容尽可能的复制给p.</p>
<p>鉴于篇幅过长,以下其他常用方法就留给读者自己去分析吧,</p>
<ul>
<li><p><code>func (b *Reader) ReadByte() (c byte, err error)</code></p>
<p>ReadByte读取并返回一个字节。如果没有可用的数据，会返回错误。</p>
</li>
<li><p><code>func (b *Reader) ReadRune() (r rune, size int, err error)</code></p>
<p>ReadRune读取一个utf-8编码的unicode码值，返回该码值、其编码长度和可能的错误。如果utf-8编码非法，读取位置只移动1字节，返回U+FFFD，返回值size为1而err为nil。如果没有可用的数据，会返回错误。</p>
</li>
<li><p><code>func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</code></p>
<p>ReadLine是一个低水平的行数据读取原语。大多数调用者应使用ReadBytes(‘\n’)或ReadString(‘\n’)代替，或者使用Scanner。</p>
<p>ReadLine尝试返回一行数据，不包括行尾标志的字节。如果行太长超过了缓冲，返回值isPrefix会被设为true，并返回行的前面一部分。该行剩下的部分将在之后的调用中返回。返回值isPrefix会在返回该行最后一个片段时才设为false。返回切片是缓冲的子切片，只在下一次读取操作之前有效。ReadLine要么返回一个非nil的line，要么返回一个非nil的err，两个返回值至少一个非nil。</p>
<p>返回的文本不包含行尾的标志字节（”\r\n”或”\n”）。如果输入流结束时没有行尾标志字节，方法不会出错，也不会指出这一情况。在调用ReadLine之后调用UnreadByte会总是吐出最后一个读取的字节（很可能是该行的行尾标志字节），即使该字节不是ReadLine返回值的一部分。</p>
</li>
<li><p><code>func (b *Reader) ReadString(delim byte) (string, error)</code></p>
<p>ReadString读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的字符串。如果ReadString方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadString方法返回的切片不以delim结尾时，会返回一个非nil的错误。</p>
</li>
<li><p><code>func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</code></p>
<p>ReadSlice读取直到第一次遇到delim字节，返回缓冲里的包含已读取的数据和delim字节的切片。该返回值只在下一次读取操作之前合法。如果ReadSlice放在在读取到delim之前遇到了错误，它会返回在错误之前读取的数据在缓冲中的切片以及该错误（一般是io.EOF）。如果在读取到delim之前缓冲就被写满了，ReadSlice失败并返回ErrBufferFull。因为ReadSlice的返回值会被下一次I/O操作重写，调用者应尽量使用ReadBytes或ReadString替代本法功法。当且仅当ReadBytes方法返回的切片不以delim结尾时，会返回一个非nil的错误。</p>
</li>
<li><p><code>func (b *Reader) ReadBytes(delim byte) ([]byte, error)</code></p>
<p>ReadBytes读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的切片。如果ReadBytes方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadBytes方法返回的切片不以delim结尾时，会返回一个非nil的错误。</p>
</li>
</ul>
<p>例子1:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f,err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	reader := bufio.NewReader(f)</span><br><span class="line">	p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">12</span>)</span><br><span class="line">	n, err :=reader.Read(p)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp;  err != io.EOF &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(n)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(p))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子2:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f,err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	reader := bufio.NewReader(f)</span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF&#123;</span><br><span class="line">			fmt.Println(str)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(str)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="bufio-Writer"><a href="#bufio-Writer" class="headerlink" title="bufio.Writer"></a><code>bufio.Writer</code></h2><p><code>bufio.Writer</code>其实和<code>bufio.Reader</code>操作很对应.</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Writer implements buffering for an io.Writer object.</span></span><br><span class="line"><span class="comment">// If an error occurs writing to a Writer, no more data will be</span></span><br><span class="line"><span class="comment">// accepted and all subsequent writes, and Flush, will return the error.</span></span><br><span class="line"><span class="comment">// After all data has been written, the client should call the</span></span><br><span class="line"><span class="comment">// Flush method to guarantee all data has been forwarded to</span></span><br><span class="line"><span class="comment">// the underlying io.Writer.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">struct</span> &#123;</span><br><span class="line">	err error</span><br><span class="line">	buf []<span class="keyword">byte</span></span><br><span class="line">	n   <span class="keyword">int</span></span><br><span class="line">	wr  io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面列举几个最最常用的方法</p>
<ul>
<li><p><code>func NewWriter(w io.Writer) *Writer</code></p>
<p>NewWriter创建一个具有默认大小缓冲、写入w的*Writer。</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewWriter returns a new Writer whose buffer has the default size.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span> *<span class="title">Writer</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewWriterSize(w, defaultBufSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法调用<code>NewWriterSize</code>,返回一个带有默认缓冲区的<code>Writer</code>指针</p>
<p>defaultBufSize</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	defaultBufSize = <span class="number">4096</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>func NewWriterSize(w io.Writer, size int) *Writer</code></p>
<p>NewWriterSize创建一个具有最少有size尺寸的缓冲、写入w的<em>Writer。如果参数w已经是一个具有足够大缓冲的</em>Writer类型值，会返回w。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewWriterSize returns a new Writer whose buffer has at least the specified</span></span><br><span class="line"><span class="comment">// size. If the argument io.Writer is already a Writer with large enough</span></span><br><span class="line"><span class="comment">// size, it returns the underlying Writer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriterSize</span><span class="params">(w io.Writer, size <span class="keyword">int</span>)</span> *<span class="title">Writer</span></span> &#123;</span><br><span class="line">	<span class="comment">// Is it already a Writer?</span></span><br><span class="line">	b, ok := w.(*Writer)</span><br><span class="line">	<span class="keyword">if</span> ok &amp;&amp; <span class="built_in">len</span>(b.buf) &gt;= size &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> size &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		size = defaultBufSize</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;Writer&#123;</span><br><span class="line">		buf: <span class="built_in">make</span>([]<span class="keyword">byte</span>, size),</span><br><span class="line">		wr:  w,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的实现过程和<code>NewReaderSize</code>如出一辙,只不过<code>NewReaderSize</code>中调用了<code>reset</code>方法,这里直接初始化指针对象</p>
</li>
<li><p><code>func (b *Writer) Reset(w io.Writer)</code></p>
<p>Reset丢弃缓冲中的数据，清除任何错误，将b重设为将其输出写入w。</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reset discards any unflushed buffered data, clears any error, and</span></span><br><span class="line"><span class="comment">// resets b to write its output to w.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Reset</span><span class="params">(w io.Writer)</span></span> &#123;</span><br><span class="line">	b.err = <span class="literal">nil</span></span><br><span class="line">	b.n = <span class="number">0</span></span><br><span class="line">	b.wr = w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就不多做解释了,一眼就明白</p>
</li>
<li><p><code>func (b *Writer) Buffered()</code></p>
<p>Buffered返回缓冲中已使用的字节数。</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffered returns the number of bytes that have been written into the current buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> b.n &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就更不用解释了</p>
</li>
<li><p><code>func (b *Writer) Available() int</code></p>
<p>Available返回缓冲中还有多少字节未使用。</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Available returns how many bytes are unused in the buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Available</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(b.buf) - b.n &#125;</span><br></pre></td></tr></table></figure>

<p>不解释</p>
</li>
<li><p><code>func (b *Writer) Write(p []byte) (nn int, err error)</code></p>
<p>Write将p的内容写入缓冲。返回写入的字节数。如果返回值nn &lt; len(p)，还会返回一个错误说明原因。</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(nn <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(p) &gt; b.Available() &amp;&amp; b.err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">		<span class="keyword">if</span> b.Buffered() == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Large write, empty buffer.</span></span><br><span class="line">			<span class="comment">// Write directly from p to avoid copy.</span></span><br><span class="line">			n, b.err = b.wr.Write(p)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			n = <span class="built_in">copy</span>(b.buf[b.n:], p)</span><br><span class="line">			b.n += n</span><br><span class="line">			b.Flush()</span><br><span class="line">		&#125;</span><br><span class="line">		nn += n</span><br><span class="line">		p = p[n:]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nn, b.err</span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="built_in">copy</span>(b.buf[b.n:], p)</span><br><span class="line">	b.n += n</span><br><span class="line">	nn += n</span><br><span class="line">	<span class="keyword">return</span> nn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>n, b.err = b.wr.Write(p)</code>可得这是通过调用<code>io.Writer</code>接口中的<code>Write</code>方法,</p>
<p><code>n := copy(b.buf[b.n:], p)</code>这一句和前面Read方法刚好相反,这是将p复制给buf的可用部分</p>
</li>
<li><p><code>func (b *Writer) WriteString(s string) (int, error)</code></p>
<p>WriteString写入一个字符串。返回写入的字节数。如果返回值nn &lt; len(s)，还会返回一个错误说明原因。</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	nn := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(s) &gt; b.Available() &amp;&amp; b.err == <span class="literal">nil</span> &#123;</span><br><span class="line">		n := <span class="built_in">copy</span>(b.buf[b.n:], s)</span><br><span class="line">		b.n += n</span><br><span class="line">		nn += n</span><br><span class="line">		s = s[n:]</span><br><span class="line">		b.Flush()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nn, b.err</span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="built_in">copy</span>(b.buf[b.n:], s)</span><br><span class="line">	b.n += n</span><br><span class="line">	nn += n</span><br><span class="line">	<span class="keyword">return</span> nn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键语句<code>n := copy(b.buf[b.n:], s)</code>不解释</p>
</li>
<li><p><code>func (b *Writer) Flush() error</code></p>
<p>Flush方法将缓冲中的数据写入下层的io.Writer接口。</p>
<p>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Flush</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b.err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b.n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	n, err := b.wr.Write(b.buf[<span class="number">0</span>:b.n])</span><br><span class="line">	<span class="keyword">if</span> n &lt; b.n &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">		err = io.ErrShortWrite</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; n &lt; b.n &#123;</span><br><span class="line">			<span class="built_in">copy</span>(b.buf[<span class="number">0</span>:b.n-n], b.buf[n:b.n])</span><br><span class="line">		&#125;</span><br><span class="line">		b.n -= n</span><br><span class="line">		b.err = err</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	b.n = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释一下,如果b有错误就直接返回错误,如果b中没有写入值,则不做任何处理,否则就将缓冲中的n个值写进底层io.Writer中,如果写入的值数量小于缓冲取的值并且没有出错,则将err定义为<code>io.ErrShortWrite</code>错误,如果err不为空,并且写进底层<code>io.Writer</code>中的数据小于缓冲中原有的数据时,将剩余的数据写进缓冲区开头,将缓冲区已用空间设置为原来大小减去写人底层大小.如果err为空则代表成功将所有缓冲数据写入<code>io.Writer</code>将已用空间置为0</p>
</li>
</ul>
<p>其他<code>bufio</code>中的方法就留给读者自己去探索吧!</p>
<p>举个例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f, err := os.OpenFile(<span class="string">&quot;test.txt&quot;</span>, os.O_RDWR|os.O_CREATE|os.O_APPEND, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	writer := bufio.NewWriter(f)</span><br><span class="line">	writer.WriteString(<span class="string">&quot;让我康康是哪位靓仔看到了这句话\n&quot;</span>)</span><br><span class="line">	writer.Write([]<span class="keyword">byte</span>(<span class="string">&quot;原来是你!\n&quot;</span>))</span><br><span class="line"></span><br><span class="line">	writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:最后一定要flush一下,否则数据就不会写入文件,注意使用<code>OpenFile</code>函数打开文件并指定可写,否则将写不进去.</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">1.</span> <span class="toc-text">获取文件信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FileInfo%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text">FileInfo接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fileStat%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.</span> <span class="toc-text">fileStat结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.</span> <span class="toc-text">查看文件信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.</span> <span class="toc-text">文件路径</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%EF%BC%88%E7%9B%AE%E5%BD%95%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">文件创建删除（目录）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">2.1.</span> <span class="toc-text">检查文件是否存在</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">2.2.</span> <span class="toc-text">创建目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#os-MKdir"><span class="toc-number">2.2.1.</span> <span class="toc-text">os.MKdir()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#os-MKdirAll"><span class="toc-number">2.2.2.</span> <span class="toc-text">os.MKdirAll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#os-Creat"><span class="toc-number">2.2.3.</span> <span class="toc-text">os.Creat()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%EF%BC%88%E7%9B%AE%E5%BD%95%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">删除文件（目录）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#os-Remove"><span class="toc-number">2.3.1.</span> <span class="toc-text">os.Remove()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#os-RemoveAll"><span class="toc-number">2.3.2.</span> <span class="toc-text">os.RemoveAll()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">读写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">打开关闭文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80"><span class="toc-number">3.1.1.</span> <span class="toc-text">打开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD"><span class="toc-number">3.1.2.</span> <span class="toc-text">关闭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">读文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#f-Write"><span class="toc-number">3.3.1.</span> <span class="toc-text">f.Write()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#f-WriteString"><span class="toc-number">3.3.2.</span> <span class="toc-text">f.WriteString()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ioutil"><span class="toc-number">4.</span> <span class="toc-text">ioutil</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bufio"><span class="toc-number">5.</span> <span class="toc-text">bufio</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bufio-Reader"><span class="toc-number">5.1.</span> <span class="toc-text">bufio.Reader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bufio-Writer"><span class="toc-number">5.2.</span> <span class="toc-text">bufio.Writer</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&text=从源码解读golang文件操作"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&title=从源码解读golang文件操作"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&is_video=false&description=从源码解读golang文件操作"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=从源码解读golang文件操作&body=Check out this article: https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&title=从源码解读golang文件操作"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&title=从源码解读golang文件操作"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&title=从源码解读golang文件操作"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&title=从源码解读golang文件操作"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&name=从源码解读golang文件操作&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://kainhuck.github.io/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/&t=从源码解读golang文件操作"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2020
    KainHuck
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
