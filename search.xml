<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python-快速排序</title>
      <link href="/2020/09/01/python-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/09/01/python-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序算法流程"><a href="#快速排序算法流程" class="headerlink" title="快速排序算法流程"></a>快速排序算法流程</h2><ol><li>选定一个基准值(任意选,以第一个为例)</li><li>定义左右指针指向左右两端</li><li>左指针往右移动,如果遇到大于基准值的数就把它和右指针的值调换位置,然后左指针不动,右指针开始向左移动,如果遇到小于基准值的数就把他和左指针的值调换位置,然后开始移动左指针,以此类推,知道左右指针相遇</li><li>递归上述过程知道排序结束</li></ol><h2 id="用python实现"><a href="#用python实现" class="headerlink" title="用python实现"></a>用python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">intList: list</span>) -&gt; list:</span></span><br><span class="line">    <span class="comment"># 如果长度小于等于1就结束</span></span><br><span class="line">    <span class="keyword">if</span> len(intList) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> intList</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 将第一个值选为基准值</span></span><br><span class="line">    flag = intList[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 定义左右指针</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(intList) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> intList[i] &gt; flag:</span><br><span class="line">            intList[i], intList[right] = intList[right], intList[i]</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            intList[i], intList[left] = intList[left], intList[i]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 传列表的切片不会改变本身变量所以需要返回</span></span><br><span class="line">    leftList = quickSort(intList[:left])</span><br><span class="line">    rightList = quickSort(intList[left+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> leftList + [flag] + rightList</span><br></pre></td></tr></table></figure><h2 id="一行代码实现快排"><a href="#一行代码实现快排" class="headerlink" title="一行代码实现快排"></a>一行代码实现快排</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quick_sort = <span class="keyword">lambda</span> array: array <span class="keyword">if</span> len(array) &lt;= <span class="number">1</span> <span class="keyword">else</span> quick_sort([item <span class="keyword">for</span> item <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> item &lt;= array[<span class="number">0</span>]]) + [array[<span class="number">0</span>]] + quick_sort([item <span class="keyword">for</span> item <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> item &gt; array[<span class="number">0</span>]])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Telegram Bot使用文档</title>
      <link href="/2020/09/01/Telegram-Bot%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
      <url>/2020/09/01/Telegram-Bot%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://core.telegram.org/bots/api">官方文档</a></p><h2 id="创建机器人"><a href="#创建机器人" class="headerlink" title="创建机器人"></a>创建机器人</h2><p>在telegram中我们可以通过和一个名为<code>BotFather</code>的机器人交互来申请我们自己的机器人，具体步骤如下</p><ol><li><p>添加BotFather为好友</p><p><a href="https://telegram.me/botfather">点击这里</a>添加botfather</p></li><li><p>打开和botfather的对话框发送 <code>/newbot</code></p><p>这一步过后botfather会提示你输入你要创建的机器人的名字，这个名字可以随意，是我们称呼它的名字</p></li><li><p>设置自定义机器人的名字（这个名字不同于上一步的名字，这个名字是唯一的）结尾必须是<code>_bot</code>或者<code>Bot</code>，不能包含中文, 标点符号</p></li><li><p>如果上一步执行成功那么botfather会返回该机器人的token，大概长这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123456789:ABCDEfghiJK4314daDSadSa7</span><br></pre></td></tr></table></figure><p>记住这个token,到这里机器人就创建好了</p></li></ol><h2 id="将机器人添加到群组里"><a href="#将机器人添加到群组里" class="headerlink" title="将机器人添加到群组里"></a>将机器人添加到群组里</h2><p>进入机器人信息页面，点击<code>更多</code>，点击<code>添加到群组</code>，选择一个群组即可</p><h2 id="获取群组chat-id"><a href="#获取群组chat-id" class="headerlink" title="获取群组chat_id"></a>获取群组chat_id</h2><p>通常来说我们都需要让机器人在一个群组里工作，所以首先我们需要将机器人添加到我们指定的群组，在群组里发送随意消息并@这个机器人，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello @your_bot</span><br></pre></td></tr></table></figure><p>然后浏览器打开这个链接，注意替换为你的token</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.telegram.org&#x2F;bot&lt;token&gt;&#x2F;getUpdates</span><br></pre></td></tr></table></figure><p>你看到的是一个json，格式如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ok&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;update_id&quot;</span>: <span class="number">414941268</span>,</span><br><span class="line">      <span class="attr">&quot;message&quot;</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;chat&quot;: &#123;</span><br><span class="line">          &quot;id&quot;: -465512321,</span><br><span class="line">          ...</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中找到chat.id这就是当前群组的id,以后发消息都是发到这个id.</p><h2 id="机器人发送请求"><a href="#机器人发送请求" class="headerlink" title="机器人发送请求"></a>机器人发送请求</h2><h3 id="请求接口"><a href="#请求接口" class="headerlink" title="请求接口"></a>请求接口</h3><p>telegram发送消息的方式类似与钉钉机器人，都是向一个api发送http请求，而且对于同一个API<code>telegram</code>支持<code>GET</code>和<code>POST</code>两种请求方式.请求的api格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.telegram.org&#x2F;bot&lt;token&gt;&#x2F;&lt;method&gt;</span><br></pre></td></tr></table></figure><p>其中token为你的机器人token，method为telegram给定的方法，在获取群组chat_id那一步就使用了telegram的其中一个方法(getUpdates),其他方法后面会介绍</p><h3 id="携带参数"><a href="#携带参数" class="headerlink" title="携带参数"></a>携带参数</h3><p>请求api时有些方法需要携带参数，telegram支持的传参方式/类型如下</p><ul><li>URL查询参数</li><li>application/x-www-form-urlencoded</li><li>application/json</li><li>multipart/form-data(上传文件使用这个content-type)</li></ul><h3 id="获取响应"><a href="#获取响应" class="headerlink" title="获取响应"></a>获取响应</h3><p>对于每次请求telegram都会有一个响应，响应的内容是一个json，格式如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ok&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中返回的result可以是telegram定义的对象或者是对象的列表</p><h2 id="telegram对象"><a href="#telegram对象" class="headerlink" title="telegram对象"></a>telegram对象</h2><p>telegram机器人的几乎所有操作都是一个一个对象的操作。</p><p>telegram定义了许多场景下的对象，<a href="https://core.telegram.org/bots/api#available-types">详见</a>，这里举例一些常见的</p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>该对象表示传入的更新，比如接收到用户发来的新消息，就会获得新的更新</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">update_id</td><td align="left">Integer</td><td align="left">更新的唯一标识符。 更新标识符从某个正数开始，并依次增加。 如果您使用的是Webhooks，则此ID变得尤为方便，因为它使您可以忽略重复的更新或在错误的情况下恢复正确的更新顺序。 如果至少有一个星期没有新更新，则将随机选择下一个更新的标识符，而不是顺序选择。</td></tr><tr><td align="left">message</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。任何形式的新传入消息-文本，照片，贴纸等。</td></tr><tr><td align="left">edited_message</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。机器人已知并已编辑的消息的新版本</td></tr><tr><td align="left">channel_post</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。任何形式的新传入频道帖子-文字，照片，贴纸等。</td></tr><tr><td align="left">edited_channel_post</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。机器人已知并已编辑的频道发布的新版本</td></tr><tr><td align="left">inline_query</td><td align="left"><a href="https://core.telegram.org/bots/api#inlinequery">InlineQuery</a></td><td align="left">可选的。新的传入内联查询</td></tr><tr><td align="left">chosen_inline_result</td><td align="left"><a href="https://core.telegram.org/bots/api#choseninlineresult">ChosenInlineResult</a></td><td align="left">可选的。用户选择并发送给其聊天伙伴的内联查询的结果。请参阅收集反馈的文档，以获取有关如何为您的机器人启用这些更新的详细信息。</td></tr><tr><td align="left">callback_query</td><td align="left"><a href="https://core.telegram.org/bots/api#callbackquery">CallbackQuery</a></td><td align="left">可选的。新传入的回调查询</td></tr><tr><td align="left">shipping_query</td><td align="left"><a href="https://core.telegram.org/bots/api#shippingquery">ShippingQuery</a></td><td align="left">可选的。新的收货查询。仅适用于价格灵活的发票</td></tr><tr><td align="left">pre_checkout_query</td><td align="left"><a href="https://core.telegram.org/bots/api#precheckoutquery">PreCheckoutQuery</a></td><td align="left">可选的。新的传入预结帐查询。包含有关结帐的完整信息</td></tr><tr><td align="left">poll</td><td align="left"><a href="https://core.telegram.org/bots/api#poll">Poll</a></td><td align="left">可选的。新的投票状态。机器人仅接收有关僵尸程序发送的有关已停止的投票和投票的更新</td></tr><tr><td align="left">poll_answer</td><td align="left"><a href="https://core.telegram.org/bots/api#poll_answer">PollAnswer</a></td><td align="left">可选的。用户在非匿名调查中更改了答案。僵尸程序仅在由僵尸程序本身发送的民意调查中才能获得新的选票。</td></tr></tbody></table><p>任何给定的更新中最多只能存在一个可选参数。</p><h3 id="User"><a href="#User" class="headerlink" title="User"></a>User</h3><p>该对象表示telegram的一个用户或者机器人</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">Integer</td><td align="left">该用户或机器人的唯一标识</td></tr><tr><td align="left">is_bot</td><td align="left">Boolean</td><td align="left">标识该用户是否是机器人，True如果是机器人</td></tr><tr><td align="left">first_name</td><td align="left">String</td><td align="left">用户或者机器人的first_name</td></tr><tr><td align="left">last_name</td><td align="left">String</td><td align="left">可选。用户或者机器人的last_name</td></tr><tr><td align="left">username</td><td align="left">String</td><td align="left">可选。用户或者机器人的username</td></tr><tr><td align="left">language_code</td><td align="left">String</td><td align="left">可选。用户语言的IETF语言标签</td></tr><tr><td align="left">can_join_groups</td><td align="left">Boolean</td><td align="left">可选。返回True如果该机器人可以被邀请加入群组，只在<code>getMe</code>方法返回</td></tr><tr><td align="left">can_read_all_group_message</td><td align="left">Boolean</td><td align="left">可选。返回True如果该机器人禁用了隐私模式，只在<code>getMe</code>方法返回</td></tr><tr><td align="left">supports_inline_queries</td><td align="left">Boolean</td><td align="left">可选。返回True，如果这个自持内联查询，只在<code>getMe</code>方法返回</td></tr></tbody></table><h3 id="Chat"><a href="#Chat" class="headerlink" title="Chat"></a>Chat</h3><p>该对象表示一个聊天信息</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">Integer</td><td align="left">该聊天的唯一标识符。 这个数字可能会大于32位但是一定小于52位所以编程时因指定<code>int64</code>类型</td></tr><tr><td align="left">type</td><td align="left">String</td><td align="left">聊天的类型，可以是 “private”, “group”, “supergroup” 或者 “channel”</td></tr><tr><td align="left">title</td><td align="left">String</td><td align="left">可选。 标题, 针对 supergroups, channels 和 group 类型的聊天</td></tr><tr><td align="left">username</td><td align="left">String</td><td align="left">可选。 Username, 针对 私有的聊天，如果可以的话也针对 supergroups 和 channels</td></tr><tr><td align="left">first_name</td><td align="left">String</td><td align="left">可选。 私人聊天中对方的first_name</td></tr><tr><td align="left">last_name</td><td align="left">String</td><td align="left">可选。私人聊天中对方的last_name</td></tr><tr><td align="left">photo</td><td align="left"><a href="https://core.telegram.org/bots/api#chatphoto">ChatPhoto</a></td><td align="left">可选。 聊天照片，只在<code>getChat</code>方法返回</td></tr><tr><td align="left">description</td><td align="left">String</td><td align="left">可选。 描述, 针对 groups, supergroups 和 channel 的聊天。只在<code>getChat</code>方法返回</td></tr><tr><td align="left">invite_link</td><td align="left">String</td><td align="left">可选。聊天的邀请链接, 针对 groups, supergroups 和 channel 的聊天。聊天中的每个管理员都会生成自己的邀请链接，因此机器人必须首先使用<code>exportChatInviteLink</code>生成链接。仅在<code>getChat</code>中返回。</td></tr><tr><td align="left">pinned_message</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选。固定信息，针对 groups, supergroups 和 channels。只在<code>getChat</code>方法中返回</td></tr><tr><td align="left">permissions</td><td align="left"><a href="https://core.telegram.org/bots/api#chatpermissions">ChatPermissions</a></td><td align="left">可选。默认的聊天成员权限, 针对 groups 和 supergroups。只在<code>getChat</code>方法中返回</td></tr><tr><td align="left">slow_mode_delay</td><td align="left">Integer</td><td align="left">可选。针对 supergroups, 每个非特权用户发送的连续消息之间允许的最小延迟。仅在<code>getChat</code>中返回。</td></tr><tr><td align="left">sticker_set_name</td><td align="left">String</td><td align="left">可选。针对 supergroups, 组贴纸集的名称。仅在getChat中返回。</td></tr><tr><td align="left">can_set_sticker_set</td><td align="left">Boolean</td><td align="left">可选。 返回True如果机器人可以改变group的贴纸集，只在<code>getChat</code>方法中返回。</td></tr></tbody></table><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>该对象代表一个消息</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">message_id</td><td align="left">Integer</td><td align="left">此聊天中的唯一消息标识符</td></tr><tr><td align="left">from</td><td align="left"><a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。发件人，对于发送到channels的消息为空</td></tr><tr><td align="left">date</td><td align="left">Integer</td><td align="left">发送时间（Unix时间）</td></tr><tr><td align="left">chat</td><td align="left"><a href="https://core.telegram.org/bots/api#chat">Chat</a></td><td align="left">消息所属的会话</td></tr><tr><td align="left">forward_from</td><td align="left"><a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。对于转发的消息，原始消息的发件人</td></tr><tr><td align="left">forward_from_chat</td><td align="left"><a href="https://core.telegram.org/bots/api#chat">Chat</a></td><td align="left">可选的。对于从频道转发的消息，有关原始频道的信息</td></tr><tr><td align="left">forward_from_message_id</td><td align="left">Integer</td><td align="left">可选的。对于从频道转发的消息，是频道中原始消息的标识符</td></tr><tr><td align="left">forward_signature</td><td align="left">String</td><td align="left">可选的。对于从频道转发的消息，作者的签名（如果有）</td></tr><tr><td align="left">forward_sender_name</td><td align="left">String</td><td align="left">可选的。从用户转发的信息的发件人名称，这些用户不允许在转发的信息中添加指向其帐户的链接</td></tr><tr><td align="left">forward_date</td><td align="left">Integer</td><td align="left">可选的。对于转发的消息，原始消息的发送日期（Unix时间）</td></tr><tr><td align="left">reply_to_message</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。对于答复，原始消息。请注意，即使此字段本身是答复，该字段中的Message对象也不会包含其他的reply_to_message字段。</td></tr><tr><td align="left">via_bot</td><td align="left"><a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。发送消息的机器人</td></tr><tr><td align="left">edit_date</td><td align="left">Integer</td><td align="left">可选的。消息最后一次编辑的日期（Unix时间）</td></tr><tr><td align="left">media_group_id</td><td align="left">String</td><td align="left">可选的。该消息所属的媒体消息组的唯一标识符</td></tr><tr><td align="left">author_signature</td><td align="left">String</td><td align="left">可选的。在频道中信息的作者签名</td></tr><tr><td align="left">text</td><td align="left">String</td><td align="left">可选的。对于文本消息，消息的实际UTF-8文本，0-4096个字符</td></tr><tr><td align="left">entities</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#messageentity">MessageEntity</a></td><td align="left">可选的。对于文本消息，出现在文本中的特殊实体，例如用户名，URL，机器人命令等。</td></tr><tr><td align="left">animation</td><td align="left"><a href="https://core.telegram.org/bots/api#animation">Animation</a></td><td align="left">可选的。消息是动画，有关动画的信息。为了向后兼容，设置此字段时，还将设置文档字段</td></tr><tr><td align="left">audio</td><td align="left"><a href="https://core.telegram.org/bots/api#audio">Audio</a></td><td align="left">可选的。消息是音频文件，有关该文件的信息</td></tr><tr><td align="left">document</td><td align="left"><a href="https://core.telegram.org/bots/api#document">Document</a></td><td align="left">可选的。消息是常规文件，有关文件的信息</td></tr><tr><td align="left">photo</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#photosize">PhotoSize</a></td><td align="left">可选的。消息是照片，照片的可用尺寸</td></tr><tr><td align="left">sticker</td><td align="left"><a href="https://core.telegram.org/bots/api#sticker">Sticker</a></td><td align="left">可选的。消息是贴纸，有关贴纸的信息</td></tr><tr><td align="left">video</td><td align="left"><a href="https://core.telegram.org/bots/api#video">Video</a></td><td align="left">可选的。消息是视频，有关视频的信息</td></tr><tr><td align="left">video_note</td><td align="left"><a href="https://core.telegram.org/bots/api#videonote">VideoNote</a></td><td align="left">可选的。消息是视频注释，有关视频消息的信息</td></tr><tr><td align="left">voice</td><td align="left"><a href="https://core.telegram.org/bots/api#voice">Voice</a></td><td align="left">可选的。消息是语音消息，有关文件的信息</td></tr><tr><td align="left">caption</td><td align="left">String</td><td align="left">可选的。动画，音频，文档，照片，视频或语音的标题，0-1024个字符</td></tr><tr><td align="left">caption_entities</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#messageentity">MessageEntity</a></td><td align="left">可选的。对于带有标题的消息，出现在标题中的特殊实体，例如用户名，URL，漫机器人命令等</td></tr><tr><td align="left">contact</td><td align="left"><a href="https://core.telegram.org/bots/api#contact">Contact</a></td><td align="left">可选的。消息是共享的联系人，有关该联系人的信息</td></tr><tr><td align="left">dice</td><td align="left"><a href="https://core.telegram.org/bots/api#dice">Dice</a></td><td align="left">可选的。消息是一个骰子，具有从1到6的随机值</td></tr><tr><td align="left">game</td><td align="left"><a href="https://core.telegram.org/bots/api#game">Game</a></td><td align="left">可选的。消息是一个游戏，有关游戏的信息。</td></tr><tr><td align="left">poll</td><td align="left"><a href="https://core.telegram.org/bots/api#poll">Poll</a></td><td align="left">可选的。消息是原生投票，有关投票的信息</td></tr><tr><td align="left">venue</td><td align="left"><a href="https://core.telegram.org/bots/api#venue">Venue</a></td><td align="left">可选的。消息是一个场地，有关该场地的信息。为了向后兼容，设置此字段时，还将设置位置字段</td></tr><tr><td align="left">location</td><td align="left"><a href="https://core.telegram.org/bots/api#location">Location</a></td><td align="left">可选的。消息是共享位置，有关位置的信息</td></tr><tr><td align="left">new_chat_members</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。添加到组或超组中的新成员以及有关它们的信息（机器人本身可能是这些成员之一）</td></tr><tr><td align="left">left_chat_member</td><td align="left"><a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。成员已从群组中删除，有关他们的信息（该成员可能是机器人本身）</td></tr><tr><td align="left">new_chat_title</td><td align="left">String</td><td align="left">可选的。聊天标题已更改为此值</td></tr><tr><td align="left">new_chat_photo</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#photosize">PhotoSize</a></td><td align="left">可选的。聊天照片已更改为此值</td></tr><tr><td align="left">delete_chat_photo</td><td align="left">True</td><td align="left">可选的。服务消息：聊天照片已删除</td></tr><tr><td align="left">group_chat_created</td><td align="left">True</td><td align="left">可选的。服务信息：组已创建</td></tr><tr><td align="left">supergroup_chat_created</td><td align="left">True</td><td align="left">可选的。 服务消息：超组已创建。 在通过更新发送的消息中无法接收到该字段，因为bot在创建时不能成为超组的成员。 仅当有人回复直接创建的超组中的第一条消息时，才可以在reply_to_message中找到该消息。</td></tr><tr><td align="left">channel_chat_created</td><td align="left">True</td><td align="left">可选的。 服务信息：频道已创建。 在通过更新发送的消息中无法接收到该字段，因为bot在创建时不能成为频道的成员。 如果有人回复频道中的第一条消息，则只能在reply_to_message中找到它。</td></tr><tr><td align="left">migrate_to_chat_id</td><td align="left">Integer</td><td align="left">可选的。 该组已迁移到具有指定标识符的超组。 此数字可能大于32位，并且某些编程语言在解释它时可能会有困难/无声的缺陷。 但是它小于52位，因此带符号的64位整数或双精度浮点类型对于存储此标识符是安全的。</td></tr><tr><td align="left">migrate_from_chat_id</td><td align="left">Integer</td><td align="left">可选的。 超级组已从具有指定标识的组中迁移。 此数字可能大于32位，并且某些编程语言在解释它时可能会有困难/无声的缺陷。 但是它小于52位，因此带符号的64位整数或双精度浮点类型对于存储此标识符是安全的。</td></tr><tr><td align="left">pinned_message</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。 指定的消息已固定。 请注意，即使该字段本身是答复，该字段中的Message对象也不会包含其他的reply_to_message字段。</td></tr><tr><td align="left">invoice</td><td align="left"><a href="https://core.telegram.org/bots/api#invoice">Invoice</a></td><td align="left">可选的。 消息是付款的发票，有关发票的信息。</td></tr><tr><td align="left">successful_payment</td><td align="left"><a href="https://core.telegram.org/bots/api#successfulpayment">SuccessfulPayment</a></td><td align="left">可选的。 消息是有关成功付款的服务消息，有关付款的信息。</td></tr><tr><td align="left">connected_website</td><td align="left">String</td><td align="left">可选的。 用户登录的网站的域名。</td></tr><tr><td align="left">passport_data</td><td align="left"><a href="https://core.telegram.org/bots/api#passportdata">PassportData</a></td><td align="left">可选的。 电报护照数据</td></tr><tr><td align="left">reply_markup</td><td align="left"><a href="https://core.telegram.org/bots/api#inlinekeyboardmarkup">InlineKeyboardMarkup</a></td><td align="left">可选的。 消息附带的嵌入式键盘。 login_url按钮表示为普通url按钮。</td></tr></tbody></table><h3 id="MessageEntity"><a href="#MessageEntity" class="headerlink" title="MessageEntity"></a>MessageEntity</h3><p>该对象表示文本消息中的一个特殊实体。例如，标签，用户名，URL等。</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">type</td><td align="left">String</td><td align="left">实体的类型。 可以是“mention”（@username），“hashtag”（#hashtag），“cashtag”（$ USD），“ bot_command”（/ start @ jobs_bot），“ URL”（<a href="https://telegram.org),“/">https://telegram.org），“</a> email”（<a href="mailto:&#x64;&#x6f;&#x2d;&#x6e;&#111;&#116;&#x2d;&#x72;&#x65;&#112;&#108;&#121;&#x40;&#116;&#x65;&#x6c;&#101;&#103;&#x72;&#97;&#x6d;&#x2e;&#111;&#x72;&#x67;">&#x64;&#x6f;&#x2d;&#x6e;&#111;&#116;&#x2d;&#x72;&#x65;&#112;&#108;&#121;&#x40;&#116;&#x65;&#x6c;&#101;&#103;&#x72;&#97;&#x6d;&#x2e;&#111;&#x72;&#x67;</a>），“phone_number”（+ 1-212-555-0123），“bold”（粗体），“italic”（斜体），“underline”（带下划线的文本） ），“strikethrough”（删除线文本），“code”（等宽字符串），“ pre”（等宽块），“ text_link”（对于可点击的文本URL），“ text_mention”（对于没有用户名的用户）</td></tr><tr><td align="left">offset</td><td align="left">Integer</td><td align="left">以UTF-16代码单位向实体开始的偏移量</td></tr><tr><td align="left">length</td><td align="left">Integer</td><td align="left">实体的长度（以UTF-16代码单元为单位）</td></tr><tr><td align="left">url</td><td align="left">String</td><td align="left">可选的。仅对于“ text_link”，用户点击文本后将打开的URL</td></tr><tr><td align="left">user</td><td align="left"><a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。仅针对“ text_mention”，提到的用户</td></tr><tr><td align="left">language</td><td align="left">String</td><td align="left">可选的。仅对于“ pre”，实体文本的编程语言</td></tr></tbody></table><h3 id="BotCommand"><a href="#BotCommand" class="headerlink" title="BotCommand"></a>BotCommand</h3><p>这个对象代表值一条机器人指令</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">command</td><td align="left">String</td><td align="left">命令文本，1-32个字符。只能包含小写英文字母，数字和下划线。</td></tr><tr><td align="left">description</td><td align="left">String</td><td align="left">命令说明，3-256个字符。</td></tr></tbody></table><h3 id="WebhookInfo"><a href="#WebhookInfo" class="headerlink" title="WebhookInfo"></a>WebhookInfo</h3><p>这个对象表示当前webhook的状态</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">String</td><td align="left">Webhook URL，如果未设置webhook，则可能为空</td></tr><tr><td align="left">has_custom_certificate</td><td align="left">Boolean</td><td align="left">如果为webhook证书检查提供了自定义证书则为真</td></tr><tr><td align="left">pending_update_count</td><td align="left">Integer</td><td align="left">等待交付的更新数量</td></tr><tr><td align="left">last_error_date</td><td align="left">Integer</td><td align="left">可选的。尝试通过Webhook传递更新时发生的最新错误的Unix时间</td></tr><tr><td align="left">last_error_message</td><td align="left">String</td><td align="left">可选的。尝试通过Webhook传递更新时发生的最新错误的人类可读格式的错误消息</td></tr><tr><td align="left">max_connections</td><td align="left">Integer</td><td align="left">可选的。与Webhook进行更新交付的同时HTTPS连接的最大允许数量</td></tr><tr><td align="left">allowed_updates</td><td align="left">Array of String</td><td align="left">可选的。机器人已订阅的更新类型的列表。默认为所有更新类型</td></tr></tbody></table><h3 id="ReplyKeyboardMarkup"><a href="#ReplyKeyboardMarkup" class="headerlink" title="ReplyKeyboardMarkup"></a>ReplyKeyboardMarkup</h3><p>该对象表示带有回复选项的自定义键盘</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">keyboard</td><td align="left">Array of Array of <a href="https://core.telegram.org/bots/api/#keyboardbutton">KeyboardButton</a></td><td align="left">按钮行数组，每个行由一个KeyboardButton对象数组表示</td></tr><tr><td align="left">resize_keyboard</td><td align="left">Boolean</td><td align="left">可选的。请求客户垂直调整键盘大小以达到最佳适合度（例如，如果只有两行按钮，则使键盘变小）。默认为false，在这种情况下，自定义键盘的高度始终与应用程序的标准键盘相同。</td></tr><tr><td align="left">one_time_keyboard</td><td align="left">Boolean</td><td align="left">可选的。要求客户在使用键盘后立即隐藏它。键盘仍然可用，但是客户端将在聊天中自动显示常用的字母键盘-用户可以在输入字段中按特殊按钮以再次查看自定义键盘。默认为false。</td></tr><tr><td align="left">selective</td><td align="left">Boolean</td><td align="left">可选的。如果只想向特定用户显示键盘，请使用此参数。目标：1）在Message对象的文本中@提及的用户； 2）如果机器人的消息是回复（具有reply_to_message_id），则为原始消息的发送者。 <br />示例：用户请求更改机器人的语言，机器人用键盘答复选择新语言的请求。群组中的其他用户看不到键盘。</td></tr></tbody></table><h3 id="KeyboardButton"><a href="#KeyboardButton" class="headerlink" title="KeyboardButton"></a>KeyboardButton</h3><p>该对象表示回复键盘的一个按钮。对于简单的文本按钮，可以使用<code>String</code>代替此对象来指定按钮的文本。可选字段<code>request_contact</code>，<code>request_location</code>和<code>request_poll</code>是互斥的。</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">String</td><td align="left">按钮的文字。如果未使用任何可选字段，则在按下按钮时它将作为消息发送</td></tr><tr><td align="left">request_contact</td><td align="left">Boolean</td><td align="left">可选的。如果为True，则按下该按钮时，用户的电话号码将作为联系人发送。仅在私人聊天中可用</td></tr><tr><td align="left">request_location</td><td align="left">Boolean</td><td align="left">可选的。如果为True，则在按下按钮时将发送用户的当前位置。仅在私人聊天中可用</td></tr><tr><td align="left">request_poll</td><td align="left"><a href="https://core.telegram.org/bots/api/#keyboardbuttonpolltype">KeyboardButtonPollType</a></td><td align="left">可选的。如果指定，则将要求用户创建一个民意调查，并在按下按钮时将其发送给机器人。仅在私人聊天中可用</td></tr></tbody></table><p><strong>注意</strong>：<em>request_contact</em>和<em>request_location</em>选项仅适用于2016年4月9日之后发布的电报版本。较旧的客户端将显示不受支持的消息。 </p><p><strong>注意</strong>：<em>request_poll</em>选项仅在2020年1月23日之后发布的电报版本中有效。旧客户端将显示不支持的消息。</p><h3 id="KeyboardButtonPollType"><a href="#KeyboardButtonPollType" class="headerlink" title="KeyboardButtonPollType"></a>KeyboardButtonPollType</h3><p>该对象表示民意调查的类型，可以在按下相应按钮时创建并发送该民意调查</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">type</td><td align="left">String</td><td align="left">可选的。如果通过了测验，将仅允许用户以测验模式创建民意测验。如果通过常规，则仅允许常规民意调查。否则，将允许用户创建任何类型的民意测验。</td></tr></tbody></table><h3 id="ReplyKeyboardRemove"><a href="#ReplyKeyboardRemove" class="headerlink" title="ReplyKeyboardRemove"></a>ReplyKeyboardRemove</h3><p>收到带有此对象的消息后，Telegram客户端将删除当前的自定义键盘并显示默认的字母键盘。默认情况下，将显示自定义键盘，直到机器人发送新键盘为止。一次性键盘的例外情况是用户按下按钮后立即隐藏的一次性键盘</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">remove_keyboard</td><td align="left">True</td><td align="left">请求客户端删除自定义键盘（用户将无法召唤此键盘；如果要隐藏键盘，但保持其可访问性，请在ReplyKeyboardMarkup中使用one_time_keyboard）</td></tr><tr><td align="left">selective</td><td align="left">Boolean</td><td align="left">可选的。如果仅要为特定用户卸下键盘，请使用此参数。目标：1）在Message对象的文本中@提及的用户； 2）如果漫游器的消息是回复（具有reply_to_message_id），则为原始消息的发送者。 示例：用户在投票中投票，机器人返回确认消息以回应投票，并删除该用户的键盘，同时仍向尚未投票的用户显示带有投票选项的键盘。</td></tr></tbody></table><h3 id="InlineKeyboardMarkup"><a href="#InlineKeyboardMarkup" class="headerlink" title="InlineKeyboardMarkup"></a>InlineKeyboardMarkup</h3><p>该对象表示一个嵌入式键盘，出现在其所属消息的旁边。</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">inline_keyboard</td><td align="left">Array of Array of <a href="https://core.telegram.org/bots/api/#inlinekeyboardbutton">InlineKeyboardButton</a></td><td align="left">按钮行数组，每个行由一个InlineKeyboardButton对象数组表示</td></tr></tbody></table><p><strong>注意</strong>：这仅适用于2016年4月9日之后发布的电报版本。较旧的客户端将显示不受支持的消息。</p><h3 id="InlineKeyboardButton"><a href="#InlineKeyboardButton" class="headerlink" title="InlineKeyboardButton"></a>InlineKeyboardButton</h3><p>此对象表示嵌入式键盘的一个按钮。您必须完全使用可选字段之一。</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">String</td><td align="left">在按钮上标记文本</td></tr><tr><td align="left">url</td><td align="left">String</td><td align="left">可选的。按下按钮时将打开HTTP或tg:// URL</td></tr><tr><td align="left">login_url</td><td align="left"><a href="https://core.telegram.org/bots/api/#loginurl">LoginUrl</a></td><td align="left">可选的。用于自动授权用户的HTTP URL。可以替代电报登录小部件。</td></tr><tr><td align="left">callback_data</td><td align="left">String</td><td align="left">可选的。按下按钮时要在回调查询中发送到bot的数据，1-64个字节</td></tr><tr><td align="left">switch_inline_query</td><td align="left">String</td><td align="left">可选的。如果已设置，则按下按钮将提示用户选择其聊天之一，打开该聊天并将bot的用户名和指定的内联查询插入输入字段。可以为空，在这种情况下，只会插入机器人的用户名。<br /><strong>注意</strong>：这为用户提供了一种简便的方法，使他们在当前与它进行私聊时以内联模式开始使用您的机器人。与switch_pm…操作结合使用时特别有用–在这种情况下，用户将自动返回到其切换到的聊天中，而跳过聊天选择屏幕。</td></tr><tr><td align="left">switch_inline_query_current_chat</td><td align="left">String</td><td align="left">可选的。如果已设置，则按下按钮会将bot的用户名和指定的嵌入式查询插入当前聊天的输入字段中。可以为空，在这种情况下，只会插入机器人的用户名。</td></tr><tr><td align="left">callback_game</td><td align="left"><a href="https://core.telegram.org/bots/api/#callbackgame">CallbackGame</a></td><td align="left">可选的。用户按下按钮时将启动的游戏的描述。<br /><strong>注意</strong>：此类型的按钮必须始终是第一行中的第一个按钮。</td></tr><tr><td align="left">pay</td><td align="left">Boolean</td><td align="left">可选的。指定True，发送付款按钮。 <br /><strong>注意</strong>：此类型的按钮必须始终是第一行中的第一个按钮。</td></tr></tbody></table><h3 id="ForceReply"><a href="#ForceReply" class="headerlink" title="ForceReply"></a>ForceReply</h3><p>收到带有该对象的消息后，Telegram客户端将向用户显示一个答复界面（就像用户选择了机器人的消息并点按“答复”一样）。如果您要创建用户友好的逐步界面而不必牺牲隐私模式，这将非常有用。</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">force_reply</td><td align="left">True</td><td align="left">向用户显示回复界面，就像他们手动选择了机器人的消息并点按“回复”一样</td></tr><tr><td align="left">selective</td><td align="left">Boolean</td><td align="left">可选的。如果只想强制特定用户答复，请使用此参数。目标：1）在Message对象的文本中@提及的用户； 2）如果漫游器的消息是回复（具有reply_to_message_id），则为原始消息的发送者。</td></tr></tbody></table><h2 id="telegram方法"><a href="#telegram方法" class="headerlink" title="telegram方法"></a>telegram方法</h2><p>telegram方法就是拼接在api后面的那串字符串，不区分大小写。<a href="https://core.telegram.org/bots/api#available-methods">详见</a>，这里只列举一些常用的，下面我所指的返回是指返回json中的result部分，其他章节提到的所有方法均可以在这一章节查阅</p><h3 id="getUpdates"><a href="#getUpdates" class="headerlink" title="getUpdates"></a>getUpdates</h3><ul><li><p>描述</p><p>获取更新，还有另外一种获取更新的方法(webhook)，两种方式不能共存</p></li><li><p>参数</p><p>无参数</p></li><li><p>返回</p><p><code>update</code>对象列表</p></li></ul><h3 id="setWebhook"><a href="#setWebhook" class="headerlink" title="setWebhook"></a>setWebhook</h3><ul><li><p>描述</p><p>使用此方法可以指定URL并通过传出的Webhook接收传入的更新。只要机器人有更新，telegram就会向指定的URL发送HTTPS POST请求，请求数据为json序列化后的<code>update</code>对象</p></li><li><p>参数</p><table><thead><tr><th align="left">Parameter</th><th align="left">Type</th><th align="left">Required</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">String</td><td align="left">Yes</td><td align="left">发送更新的https url。使用空字符串删除webhook集成</td></tr><tr><td align="left">certificate</td><td align="left"><a href="https://core.telegram.org/bots/api#inputfile">InputFile</a></td><td align="left">Optional</td><td align="left">上传您的公共密钥证书，以便可以检查正在使用的根证书。有关详细信息，请参见我们的<a href="https://core.telegram.org/bots/self-signed">自签名指南</a>。</td></tr><tr><td align="left">max_connections</td><td align="left">Integer</td><td align="left">Optional</td><td align="left">与Webhook进行更新交付的同时HTTPS连接的最大允许数量为1-100。默认值为40。使用较低的值可以限制bot服务器的负载，使用较高的值可以增加bot的吞吐量。</td></tr><tr><td align="left">allowed_updates</td><td align="left">Array of String</td><td align="left">Optional</td><td align="left">您希望机器人接收的更新类型的JSON序列化列表。 例如，指定[“ message”，“ edited_channel_post”，“ callback_query”]仅接收这些类型的更新。 请参阅更新以获取可用更新类型的完整列表。 指定一个空列表以接收所有更新，无论类型如何（默认）。 如果未指定，将使用以前的设置。<br />请注意，此参数不会影响调用setWebhook之前创建的更新，因此可能会在短时间内收到不需要的更新。</td></tr></tbody></table></li></ul><ul><li><p>返回</p><p>成功返回<code>True</code></p></li></ul><h3 id="deleteWebhook"><a href="#deleteWebhook" class="headerlink" title="deleteWebhook"></a>deleteWebhook</h3><ul><li><p>描述</p><p>删除设置的webhook</p></li><li><p>参数</p><p>无参数</p></li><li><p>返回</p><p>成功返回True</p></li></ul><h3 id="getWebhookInfo"><a href="#getWebhookInfo" class="headerlink" title="getWebhookInfo"></a>getWebhookInfo</h3><ul><li><p>描述</p><p>获取当前webhook的状态</p></li><li><p>参数</p><p>无参数</p></li><li><p>返回</p><p><code>WebhookInfo</code>对象</p><p>（如果没有设置webhook，则返回的对象中url为空）</p></li></ul><h3 id="getMe"><a href="#getMe" class="headerlink" title="getMe"></a>getMe</h3><ul><li><p>描述</p><p>获取机器人自身信息</p></li><li><p>参数</p><p>无参数</p></li><li><p>返回</p><p><code>user</code>对象</p></li></ul><h3 id="getChat"><a href="#getChat" class="headerlink" title="getChat"></a>getChat</h3><ul><li><p>描述</p><p>使用此方法可获取有关聊天的最新信息（一对一对话的用户的当前名称，用户的当前用户名，组或频道等）</p></li><li><p>参数</p><table><thead><tr><th align="left">Parameter</th><th align="left">Type</th><th align="left">Required</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">chat_id</td><td align="left">Integer or String</td><td align="left">Yes</td><td align="left">目标聊天或目标超级组或频道的用户名的唯一标识符（格式为@channelusername）</td></tr></tbody></table></li><li><p>返回</p><p><code>chat</code>对象</p></li></ul><h3 id="sendMessage"><a href="#sendMessage" class="headerlink" title="sendMessage"></a>sendMessage</h3><ul><li><p>描述</p><p>发送消息</p></li><li><p>参数</p><table><thead><tr><th align="left">Parameter</th><th align="left">Type</th><th align="left">Required</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">chat_id</td><td align="left">Integer or String</td><td align="left">Yes</td><td align="left">目标聊天（chat_id）或目标频道的用户名的唯一标识符（格式为@channelusername）</td></tr><tr><td align="left">text</td><td align="left">String</td><td align="left">Yes</td><td align="left">待发送消息的文本，实体解析后为1-4096个字符</td></tr><tr><td align="left">parse_mode</td><td align="left">String</td><td align="left">Optional</td><td align="left">消息文本中的实体解析模式。有关更多详细信息，请参见格式化选项。</td></tr><tr><td align="left">disable_web_page_preview</td><td align="left">Boolean</td><td align="left">Optional</td><td align="left">禁用此消息中链接的链接预览</td></tr><tr><td align="left">disable_notification</td><td align="left">Boolean</td><td align="left">Optional</td><td align="left">静默发送消息。用户将收到没有声音的通知。</td></tr><tr><td align="left">reply_to_message_id</td><td align="left">Integer</td><td align="left">Optional</td><td align="left">如果消息是答复，则为原始消息的ID</td></tr><tr><td align="left">reply_markup</td><td align="left"><a href="https://core.telegram.org/bots/api#inlinekeyboardmarkup">InlineKeyboardMarkup</a> or <a href="https://core.telegram.org/bots/api#replykeyboardmarkup">ReplyKeyboardMarkup</a> or <a href="https://core.telegram.org/bots/api#replykeyboardremove">ReplyKeyboardRemove</a> or <a href="https://core.telegram.org/bots/api#forcereply">ForceReply</a></td><td align="left">Optional</td><td align="left">其他界面选项。内联键盘，自定义回复键盘，删除回复键盘或强制用户回复的说明的JSON序列化对象。</td></tr></tbody></table></li><li><p>返回</p><p>刚刚发送的<code>message</code>对象</p></li></ul><h3 id="setMyCommands"><a href="#setMyCommands" class="headerlink" title="setMyCommands"></a>setMyCommands</h3><ul><li><p>描述</p><p>使用此方法可以更改机器人的命令列表</p></li><li><p>参数</p><table><thead><tr><th align="left">Parameter</th><th align="left">Type</th><th align="left">Required</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">commands</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#botcommand">BotCommand</a></td><td align="left">Yes</td><td align="left">将bot命令的JSON序列化列表设置为bot命令列表。最多可以指定100个命令。</td></tr></tbody></table></li><li><p>返回</p><p>成功返回<code>True</code></p></li></ul><h3 id="getMyCommands"><a href="#getMyCommands" class="headerlink" title="getMyCommands"></a>getMyCommands</h3><ul><li><p>描述</p><p>使用此方法获取机器人命令的当前列表</p></li><li><p>参数</p><p>无参数</p></li><li><p>返回</p><p><code>BotCommand</code>对象列表</p></li><li></li></ul><h2 id="格式化选项"><a href="#格式化选项" class="headerlink" title="格式化选项"></a>格式化选项</h2><p>格式化选项就是让我们的机器人以某种格式发送消息（比如markdown，或者html）</p><p>  Bot API支持消息的基本格式。您可以在机器人的消息中使用粗体，斜体，下划线和删除线文本，以及内联链接和预格式化的代码。电报客户端将相应地呈现它们。您可以使用markdown样式或HTML样式格式。</p><p>请注意，Telegram客户端将在打开内联链接（“打开此链接？”以及完整的URL）之前向用户显示警报。</p><p>如果满足以下限制，则可以嵌套消息实体：</p><ul><li>如果两个实体具有公共字符，则其中一个完全包含在另一个内部。</li><li>粗体，斜体，下划线和删除线实体可以包含并且要包含在任何其他实体中，但pre和code除外。</li><li>所有其他实体不能互相包含。</li></ul><p>链接<code>tg://user?id=&lt;user_id&gt;</code>可以用于通过用户ID提及用户，而无需使用用户名。请注意：</p><ul><li>这些链接仅在内联链接中使用时才有效。例如，当用于嵌入式键盘按钮或消息文本中时，它们将不起作用。</li><li>仅当用户过去联系过该机器人，通过内联按钮向该机器人发送了回调查询或成为提及该用户的组的成员时，才能保证这些提及有效。</li></ul><h3 id="MarkdownV2-style"><a href="#MarkdownV2-style" class="headerlink" title="MarkdownV2 style"></a>MarkdownV2 style</h3><p>要使用此模式，请在parse_mode字段中传递MarkdownV2。在您的消息中使用以下语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*bold \*</span>text<span class="emphasis">*</span></span><br><span class="line"><span class="emphasis">_italic \*</span>text<span class="emphasis">_</span></span><br><span class="line"><span class="emphasis"><span class="strong">__underline__</span></span></span><br><span class="line"><span class="emphasis">~strikethrough~</span></span><br><span class="line"><span class="emphasis">*bold _</span>italic bold ~italic bold strikethrough~ <span class="strong">__underline italic bold__</span><span class="emphasis">_ bold*</span></span><br><span class="line"><span class="emphasis">[<span class="string">inline URL</span>](<span class="link">http://www.example.com/</span>)</span></span><br><span class="line"><span class="emphasis">[<span class="string">inline mention of a user</span>](<span class="link">tg://user?id=123456789</span>)</span></span><br><span class="line"><span class="emphasis">`inline fixed-width code`</span></span><br><span class="line"><span class="emphasis">​```</span></span><br><span class="line"><span class="emphasis">pre-formatted fixed-width code block</span></span><br><span class="line"><span class="emphasis">​```</span></span><br><span class="line"><span class="emphasis">​```python</span></span><br><span class="line"><span class="emphasis">pre-formatted fixed-width code block written in the Python programming language</span></span><br><span class="line"><span class="emphasis">​```</span></span><br></pre></td></tr></table></figure><p>请注意：</p><ul><li>任何代码在1到126之间（含1和126）的字符都可以在任何带有’&#39;字符的位置转义，在这种情况下，它将被视为普通字符，而不是标记的一部分。</li><li>在pre和code实体内部，所有’`’和’\‘字符必须以前面的’\‘字符转义。</li><li>内联链接定义的内部(…)部分，所有’)’和’\‘必须以前面的’\‘字符转义</li><li>在其他所有地方这些字符 ‘_’, ‘*’, ‘[‘, ‘]’, ‘(‘, ‘)’, ‘~’, ‘`’, ‘&gt;’, ‘#’, ‘+’, ‘-‘, ‘=’, ‘|’, ‘{‘, ‘}’, ‘.’, ‘!’ 必须用前置’\‘转义</li><li>如果<code>斜体</code>和<code>下划线</code>之间存在歧义，<code>__</code>始终从左到右被视为<code>下划线</code>实体的开始或结尾，所以使用<code>___italic underline_\r__</code>代替<code>___italic underline___</code></li></ul><h3 id="HTML-style"><a href="#HTML-style" class="headerlink" title="HTML style"></a>HTML style</h3><p>要使用此模式，请在parse_mode字段中传递HTML。当前支持以下标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>bold<span class="tag">&lt;/<span class="name">b</span>&gt;</span>, <span class="tag">&lt;<span class="name">strong</span>&gt;</span>bold<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>italic<span class="tag">&lt;/<span class="name">i</span>&gt;</span>, <span class="tag">&lt;<span class="name">em</span>&gt;</span>italic<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>underline<span class="tag">&lt;/<span class="name">u</span>&gt;</span>, <span class="tag">&lt;<span class="name">ins</span>&gt;</span>underline<span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">s</span>&gt;</span>strikethrough<span class="tag">&lt;/<span class="name">s</span>&gt;</span>, <span class="tag">&lt;<span class="name">strike</span>&gt;</span>strikethrough<span class="tag">&lt;/<span class="name">strike</span>&gt;</span>, <span class="tag">&lt;<span class="name">del</span>&gt;</span>strikethrough<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>bold <span class="tag">&lt;<span class="name">i</span>&gt;</span>italic bold <span class="tag">&lt;<span class="name">s</span>&gt;</span>italic bold strikethrough<span class="tag">&lt;/<span class="name">s</span>&gt;</span> <span class="tag">&lt;<span class="name">u</span>&gt;</span>underline italic bold<span class="tag">&lt;/<span class="name">u</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> bold<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.example.com/&quot;</span>&gt;</span>inline URL<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;tg://user?id=123456789&quot;</span>&gt;</span>inline mention of a user<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span>inline fixed-width code<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>pre-formatted fixed-width code block<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span> <span class="attr">class</span>=<span class="string">&quot;language-python&quot;</span>&gt;</span>pre-formatted fixed-width code block written in the Python programming language<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请注意：</p><ul><li>当前仅支持上述标签。</li><li>所有不属于标记或HTML实体的<code>&lt;</code>，<code>&gt;</code>和<code>&amp;</code>符号必须替换为相应的HTML实体(<code>&lt;</code> 用 <code>&amp;lt;</code>， <code>&gt;</code> 用 <code>&amp;gt;</code>， <code>&amp;</code> 用 <code>&amp;amp;</code>)。</li><li>支持所有数字HTML实体。</li><li>该API当前仅支持以下命名的HTML实体： <code>&amp;lt;</code>, <code>&amp;gt;</code>, <code>&amp;amp;</code> and <code>&amp;quot;</code>。</li><li>使用嵌套的pre和code标签，为pre实体定义编程语言。</li><li>不能为独立code标签指定编程语言。</li></ul><h3 id="Markdown-style"><a href="#Markdown-style" class="headerlink" title="Markdown style"></a>Markdown style</h3><p>这是旧版模式，保留下来是为了向后兼容。要使用此模式，请在parse_mode字段中传递Markdown。在您的消息中使用以下语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*bold text*</span></span><br><span class="line"><span class="emphasis">_italic text_</span></span><br><span class="line">[<span class="string">inline URL</span>](<span class="link">http://www.example.com/</span>)</span><br><span class="line">[<span class="string">inline mention of a user</span>](<span class="link">tg://user?id=123456789</span>)</span><br><span class="line"><span class="code">`inline fixed-width code`</span></span><br><span class="line">​<span class="code">```</span></span><br><span class="line"><span class="code">pre-formatted fixed-width code block</span></span><br><span class="line"><span class="code">​```</span></span><br><span class="line">​<span class="code">```python</span></span><br><span class="line"><span class="code">pre-formatted fixed-width code block written in the Python programming language</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure><p>请注意：</p><ul><li>实体不得嵌套，而应使用解析模式<code>MarkdownV2</code>。</li><li>无法指定下划线和删除线实体，请改用解析模式<code>MarkdownV2</code>。</li><li>要在实体外部转义字符<code>_</code>，<code>*</code>，`，<code>[</code>，请在字符之前加上<code>\</code>。</li><li>不允许在实体内部转义，因此必须先关闭实体再重新打开：对于斜体使用<code>_snake_\__case_</code>，对于粗体<code>2*2=4</code>使用 <code>snake_case</code> 和 <code>*2*\**2=4*</code>。</li></ul><h2 id="telegram更新"><a href="#telegram更新" class="headerlink" title="telegram更新"></a>telegram更新</h2><p>telegram中更新指的是机器人是否有收到新的消息，具体有哪些消息可以查看<code>telegram对象</code>部分中的<code>Update</code>，获取更新的方式有两种1. 轮询，2.webhook</p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>这是一种主动询问的方式，这种方式比较简单但是效率欠佳，具体操作是，开发者每个一段时间请求一次<code>getUpdates</code>方法，从获取结果中判断update有无更新，有关<code>update</code>对象的描述可看<code>telegram对象</code>章节</p><h3 id="webhook"><a href="#webhook" class="headerlink" title="webhook"></a>webhook</h3><p>webhook可以理解为客户端给服务端的api,只要服务端一有更新就会主动将内容发送到客户端设置的一个api中，然后客户端收到消息后可做相应处理。</p><p><strong>给我们的机器人设置webhook</strong></p><p>通过<code>setWebhook</code>方法设置（前面有介绍），需要注意的是，telegram只支持<code>https</code>协议，所以我们的api服务器必须要有TLS证书，必须注意一但我们设置了webhook那么通过<code>getUpdates</code>方法将不起作用！</p><h2 id="telegram中的命令"><a href="#telegram中的命令" class="headerlink" title="telegram中的命令"></a>telegram中的命令</h2><p>通过命令来和机器人交互是电报机器人的一大特色，在telegram中命令由实体<code>BotCommand</code>表示（telegram对象那节已经介绍过）。</p><p>其实任何以<code>/</code>开头的连续英文消息都被视作命令(可以理解为这是一种具有格式的普通消息)，私聊或者在群里@机器人时发送<code>/</code>开头的信息可以查看实体类型为<code>bot_command</code>。要想让机器人收到某条命令后执行响应动作只需要判断发送的消息是否匹配我们约定的内容即刻，（从某种意义上讲无论发送的消息是否是命令格式我们都可以将其视为命令只要我们愿意），开发具有命令响应的过程总结如下：</p><ol><li>起一个死循环监听<code>update</code>的<code>message</code>消息，可以是轮询或者webhook方式</li><li>拿到<code>update.id</code>检查其是否更新，如有更新则取<code>message.Text</code>匹配已经定义好的<code>路由</code>（这是我定义的叫法，也就是我们约定的命令，事实上他的确和路由很像）</li><li>如果匹配成功，执行我们定义的方法，如果匹配失败则当做普通信息无视，或者返回对应信息</li></ol><p>从上面过程可以看出命令是否是<code>/</code>开头其实已经不那么重要了，那么为什么官方要定义<code>BotCommand</code>类呢，理由（优点）如下</p><ol><li>用以和普通消息区分</li><li>在聊天消息中命令会高亮显示</li><li>已经注册的命令在对话框中只需要输入<code>/</code>就会有提示列表</li></ol><h3 id="给机器人注册指令"><a href="#给机器人注册指令" class="headerlink" title="给机器人注册指令"></a>给机器人注册指令</h3><p><strong>手动注册</strong></p><ol><li><p>和<code>botFather</code>对话，输入<code>/mybot</code></p></li><li><p>选择要注册指令的机器人</p></li><li><p>选择<code>Edit Bot</code>选项</p></li><li><p>选择<code>Edit Commands</code></p></li><li><p>输入你想定义的命令，格式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 - 描述</span><br><span class="line">command2 - Description</span><br></pre></td></tr></table></figure><p>注意：注册时命令开头没有斜杠，使用命令时需要带上斜杠，中间用 <code>-</code> 分割；每一次的命令编辑都会覆盖之前的命令而不是追加，所以必须一次发送全部命令（在对话框中按<code>shift + enter</code>换行），另外命令不能使用驼峰命名法</p></li></ol><p><strong>通过<code>setMyCommands</code>方法注册</strong></p><ul><li>详见（telegram方法 setMyCommands）</li></ul><h3 id="查看已注册的指令"><a href="#查看已注册的指令" class="headerlink" title="查看已注册的指令"></a>查看已注册的指令</h3><ul><li>详见（telegram方法 getMyCommands）</li></ul><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><p>telegram建议我们的机器人都带上三条基本指令分别是</p><ul><li><code>/start</code></li><li><code>/help</code></li><li><code>/settings</code></li></ul><p>当设置了上面三个命令，用户首次打开与你的机器人的对话时，将看到<code>Start</code>按钮。机器人的个人资料页面上的菜单中将提供<code>Help</code>和<code>Settings</code>链接。</p><h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><p>telegram中键盘也是机器人的一大特色，开发者可以自定义自己的键盘，一个键盘相当于机器人的菜单可以理解为一个答复界面，可以更加方便的和机器人交互。</p><p>telegram中的键盘有四种<code>ReplyKeyboardMarkup</code>，<code>InlineKeyboardMarkup</code>，<code>ReplyKeyboardRemove</code>和<code>ForceReply</code>，这四个对象可参考前面的介绍</p><h3 id="创建键盘"><a href="#创建键盘" class="headerlink" title="创建键盘"></a>创建键盘</h3><p>只需要在<code>sendMessage</code>时指定<code>reply_markup</code>即可，详见<code>sendMessage</code>方法</p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> telegram </tag>
            
            <tag> bot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go get 私有库</title>
      <link href="/2020/09/01/go-get-%E7%A7%81%E6%9C%89%E5%BA%93/"/>
      <url>/2020/09/01/go-get-%E7%A7%81%E6%9C%89%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<ol><li><p>将本地的ssh公钥添加进私有git服务器</p></li><li><p>使用git协议拉取代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --add url.<span class="string">&quot;git@git.balabala.xxx:&quot;</span>.insteadOf <span class="string">&quot;https://git.balabala.xxx/&quot;</span>  </span><br></pre></td></tr></table></figure></li><li><p>设置GOPRIVATE环境变量为私有服务器地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPRIVATE=git.balabala.xxx/*</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tornado中的cookie</title>
      <link href="/2020/09/01/tornado%E4%B8%AD%E7%9A%84cookie/"/>
      <url>/2020/09/01/tornado%E4%B8%AD%E7%9A%84cookie/</url>
      
        <content type="html"><![CDATA[<p>Tornado中的cookie分为两种–<em>普通cookie</em>和<em>安全cookie</em></p><h2 id="普通cookie"><a href="#普通cookie" class="headerlink" title="普通cookie"></a>普通cookie</h2><h3 id="1-创建cookie"><a href="#1-创建cookie" class="headerlink" title="1.创建cookie"></a>1.创建cookie</h3><p><strong>原型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.set_cookie(name, value, domain=<span class="literal">None</span>,expires=<span class="literal">None</span>, path=<span class="string">&quot;/&quot;</span>, expires_days=<span class="literal">None</span>, **kwargs</span><br></pre></td></tr></table></figure><p><strong>参数解释</strong></p><table><thead><tr><th>参数名</th><th>意义</th></tr></thead><tbody><tr><td>name</td><td>创建cookie的名称</td></tr><tr><td>value</td><td>创建cookie的值</td></tr><tr><td>domain</td><td>提交cookie时匹配的域名</td></tr><tr><td>path</td><td>提交cookie时匹配的路径</td></tr><tr><td>expires</td><td>cookie的有效期,可以是时间戳整数,时间元组,datetime类型.为UTC时间</td></tr><tr><td>expires_days</td><td>cookie的有效期天数.优先级低于expires</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCookieHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.set_cookie(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;kainhuck&quot;</span>)</span><br><span class="line">        self.write(<span class="string">&quot;ok&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h3><p>设置cookie的原理实际上是通过设置headers中的**<em>Set-Cookie**</em>来实现的.</p><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.set_header(<span class="string">&quot;Set-Cookie&quot;</span>, <span class="string">&quot;name=kainhuck; Path=/&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="3-获取cookie"><a href="#3-获取cookie" class="headerlink" title="3.获取cookie"></a>3.获取cookie</h3><p><strong>原型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.get_cookie(name, default=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><strong>参数解释</strong></p><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>name</td><td>要获取的cookie的名称</td></tr><tr><td>default</td><td><strong>如果要获取的</strong>cookie值不存在,则返回default的值</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetComCookie</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        cookie = self.get_cookie(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;NULL&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;cookie:&quot;</span>,cookie)</span><br><span class="line">        self.write(<span class="string">&quot;ok&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-清除cookie"><a href="#4-清除cookie" class="headerlink" title="4.清除cookie"></a>4.清除cookie</h3><p>清除cookie有两中方法</p><p><strong>法一:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.clear_cookie(name, path=<span class="string">&quot;/&quot;</span>, domain=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><em>删除名为name,并同时匹配domain和path的cookie</em></p><p><strong>法二:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.clear_all_cookies(path=<span class="string">&quot;/&quot;</span>, domain=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><em>删除同时匹配path和domain的所有cookie</em></p><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClearPCookieHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 清除一个cookie</span></span><br><span class="line">        <span class="comment"># self.clear_cookie(&quot;hello&quot;)</span></span><br><span class="line">        <span class="comment"># 清除所有cookie</span></span><br><span class="line">        self.clear_all_cookies()</span><br><span class="line">        self.write(<span class="string">&quot;ok&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="安全cookie"><a href="#安全cookie" class="headerlink" title="安全cookie"></a>安全cookie</h2><p><em>tornado提供了一种对cookie进行简易加密方式来防止Cookie被恶意篡改</em></p><h3 id="1-设置安全cookie"><a href="#1-设置安全cookie" class="headerlink" title="1.设置安全cookie"></a>1.设置安全cookie</h3><p>设置安全cookie需要一个进行混淆加密的秘钥</p><p><em>生成秘钥的方法举例</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line">key = base64.b64encode(uuid.uuid4().bytes + uuid.uuid4().bytes)</span><br><span class="line">print(key) <span class="comment"># zadJa2GJTOu5wGL62RngnVrUxVoQ80H2u6qjAfQ4rv4=</span></span><br></pre></td></tr></table></figure><p>并在*<strong>tornado.web.Application**<em>里添加</em></strong>cookie_secret***</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;cookie_secret&quot;: &quot;zadJa2GJTOu5wGL62RngnVrUxVoQ80H2u6qjAfQ4rv4&#x3D;&quot;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SCookieHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        self.set_secure_cookie(<span class="string">&quot;laohu&quot;</span>, <span class="string">&quot;good&quot;</span>)</span><br><span class="line">        self.write(<span class="string">&quot;ok&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>安全cookie值的样子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2|1:0|10:1548248269|5:laohu|8:Z29vZA&#x3D;&#x3D;|c611b726829b3ba268e7e01da446a9daed7262b505e29ec34fdf239cef2fcfc8</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><blockquote><ul><li>以竖线分割, 冒号前面表示后面有几位</li><li>安全cookie的版本,默认使用版本2</li><li>默认为0</li><li>时间戳</li><li>cookie名</li><li>base64编码的cookie值</li><li>签名值,不带长度说明</li></ul></blockquote><h3 id="2-获取安全cookie"><a href="#2-获取安全cookie" class="headerlink" title="2.获取安全cookie"></a>2.获取安全cookie</h3><p><strong>原型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.get_secure_cookie(name, value=<span class="literal">None</span>, max_age_days=<span class="number">31</span>, min_version=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><em>说明一:</em> 如果cookie存在且验证通过,返回cookie值,否则返回None</p><p><em>说明二:</em> max_age_days不同于expires_days,expires_days设置浏览器中的cookie的有效时间.而max_age_days是过滤安全cookie的时间戳</p><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetSCookieHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        scookie = self.get_secure_cookie(<span class="string">&quot;laohu&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;scookie =&quot;</span>, scookie)</span><br><span class="line">        self.write(<span class="string">&quot;ok&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>安全cookie不是完全的安全,只是增加了破解cookie的难度,请勿用cookie存储敏感数据</p>]]></content>
      
      
      <categories>
          
          <category> 网络框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> tornado </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis手动安装</title>
      <link href="/2020/08/31/redis%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85/"/>
      <url>/2020/08/31/redis%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h1><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.5.tar.gz</span><br></pre></td></tr></table></figure><h3 id="2-解压"><a href="#2-解压" class="headerlink" title="2.解压"></a>2.解压</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-5.0.5.tar.gz</span><br></pre></td></tr></table></figure><h3 id="3-进入解压目录"><a href="#3-进入解压目录" class="headerlink" title="3.进入解压目录"></a>3.进入解压目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-5.0.5 </span><br></pre></td></tr></table></figure><h3 id="4-编译"><a href="#4-编译" class="headerlink" title="4.编译"></a>4.编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><h3 id="5-安装到指定的安装目录"><a href="#5-安装到指定的安装目录" class="headerlink" title="5.安装到指定的安装目录"></a>5.安装到指定的安装目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis install</span><br></pre></td></tr></table></figure><h3 id="6-切换到安装目录"><a href="#6-切换到安装目录" class="headerlink" title="6.切换到安装目录"></a>6.切换到安装目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redis</span><br></pre></td></tr></table></figure><h3 id="7-把配置文件复制到redis安装目录下"><a href="#7-把配置文件复制到redis安装目录下" class="headerlink" title="7.把配置文件复制到redis安装目录下"></a>7.把配置文件复制到redis安装目录下</h3><p>我这里的redis下载目录为<code>~/Documents</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp ~&#x2F;Documents&#x2F;redis-5.0.5&#x2F;redis.conf .&#x2F;</span><br></pre></td></tr></table></figure><h3 id="8-修改redis配置文件"><a href="#8-修改redis配置文件" class="headerlink" title="8.修改redis配置文件"></a>8.修改redis配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim redis.conf</span><br></pre></td></tr></table></figure><p><strong>将<code>*daemonize no*</code>改为 <code>*daemonize yes*</code>,(后台运行redis)</strong></p><p><strong>修改 <code>requirepass foobared</code> 用以设置密码</strong></p><p><strong>将 <em>logfile “”</em> 改为 <em>logfile “/usr/local/redis/redis.log”</em>(日志文件路径,自定义,注意:放到家目录以外的地方可能引起权限问题)</strong> </p><h3 id="9-启动redis"><a href="#9-启动redis" class="headerlink" title="9. 启动redis"></a>9. 启动redis</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf</span><br></pre></td></tr></table></figure><p>查看是否启动成功<em>ps -aux | grep redis</em></p><h3 id="10-连接redis服务"><a href="#10-连接redis服务" class="headerlink" title="10. 连接redis服务"></a>10. 连接redis服务</h3><p><em>连接命令 -h 主机ip -p 端口</em></p><p>如果是本地连接,直接输入连接命令即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli</span><br></pre></td></tr></table></figure><h3 id="11-正常关闭redis服务"><a href="#11-正常关闭redis服务" class="headerlink" title="11. 正常关闭redis服务"></a>11. 正常关闭redis服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli shutdown</span><br></pre></td></tr></table></figure><h2 id="为了方便启动可以做如下操作"><a href="#为了方便启动可以做如下操作" class="headerlink" title="为了方便启动可以做如下操作"></a>为了方便启动可以做如下操作</h2><ol><li><p>方便启动客户端</p><p>将<code>/usr/local/redis/bin/redis-cli</code>链接到<code>/usr/local/bin</code>目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure><p>注意:<em>如果没有设置redis密码,利用命令<code>redis-cli shutdown</code>关闭redis需要加<code>sudo</code></em></p></li><li><p>方便启动服务端</p><p>在<code>/usr/local/bin</code>下编写脚本<code>redis_run.sh</code>用以启动redis服务<br>1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure><p>2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo echo -e &#39;#!&#x2F;bin&#x2F;bash\n&#96;sudo &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf&#96;&#39; &gt; redis_run.sh</span><br></pre></td></tr></table></figure><p> 如果提示权限问题,请手动写入,内容如下 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">&#96;sudo &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf&#96;</span><br></pre></td></tr></table></figure><p>3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x redis_run.sh</span><br></pre></td></tr></table></figure><p>4</p><p>如果觉得<code>redis_run.sh</code>文件名不舒服可以重命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv redis_run.sh redis-ser</span><br></pre></td></tr></table></figure></li></ol><p>   以后启动redis服务时,可在任意目录下输入命令 <code>redis-ser</code></p><p>   启动客户端时可在任意目录下输入<code>redis-cli</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议概述</title>
      <link href="/2020/08/16/HTTP%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/08/16/HTTP%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>HTTP协议并不是什么高深的协议，相反正式因为HTTP协议足够简单所以它才会被广泛的使用。</p><h2 id="2-什么是协议"><a href="#2-什么是协议" class="headerlink" title="2. 什么是协议"></a>2. 什么是协议</h2><p>很多人不理解http协议其实是因为不理解<code>协议</code>或者说是自己将协议复杂化。其实协议很简单，就是一个约定。</p><p><strong>举个例子</strong></p><p>在你的电脑上有许多文件<code>1.txt 2.txt 3.txt ...</code>, 现在我想通过互联网来从你的电脑上获取这些文件。为了完成这一目的我们需要以下几步</p><ol><li><p>首先我需要在互联网上和你的电脑建立连接，为了保证传输的稳定性我们选择使用TCP协议（不理解TCP协议的同学，先简单的理解为负责传输我们数据的一种方式）来建立我们的连接。</p></li><li><p>建立连接后我发消息告诉你我想要的文件，你接收到我的消息后将对应的文件发送给我。</p><ul><li><p>这时就有一些问题，你的程序处理我发送消息是死板的，比如我发送<code>给我1.txt</code>和<code>把 1.txt 给我</code>对我来说都是一样的目的，但是你的程序解读时是不一样的。</p></li><li><p>为了解决这个问题我们必须统一我发送请求的格式，这样你的程序解读时就比较方便，因为有了固定的格式</p><p>比如我们约定如果我想获取你电脑上的文件我发送的请求格式就必须为<code>GET 文件名 \r\n</code>, 其中<code>GET</code>代表你这次的请求目的是<code>获取</code>，然后空一格写上你想要的文件名，最后用<code>\r\n</code> 代表请求结束</p></li><li><p>有了这种统一的约定就会很方便的实现一些功能</p></li></ul></li></ol><p>我们上面举的例子中的<code>约定</code>就是所谓的<code>协议</code></p><h2 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h2><p>HTTP的全称是<code>HyperText Transfer Protocol</code>中文叫做超文本传输协议，所谓的超文本其实就是<code>HTML</code>文件，把上面例子中的<code>txt文件</code>换成<code>html</code>文件，那么那就是HTTP的第一个版本(HTTP/0.9)，http是c/s模式的，从上面的例子我们可以看出<code>我</code>扮演的就是客户端,<code>你</code>扮演的就是服务端。其实随着http协议的发展其可以传送的文件类型几乎可以是任何类型</p><p><strong>为什么要叫html文件为超文本</strong></p><p>因为html文件里可以包含超链接（就是URL，他只是字符串，不要理解为超链接有特殊功能，哪些跳转功能都是浏览器实现的），它指向了网络中另外一处的资源，这样html可以组织互联网中的资源，可能是这样比较高级吧所以发明者称之为<code>超文本</code>。</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p><code>http/1.1</code>是http版本的一种，是标准化的协议，发布于1997年，时至今日<code>http/1.1</code>仍然是使用最广泛的协议。</p><p>在<code>HTTP/1.0</code>的时候引入了请求头的概念，我们可以通过设置请求头可能很方便的对HTTP协议进行拓展。</p><h3 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h3><p>http协议定义的请求格式由4个部分组成，分别是<code>请求行</code>，<code>请求头</code>，<code>空行</code>，<code>请求体</code></p><ul><li><p>请求行</p><p>指定请求的方法，路径，协议版本</p></li><li><p>请求头</p><p>以键值对的方式设置一些需要告诉服务端的其他信息，比如<code>User-Agent: Firefox</code>代表你的用户代理是Firefox</p></li><li><p>空行</p><p>就是普通的空行，分割上面的头部和下面的请求体</p></li><li><p>请求体</p><p>像<code>POST</code>这类方法需要发送而外的请求信息就会把要发送的数据放在请求体中</p></li></ul><h3 id="响应例子"><a href="#响应例子" class="headerlink" title="响应例子"></a>响应例子</h3><p>http协议定义的响应格式同请求格式类似，也是由四个部分组成：<code>响应行</code>，<code>响应头</code>，<code>空行</code>，<code>响应体</code></p><ul><li><p>响应行</p><p>http的版本，响应状态码，响应信息</p></li><li><p>响应头</p><p>以键值对的方式设置一些需要告诉客户端的其他信息，比如：<code>Content-Type: text/html</code>代表传给你的文件类型是html</p></li><li><p>空行</p><p>就是普通的空行，分割上面的头部和下面的响应体</p></li><li><p>响应体</p><p>客户端请求的数据将会放在响应体中返回</p></li></ul><p><strong>举个例子</strong></p><p>为了更好的阅读，在下面我会将<code>\r\n</code>（回车换行符）用折行来显示，比如</p><p><code>aaaaa \r\n bbb</code></p><p>显示为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaaaa</span><br><span class="line">bbb</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;GET &#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;Simple_header HTTP&#x2F;1.1</span><br><span class="line">&gt;Host: developer.mozilla.org</span><br><span class="line">&gt;User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko&#x2F;20100101 Firefox&#x2F;50.0</span><br><span class="line">&gt;Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">&gt;Accept-Language: en-US,en;q&#x3D;0.5</span><br><span class="line">&gt;Accept-Encoding: gzip, deflate, br</span><br><span class="line">&gt;Referer: https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;Simple_header</span><br><span class="line"></span><br><span class="line">&gt;HTTP&#x2F;1.1 200 OK</span><br><span class="line">&gt;Connection: Keep-Alive</span><br><span class="line">&gt;Content-Encoding: gzip</span><br><span class="line">&gt;Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">&gt;Date: Wed, 20 Jul 2016 10:55:30 GMT</span><br><span class="line">&gt;Etag: &quot;547fa7e369ef56031dd3bff2ace9fc0832eb251a&quot;</span><br><span class="line">&gt;Keep-Alive: timeout&#x3D;5, max&#x3D;1000</span><br><span class="line">&gt;Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT</span><br><span class="line">&gt;Server: Apache</span><br><span class="line">&gt;Transfer-Encoding: chunked</span><br><span class="line">&gt;Vary: Cookie, Accept-Encoding</span><br><span class="line"></span><br><span class="line">&gt;(content)</span><br></pre></td></tr></table></figure></blockquote><p>  <strong>解读</strong></p><ul><li>请求部分</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;Simple_header HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><p>GET方法</p><p>请求地址：/en-US/docs/Glossary/Simple_header</p><p>HTTP版本：HTTP/1.1</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host: developer.mozilla.org</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko&#x2F;20100101 Firefox&#x2F;50.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Referer: https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;Simple_header</span><br></pre></td></tr></table></figure><p>请求头部分，数据以键值对的方式存放，请求头中的key种类繁多，每种请求按需取用，这里代表的意思是</p><p>请求主机: developer.mozilla.org</p><p>用户代理（你是谁）：Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0</p><p>接受的类型（这个类型展开又可以讲很多）：text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8</p><p>接受的自然语言：en-US,en;q=0.5</p><p>接受的编码方式：gzip, deflate, br</p><p>从哪里跳转过来：<a href="https://developer.mozilla.org/en-US/docs/Glossary/Simple_header">https://developer.mozilla.org/en-US/docs/Glossary/Simple_header</a></p></blockquote><blockquote><p>由于这里GET请求没有没有携带而外参数，所以就没有请求体</p></blockquote><ul><li>响应部分</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br></pre></td></tr></table></figure><p>HTTP协议：HTTP/1.1</p><p>响应状态码: 200</p><p>响应状态描述: OK</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">Date: Wed, 20 Jul 2016 10:55:30 GMT</span><br><span class="line">Etag: &quot;547fa7e369ef56031dd3bff2ace9fc0832eb251a&quot;</span><br><span class="line">Keep-Alive: timeout&#x3D;5, max&#x3D;1000</span><br><span class="line">Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Vary: Cookie, Accept-Encoding</span><br></pre></td></tr></table></figure><p>响应头</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>空行</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(content)</span><br></pre></td></tr></table></figure><p>响应体内容</p></blockquote><h2 id="HTTP的特点"><a href="#HTTP的特点" class="headerlink" title="HTTP的特点"></a>HTTP的特点</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><p>http是比较简单的应用层协议，通过一些列请求方法来区分不同功能的请求，通过URL来在互联网上定位资源，通过头部来携带一些其他数据，通过Body来携带数据，而且HTTP/1.1及其之前的数据报都是可以阅读的。</p><h3 id="可拓展"><a href="#可拓展" class="headerlink" title="可拓展"></a>可拓展</h3><p>由于HTTP/1.0开始引入了头部概念，所以我们可以通过添加自己的头部信息来实现自定义的功能。</p><h3 id="无状态，有会话的"><a href="#无状态，有会话的" class="headerlink" title="无状态，有会话的"></a>无状态，有会话的</h3><p>从上面的例子可以看出每一次请求之间都是孤立的没有联系的，也就是说HTTP请求是无状态的，这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。为了解决这个问题，我们可以在头部加一个字段本质上取名可以任意，但是为了统一我们将这个字段的名称取为<code>Cookie</code>，我们把商品信息加入到这个字段中，然后每次请求都带上<code>Cookie</code>这个字段就实现了有状态的会话。</p><h2 id="HTTP-1-x的缺点"><a href="#HTTP-1-x的缺点" class="headerlink" title="HTTP/1.x的缺点"></a>HTTP/1.x的缺点</h2><p>HTTP是传输层上的应用层协议，最常见的传输层协议有两种<code>UDP</code>，<code>TCP</code>为了稳定起见，HTTP选择了TCP协议。但是建立TCP比较耗时，而且通常一个网页会同时会发起多个HTTP请求，由于HTTP/1.x不能复用一个TCP连接所以每个HTTP请求都会单独开一个TCP连接，这将非常低效。为了减轻这些缺陷，HTTP/1.1引入了流水线（被证明难以实现）和持久连接的概念：底层的TCP连接可以通过Connection头部来被部分控制。HTTP/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang中使用gRPC</title>
      <link href="/2020/07/18/golang%E4%B8%AD%E4%BD%BF%E7%94%A8gRPC/"/>
      <url>/2020/07/18/golang%E4%B8%AD%E4%BD%BF%E7%94%A8gRPC/</url>
      
        <content type="html"><![CDATA[<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC(Remote Procedure Call: 远程过程调用)是一个计算机通信协议，该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。</p><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>gRPC 一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。（<a href="http://doc.oschina.net/grpc%EF%BC%89">http://doc.oschina.net/grpc）</a></p><p>在 gRPC 里<em>客户端</em>应用可以像调用本地对象一样直接调用另一台不同的机器上<em>服务端</em>应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个<em>服务</em>，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个<em>存根</em>能够像服务端一样的方法。</p><p>gRPC 默认使用 <em>protocol buffers</em>，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）。</p><p>使用gRPC分为三步</p><ul><li>编写.proto文件</li><li>利用工具将.proto文件生成对应语言的代码</li><li>根据生成的代码编写服务端和客户端的代码</li></ul><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>首先我们需要安装将.proto文件生成对应代码的工具，下载地址（<a href="https://github.com/protocolbuffers/protobuf/releases%EF%BC%89%EF%BC%8C%E4%B8%8B%E8%BD%BD%E4%BD%A0%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%8D%B3%E5%8F%AF%E3%80%82%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%E8%A7%A3%E5%8E%8B%E5%B0%86%E5%85%B6bin%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%94%BE%E5%85%A5%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8D%B3%E5%8F%AF%E3%80%82">https://github.com/protocolbuffers/protobuf/releases），下载你对应操作系统的压缩包即可。下载完成后解压将其bin目录下的可执行文件放入环境变量中的文件夹即可。</a></p><p>此外，我们还需要安装对应语言的插件，比如</p><p>go语言插件安装方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go</span><br></pre></td></tr></table></figure><p>python插件安装方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install grpcio</span><br><span class="line">pip install protobuf</span><br><span class="line">pip install grpcio_tools</span><br></pre></td></tr></table></figure><p>接下来我将以一个例子来做演示介绍如何在go中使用gRPC,注意我将采用go module的方式来编写这个demo,</p><p>首先我们在一个你喜欢的文件夹下面新建一个文件夹命名为<code>hello_grpc</code>，然后在<code>hello_grpc</code>文件夹下新建一个go.mod文件并写入一下内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module <span class="string">&quot;hello_grpc&quot;</span></span><br></pre></td></tr></table></figure><p>然后用你喜欢的IDE打开这个文件夹，进行之后的操作</p><h2 id="1-编写-proto文件"><a href="#1-编写-proto文件" class="headerlink" title="1. 编写.proto文件"></a>1. 编写.proto文件</h2><p>我们在项目的根目录下新建名为<code>pb</code>的文件夹,然后新建名为<code>hello_grpc.proto</code>的文件，写入如下内容,这是一个官方的例子</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">service</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">option</span> go_package = &quot;.;hello_grpc&quot;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">service Greeter </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>其中第一行指定了我们使用 protocol buffers的版本</p><p>下面我们定义了包的名称，这将成为后面我们生成的go语言的代码的包名</p><p>然后我们定义了一个服务名为Greeter，其中定义了一个函数SayHello它的参数定义在HelloRequest，返回值定义在HelloReply</p><p>关于proto的服务，一共有4种类型，此例子中是最简单的一种</p><ul><li><p><em>简单 RPC</em> </p><p>客户端使用存根发送请求到服务器并等待响应返回，就像平常的函数调用一样。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> GetFeature(Point) <span class="keyword">returns</span> (Feature) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>服务器端流式 RPC</em> </p><p>客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。从例子中可以看出，通过在 <em>响应</em> 类型前插入 <code>stream</code> 关键字，可以指定一个服务器端的流方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>客户端流式 RPC</em> </p><p>客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦客户端完成写入消息，它等待服务器完成读取返回它的响应。通过在 <em>请求</em> 类型前指定 <code>stream</code> 关键字来指定一个客户端的流方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>双向流式 RPC</em></p><p>是双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器可以以任意喜欢的顺序读写：比如， 服务器可以在写入响应前等待接收所有的客户端消息，或者可以交替的读取和写入消息，或者其他读写的组合。 每个流中的消息顺序被预留。你可以通过在请求和响应前加 <code>stream</code> 关键字去制定方法的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-生成对应语言的代码"><a href="#2-生成对应语言的代码" class="headerlink" title="2. 生成对应语言的代码"></a>2. 生成对应语言的代码</h2><p>在我们项目的根目录下新建<code>service</code>目录（这将用来存放我们生成的golang代码），然后打开终端，输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I pb&#x2F; pb&#x2F;hello_grpc.proto --go_out&#x3D;plugins&#x3D;grpc:service</span><br></pre></td></tr></table></figure><p><code>-I</code> 后面指定proto文件存放目录，和proto文件 </p><p><code>--go_out=plugins=grpc:</code>后面指定生成go代码存放的目录</p><p>检查在service目录下是否成功生成一个名为<code>hello_grpc.pb.go</code>的文件</p><p>打开这个文件发现抱错，原因是我们的项目中还没有安装相应的包，输入以下命令安装</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> mod tidy</span><br></pre></td></tr></table></figure><h2 id="3-编写服务端和客户端的代码"><a href="#3-编写服务端和客户端的代码" class="headerlink" title="3.编写服务端和客户端的代码"></a>3.编写服务端和客户端的代码</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>在根目录下新建文件夹<code>server</code>然在这个文件夹下新建<code>server.go</code>，写入以下内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;hello_grpc/service&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc/reflection&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *service.HelloRequest)</span> <span class="params">(*service.HelloReply, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;service.HelloReply&#123;Message: <span class="string">&quot;hello &quot;</span> + in.Name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 监听本地端口</span></span><br><span class="line">lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;监听端口失败: %s&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建gRPC服务器</span></span><br><span class="line">s := grpc.NewServer()</span><br><span class="line"><span class="comment">// 注册服务</span></span><br><span class="line">service.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line"></span><br><span class="line">reflection.Register(s)</span><br><span class="line"></span><br><span class="line">err = s.Serve(lis)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;开启服务失败: %s&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里先定义了一个结构体，该结构体需要实现<code>GreeterServer</code>这个接口(见生成的代码，如下)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GreeterServer <span class="keyword">interface</span> &#123;</span><br><span class="line">SayHello(context.Context, *HelloRequest) (*HelloReply, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p>同理在项目根目录下新建<code>client/client.go</code>写入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;hello_grpc/service&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line">conn, err := grpc.Dial(<span class="string">&quot;:8080&quot;</span>, grpc.WithInsecure())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;连接服务端失败: %s&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个客户端</span></span><br><span class="line">c := service.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用服务端函数</span></span><br><span class="line">r, err := c.SayHello(context.Background(), &amp;service.HelloRequest&#123;Name: <span class="string">&quot;horika&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;调用服务端代码失败: %s&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;调用成功: %s&quot;</span>, r.Message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-运行"><a href="#4-运行" class="headerlink" title="4. 运行"></a>4. 运行</h2><ul><li><p>先运行服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run server&#x2F;server.go</span><br></pre></td></tr></table></figure></li><li><p>开新的终端运行客户端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run client/client.<span class="keyword">go</span></span><br></pre></td></tr></table></figure></li><li><p>观察客户端输出</p></li></ul><h2 id="5-番外篇：编写跨语言调用"><a href="#5-番外篇：编写跨语言调用" class="headerlink" title="5. 番外篇：编写跨语言调用"></a>5. 番外篇：编写跨语言调用</h2><p>以python为例，这里就不编写python的服务端了，直接编写python的客户端调用go的服务端</p><p>注意：你是否安装python的插件？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install grpcio</span><br><span class="line">pip install protobuf</span><br><span class="line">pip install grpcio_tools</span><br></pre></td></tr></table></figure><h3 id="生成python代码"><a href="#生成python代码" class="headerlink" title="生成python代码"></a>生成python代码</h3><p>在项目跟目录下新建文件夹<code>python</code>然后在根目录下打开终端输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I pb&#x2F; --python_out&#x3D;python&#x2F; --grpc_python_out&#x3D;python&#x2F; pb&#x2F;hello_grpc.proto</span><br></pre></td></tr></table></figure><p>在刚刚新建的文件夹下查看是否多出来了两个文件<code>hello_grpc_pb2.py</code>和<code>hello_grpc_pb2_grpc.py</code></p><h3 id="编写python客户端代码"><a href="#编写python客户端代码" class="headerlink" title="编写python客户端代码"></a>编写python客户端代码</h3><p>在python文件夹中新建client.py写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hello_grpc_pb2</span><br><span class="line"><span class="keyword">import</span> hello_grpc_pb2_grpc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">with</span> grpc.insecure_channel(<span class="string">&#x27;localhost:8080&#x27;</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = hello_grpc_pb2_grpc.GreeterStub(channel)</span><br><span class="line">        response = stub.SayHello(hello_grpc_pb2.HelloRequest(name=<span class="string">&#x27;horika&#x27;</span>))</span><br><span class="line">    print(<span class="string">&quot;调用成功: &#123;&#125;!&quot;</span>.format(response.message))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>运行go的服务端，然后运行python客户端查看输出</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang实现定时任务</title>
      <link href="/2020/07/18/golang%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2020/07/18/golang%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装cron"><a href="#1-安装cron" class="headerlink" title="1. 安装cron"></a>1. 安装cron</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com&#x2F;robfig&#x2F;cron</span><br></pre></td></tr></table></figure><h2 id="2-先看一个例子"><a href="#2-先看一个例子" class="headerlink" title="2. 先看一个例子"></a>2. 先看一个例子</h2><p>这个例子将会每秒钟打印 一次<code>hello world</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/robfig/cron&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">c := cron.New()</span><br><span class="line">_ = c.AddFunc(<span class="string">&quot;* * * * * *&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">c.Start()</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做几点说明：</p><ul><li>cron.New() 创建一个cron对象</li><li>cron对象通过AddFunc方法将一个函数按指定的时间计划执行</li><li><code>* * * * * *</code>就是我们的时间计划，这是指每秒执行一次，后面在详细讲</li><li>Start() 方法开始执行</li><li>time.Sleep(10 * time.Second) 防止主goroutine退出否则这个程序就会结束，任务将会无法执行</li></ul><h2 id="3-解决你的疑惑"><a href="#3-解决你的疑惑" class="headerlink" title="3. 解决你的疑惑"></a>3. 解决你的疑惑</h2><h3 id="time-Sleep-真的好吗？"><a href="#time-Sleep-真的好吗？" class="headerlink" title="time.Sleep() 真的好吗？"></a>time.Sleep() 真的好吗？</h3><p>我们知道这一个语句的作用是让主goroutine等待，对于一个定时任务来说主goroutine应该一直等待，time.Sleep()肯定不是最好的解决方法，那我们该怎么做呢</p><ul><li><p>勇敢的尝试 <code>死循环</code></p><p>注意一些IDE会提示死循环的错误，但其实是可以编译运行的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/robfig/cron&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">c := cron.New()</span><br><span class="line">_ = c.AddFunc(<span class="string">&quot;* * * * * *&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">c.Start()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这视乎达到了我们的效果，但是大家都明白这样做的后果，看下你的电脑cpu利用率，我的电脑cpu占用率是30%左右</p></li><li><p>利用select改进我们的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/robfig/cron&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">c := cron.New()</span><br><span class="line">_ = c.AddFunc(<span class="string">&quot;* * * * * *&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">c.Start()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我的电脑cpu占用率是10%左右</p><p>但这是真的是最好的版本吗？</p></li><li><p>for 和 select 结合</p><p>设置一个定时器</p><p>利用for加select等待</p><p>每当计时器可以取值时，重置计时器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t := time.NewTimer(time.Second * <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">t.Reset(time.Second * <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="* * * * * * 是什么？"></a>* * * * * * 是什么？</h3><p>这上面的例子中我们用<code>* * * * * *</code>来表示我们的定时计划，我已经告诉你们了，这表示每秒中执行一次，下面让我们详细的了解一下它的语法吧。</p><ul><li><p>这个字符串一共由6位组成，每一位之间用一个空格隔开，每一位的意思如下</p><p>第一位：秒</p><p>第二位：分</p><p>第三位：时</p><p>第四位：一月中的某天(日)</p><p>第五位：月</p><p>第六位：星期几</p></li><li><p>我们明白了位置的含义，那么这些符号又是什么意思呢</p><table><thead><tr><th>符号</th><th>表示的含义</th></tr></thead><tbody><tr><td>*</td><td>表示<code>每</code>的意思，比如在第一位就表示每秒</td></tr><tr><td>/</td><td>后跟数字表示<code>每隔</code>的意思，比如在第一位<code>*/10</code>，表示每隔10秒执行一次；<code>1-30/10</code>，表示从第一秒到第30秒每个10秒执行一次</td></tr><tr><td>,</td><td>枚举，比如第6个字段值是 MON,WED,FRI，表示 星期一、三、五 执行</td></tr><tr><td>-</td><td>表示范围，比如第一位<code>1-30</code>表示第一秒到第30秒每秒执行一次</td></tr><tr><td>?</td><td>只用于 第四位 和 第六位，表示不指定值，可以用于代替 *</td></tr><tr><td>具体的数字</td><td>表示具体的时刻，比如第一位是<code>5</code>表示第5秒执行</td></tr></tbody></table></li></ul><h2 id="4-一些常用表达式举例"><a href="#4-一些常用表达式举例" class="headerlink" title="4. 一些常用表达式举例"></a>4. 一些常用表达式举例</h2><table><thead><tr><th>含义</th><th>表达式</th></tr></thead><tbody><tr><td>每隔10秒执行一次</td><td>*/10 * * * * *</td></tr><tr><td>每个10分钟执行一次</td><td>0 */10 * * * *</td></tr><tr><td>每天0点0时0分执行一次</td><td>0 0 0 * * *</td></tr><tr><td>每天9点18点执行一次</td><td>0 0 9,18 * * *</td></tr></tbody></table><p>其实cron也给了一些预定义的表达式</p><table><thead><tr><th>预置表达式</th><th>描述</th><th>表达式</th></tr></thead><tbody><tr><td>@yearly (or @annually)</td><td>1 月 1 日午夜运行一次</td><td>0 0 0 1 1 *</td></tr><tr><td>@monthly</td><td>每个月的午夜，每个月的第一个月运行一次</td><td>0 0 0 1 * *</td></tr><tr><td>@weekly</td><td>每周一次，周日午夜运行一次</td><td>0 0 0 * * 0</td></tr><tr><td>@daily (or @midnight)</td><td>每天午夜运行一次</td><td>0 0 0 * * *</td></tr><tr><td>@hourly</td><td>每小时运行一次</td><td>0 0 * * * *</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang使用zap日志库</title>
      <link href="/2020/07/17/golang%E4%BD%BF%E7%94%A8zap%E6%97%A5%E5%BF%97%E5%BA%93/"/>
      <url>/2020/07/17/golang%E4%BD%BF%E7%94%A8zap%E6%97%A5%E5%BF%97%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-为什么使用zap"><a href="#1-为什么使用zap" class="headerlink" title="1. 为什么使用zap"></a>1. 为什么使用zap</h2><p>因为它很快，而且我写不出比他更快的日志库😭</p><p>当然他还有其他优点，比如：它同时提供了结构化日志记录和printf风格的日志记录</p><h2 id="2-安装zap"><a href="#2-安装zap" class="headerlink" title="2. 安装zap"></a>2. 安装zap</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u go.uber.org/zap</span><br></pre></td></tr></table></figure><h2 id="3-配置zap"><a href="#3-配置zap" class="headerlink" title="3. 配置zap"></a>3. 配置zap</h2><p>zap提供两种日志记录器，如下表</p><table><thead><tr><th>名称</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Sugared Logger</td><td>支持结构化和printf风格的日志记录</td><td>较Logger慢</td></tr><tr><td>Logger</td><td>较Sugared Logger快</td><td>只支持强类型的结构化日志记录</td></tr></tbody></table><h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><ul><li>创建Logger<ul><li>zap.NewProduction()</li><li>zap.NewDevelopment()</li><li>zap.Example()</li></ul></li><li>上述函数均可创建Logger只是输出信息不同</li><li>默认情况下日志会打印到控制台</li></ul><p>举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logger *zap.Logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProductionLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">logger,_ = zap.NewProduction()</span><br><span class="line">logger.Info(<span class="string">&quot;log info&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DevelopmentLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">logger,_ = zap.NewDevelopment()</span><br><span class="line">logger.Info(<span class="string">&quot;log info&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">logger = zap.NewExample()</span><br><span class="line">logger.Info(<span class="string">&quot;log info&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ProductionLogger()</span><br><span class="line">DevelopmentLogger()</span><br><span class="line">ExampleLogger()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;ts&quot;:1594976812.8990078,&quot;caller&quot;:&quot;go_zap&#x2F;main.go:9&quot;,&quot;msg&quot;:&quot;log info&quot;&#125;</span><br><span class="line">2020-07-17T17:06:52.899+0800INFOgo_zap&#x2F;main.go:14log info</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;log info&quot;&#125;</span><br></pre></td></tr></table></figure><p>除DevelopmentLogger之外其余都是json格式输出</p><h3 id="Sugared-Logger"><a href="#Sugared-Logger" class="headerlink" title="Sugared Logger"></a>Sugared Logger</h3><ul><li>创建Sugared Logger<ul><li>由Logger调用Sugar()方法获得</li></ul></li><li>支持printf风格输出日志</li></ul><p>举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sugarLogger *zap.SugaredLogger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProductionLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">logger,_ := zap.NewProduction()</span><br><span class="line">sugarLogger = logger.Sugar()</span><br><span class="line">sugarLogger.Infof(<span class="string">&quot;sugar loger %s&quot;</span>, <span class="string">&quot;yes!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DevelopmentLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">logger,_ := zap.NewDevelopment()</span><br><span class="line">sugarLogger = logger.Sugar()</span><br><span class="line">sugarLogger.Infof(<span class="string">&quot;sugar loger %s&quot;</span>, <span class="string">&quot;yes!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">logger := zap.NewExample()</span><br><span class="line">sugarLogger = logger.Sugar()</span><br><span class="line">sugarLogger.Infof(<span class="string">&quot;sugar loger %s&quot;</span>, <span class="string">&quot;yes!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ProductionLogger()</span><br><span class="line">DevelopmentLogger()</span><br><span class="line">ExampleLogger()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;ts&quot;:1594977351.4368348,&quot;caller&quot;:&quot;go_zap&#x2F;main.go:10&quot;,&quot;msg&quot;:&quot;sugar loger yes!&quot;&#125;</span><br><span class="line">2020-07-17T17:15:51.436+0800INFOgo_zap&#x2F;main.go:16sugar loger yes!</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;sugar loger yes!&quot;&#125;</span><br></pre></td></tr></table></figure><p>输出结果和Logger类似，但是sugarLogger支持printf</p><h2 id="4-定制Logger"><a href="#4-定制Logger" class="headerlink" title="4. 定制Logger"></a>4. 定制Logger</h2><p>上面所介绍到的三个创建Logger的方法包含了一些预置的配置，如果我们想要完全自定义，那我们就需要自己写好自己需要的配置。</p><p>这些配置将被赋值给<code>zap.Config</code>结构体，然后这个结构体对象调用<code>Build</code>方法构造Logger，大概就像这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config := zap.Config&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log, err := config.Build()</span><br></pre></td></tr></table></figure><h3 id="zap-Config"><a href="#zap-Config" class="headerlink" title="zap.Config"></a>zap.Config</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Level is the minimum enabled logging level. Note that this is a dynamic</span></span><br><span class="line"><span class="comment">// level, so calling Config.Level.SetLevel will atomically change the log</span></span><br><span class="line"><span class="comment">// level of all loggers descended from this config.</span></span><br><span class="line">Level AtomicLevel <span class="string">`json:&quot;level&quot; yaml:&quot;level&quot;`</span></span><br><span class="line"><span class="comment">// Development puts the logger in development mode, which changes the</span></span><br><span class="line"><span class="comment">// behavior of DPanicLevel and takes stacktraces more liberally.</span></span><br><span class="line">Development <span class="keyword">bool</span> <span class="string">`json:&quot;development&quot; yaml:&quot;development&quot;`</span></span><br><span class="line"><span class="comment">// DisableCaller stops annotating logs with the calling function&#x27;s file</span></span><br><span class="line"><span class="comment">// name and line number. By default, all logs are annotated.</span></span><br><span class="line">DisableCaller <span class="keyword">bool</span> <span class="string">`json:&quot;disableCaller&quot; yaml:&quot;disableCaller&quot;`</span></span><br><span class="line"><span class="comment">// DisableStacktrace completely disables automatic stacktrace capturing. By</span></span><br><span class="line"><span class="comment">// default, stacktraces are captured for WarnLevel and above logs in</span></span><br><span class="line"><span class="comment">// development and ErrorLevel and above in production.</span></span><br><span class="line">DisableStacktrace <span class="keyword">bool</span> <span class="string">`json:&quot;disableStacktrace&quot; yaml:&quot;disableStacktrace&quot;`</span></span><br><span class="line"><span class="comment">// Sampling sets a sampling policy. A nil SamplingConfig disables sampling.</span></span><br><span class="line">Sampling *SamplingConfig <span class="string">`json:&quot;sampling&quot; yaml:&quot;sampling&quot;`</span></span><br><span class="line"><span class="comment">// Encoding sets the logger&#x27;s encoding. Valid values are &quot;json&quot; and</span></span><br><span class="line"><span class="comment">// &quot;console&quot;, as well as any third-party encodings registered via</span></span><br><span class="line"><span class="comment">// RegisterEncoder.</span></span><br><span class="line">Encoding <span class="keyword">string</span> <span class="string">`json:&quot;encoding&quot; yaml:&quot;encoding&quot;`</span></span><br><span class="line"><span class="comment">// EncoderConfig sets options for the chosen encoder. See</span></span><br><span class="line"><span class="comment">// zapcore.EncoderConfig for details.</span></span><br><span class="line">EncoderConfig zapcore.EncoderConfig <span class="string">`json:&quot;encoderConfig&quot; yaml:&quot;encoderConfig&quot;`</span></span><br><span class="line"><span class="comment">// OutputPaths is a list of URLs or file paths to write logging output to.</span></span><br><span class="line"><span class="comment">// See Open for details.</span></span><br><span class="line">OutputPaths []<span class="keyword">string</span> <span class="string">`json:&quot;outputPaths&quot; yaml:&quot;outputPaths&quot;`</span></span><br><span class="line"><span class="comment">// ErrorOutputPaths is a list of URLs to write internal logger errors to.</span></span><br><span class="line"><span class="comment">// The default is standard error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that this setting only affects internal errors; for sample code that</span></span><br><span class="line"><span class="comment">// sends error-level logs to a different location from info- and debug-level</span></span><br><span class="line"><span class="comment">// logs, see the package-level AdvancedConfiguration example.</span></span><br><span class="line">ErrorOutputPaths []<span class="keyword">string</span> <span class="string">`json:&quot;errorOutputPaths&quot; yaml:&quot;errorOutputPaths&quot;`</span></span><br><span class="line"><span class="comment">// InitialFields is a collection of fields to add to the root logger.</span></span><br><span class="line">InitialFields <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;initialFields&quot; yaml:&quot;initialFields&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要特别注意的是<code>EncoderConfig</code>这个字段，它定义了我们输出的格式，根据他的提示我们来看看<code>zapcore.EncoderConfig</code>结构体</p><h3 id="zapcore-EncoderConfig"><a href="#zapcore-EncoderConfig" class="headerlink" title="zapcore.EncoderConfig"></a>zapcore.EncoderConfig</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An EncoderConfig allows users to configure the concrete encoders supplied by</span></span><br><span class="line"><span class="comment">// zapcore.</span></span><br><span class="line"><span class="keyword">type</span> EncoderConfig <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Set the keys used for each log entry. If any key is empty, that portion</span></span><br><span class="line"><span class="comment">// of the entry is omitted.</span></span><br><span class="line">MessageKey    <span class="keyword">string</span> <span class="string">`json:&quot;messageKey&quot; yaml:&quot;messageKey&quot;`</span></span><br><span class="line">LevelKey      <span class="keyword">string</span> <span class="string">`json:&quot;levelKey&quot; yaml:&quot;levelKey&quot;`</span></span><br><span class="line">TimeKey       <span class="keyword">string</span> <span class="string">`json:&quot;timeKey&quot; yaml:&quot;timeKey&quot;`</span></span><br><span class="line">NameKey       <span class="keyword">string</span> <span class="string">`json:&quot;nameKey&quot; yaml:&quot;nameKey&quot;`</span></span><br><span class="line">CallerKey     <span class="keyword">string</span> <span class="string">`json:&quot;callerKey&quot; yaml:&quot;callerKey&quot;`</span></span><br><span class="line">StacktraceKey <span class="keyword">string</span> <span class="string">`json:&quot;stacktraceKey&quot; yaml:&quot;stacktraceKey&quot;`</span></span><br><span class="line">LineEnding    <span class="keyword">string</span> <span class="string">`json:&quot;lineEnding&quot; yaml:&quot;lineEnding&quot;`</span></span><br><span class="line"><span class="comment">// Configure the primitive representations of common complex types. For</span></span><br><span class="line"><span class="comment">// example, some users may want all time.Times serialized as floating-point</span></span><br><span class="line"><span class="comment">// seconds since epoch, while others may prefer ISO8601 strings.</span></span><br><span class="line">EncodeLevel    LevelEncoder    <span class="string">`json:&quot;levelEncoder&quot; yaml:&quot;levelEncoder&quot;`</span></span><br><span class="line">EncodeTime     TimeEncoder     <span class="string">`json:&quot;timeEncoder&quot; yaml:&quot;timeEncoder&quot;`</span></span><br><span class="line">EncodeDuration DurationEncoder <span class="string">`json:&quot;durationEncoder&quot; yaml:&quot;durationEncoder&quot;`</span></span><br><span class="line">EncodeCaller   CallerEncoder   <span class="string">`json:&quot;callerEncoder&quot; yaml:&quot;callerEncoder&quot;`</span></span><br><span class="line"><span class="comment">// Unlike the other primitive type encoders, EncodeName is optional. The</span></span><br><span class="line"><span class="comment">// zero value falls back to FullNameEncoder.</span></span><br><span class="line">EncodeName NameEncoder <span class="string">`json:&quot;nameEncoder&quot; yaml:&quot;nameEncoder&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些字段都不难理解，让我们来写一个例子吧</p><h3 id="一个简单的样例"><a href="#一个简单的样例" class="headerlink" title="一个简单的样例"></a>一个简单的样例</h3><p>一般情况下我们都是用SugaredLogger因为它的速度足够快，而其功能更加强大，如果呢不知道该怎么选择不如就把两个都选上吧，就像这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line"><span class="string">&quot;go.uber.org/zap/zapcore&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Logger *zap.Logger</span><br><span class="line"><span class="keyword">var</span> SugarLogger *zap.SugaredLogger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span> <span class="title">error</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="comment">// 构造EncoderConfig</span></span><br><span class="line">encoderConfig := zapcore.EncoderConfig&#123;</span><br><span class="line">TimeKey: <span class="string">&quot;timestamp&quot;</span>,</span><br><span class="line">LevelKey: <span class="string">&quot;severity&quot;</span>,</span><br><span class="line">NameKey: <span class="string">&quot;logger&quot;</span>,</span><br><span class="line">CallerKey: <span class="string">&quot;caller&quot;</span>,</span><br><span class="line">MessageKey: <span class="string">&quot;message&quot;</span>,</span><br><span class="line">StacktraceKey: <span class="string">&quot;stacktrace&quot;</span>,</span><br><span class="line">LineEnding: <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">EncodeLevel: zapcore.LowercaseLevelEncoder,</span><br><span class="line">EncodeTime: zapcore.ISO8601TimeEncoder,</span><br><span class="line">EncodeDuration: zapcore.SecondsDurationEncoder,</span><br><span class="line">EncodeCaller:   zapcore.FullCallerEncoder,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 Config</span></span><br><span class="line">config := zap.Config&#123;</span><br><span class="line">Level: zap.NewAtomicLevelAt(zapcore.DebugLevel),</span><br><span class="line">Development: <span class="literal">true</span>,</span><br><span class="line">Encoding: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">EncoderConfig: encoderConfig,</span><br><span class="line">InitialFields: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;MyName&quot;</span>: <span class="string">&quot;kainhuck&quot;</span>&#125;,</span><br><span class="line">OutputPaths: []<span class="keyword">string</span>&#123;<span class="string">&quot;stdout&quot;</span>&#125;,</span><br><span class="line">ErrorOutputPaths: []<span class="keyword">string</span>&#123;<span class="string">&quot;stdout&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以构造Logger了</span></span><br><span class="line">Logger, err = config.Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后是SugarLogger</span></span><br><span class="line">SugarLogger = Logger.Sugar()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">err := Init()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SugarLogger.Debugf(<span class="string">&quot;ohhhhhhh err:%s&quot;</span>, <span class="string">&quot;horika&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;severity&quot;</span>:<span class="string">&quot;debug&quot;</span>,<span class="attr">&quot;timestamp&quot;</span>:<span class="string">&quot;2020-07-17T17:58:56.626+0800&quot;</span>,<span class="attr">&quot;caller&quot;</span>:<span class="string">&quot;D:/Coding/go_module/go_zap/main.go:56&quot;</span>,<span class="attr">&quot;message&quot;</span>:<span class="string">&quot;ohhhhhhh err:horika&quot;</span>,<span class="attr">&quot;MyName&quot;</span>:<span class="string">&quot;kainhuck&quot;</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang使用viper解析配置文件</title>
      <link href="/2020/07/12/golang%E4%BD%BF%E7%94%A8viper%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2020/07/12/golang%E4%BD%BF%E7%94%A8viper%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/spf13/viper">https://github.com/spf13/viper</a></p><p>安装方式：go get github.com/spf13/viper</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>viper是一个十分强大的配置文件解析工具，具有以下特点</p><ul><li>设置默认值</li><li>支持的文件包括JSON, TOML, YAML, HCL, envfile 和 Java properties 配置文件</li><li>实时监听和重新读取配置文件</li><li>从环境变量中读取</li><li>从远程配置系统（etcd或Consul）中读取，并监听更改</li><li>从命令行读取</li><li>从缓冲读取</li><li>设置显示值</li></ul><p><em>另外需要注意的是，viper对配置中的<code>key</code>是大小写不敏感的</em></p><p>下面我以YAML格式的配置文件为例，介绍viper的用法，其他跟多的用法请见<a href="https://github.com/spf13/viper">官网</a></p><h2 id="示例配置文件"><a href="#示例配置文件" class="headerlink" title="示例配置文件"></a>示例配置文件</h2><p>一个好的项目应该把配置文件分成两份，一份存放不敏感信息（比如项目运行端口），一份存放敏感信息（比如数据库密码），下面两个配置文件用作举例</p><p>public config <code>config/config/config.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">TimeStamp:</span> <span class="string">&quot;2018-07-16 10:23:19&quot;</span></span><br><span class="line"><span class="attr">Username:</span> <span class="string">&quot;horika&quot;</span></span><br><span class="line"><span class="attr">BasicInfo:</span></span><br><span class="line">   <span class="attr">RealName:</span> <span class="string">&quot;Harry&quot;</span></span><br><span class="line">   <span class="attr">Age:</span> <span class="string">&quot;18&quot;</span></span><br><span class="line">   <span class="attr">Language:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&quot;Golang&quot;</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&quot;Python&quot;</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&quot;C++&quot;</span></span><br><span class="line">   <span class="attr">Married:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Hobby:</span></span><br><span class="line">  <span class="attr">Sport:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;Lure&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;pingpong&quot;</span></span><br><span class="line">  <span class="attr">Music:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;Bohemian Rhapsody&quot;</span></span><br><span class="line">  <span class="attr">LuckyNumber:</span> <span class="number">22</span></span><br></pre></td></tr></table></figure><p>secret config <code>config/secret/secret.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">admin:</span></span><br><span class="line">    <span class="attr">addr:</span> <span class="string">&quot;127.0.0.1:6379&quot;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">db:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">&quot;mysql&quot;</span></span><br><span class="line">  <span class="attr">uri:</span></span><br><span class="line">    <span class="string">&quot;root:123456@tcp(localhost:3306)/user?charset=utf8&amp;parseTime=True&amp;loc=Local&amp;multiStatements=true&quot;</span></span><br><span class="line"><span class="attr">jwt:</span></span><br><span class="line">  <span class="attr">secret:</span> <span class="string">&quot;horika@^-^@kainhuck&quot;</span></span><br></pre></td></tr></table></figure><h2 id="告诉viper你要解析的配置文件是什么"><a href="#告诉viper你要解析的配置文件是什么" class="headerlink" title="告诉viper你要解析的配置文件是什么"></a>告诉viper你要解析的配置文件是什么</h2><p>示例代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config *viper.Viper</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init 初始化配置文件解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">config = viper.New()</span><br><span class="line"><span class="comment">// 设置 public 配置文件名</span></span><br><span class="line">config.SetConfigName(<span class="string">&quot;config&quot;</span>)</span><br><span class="line"><span class="comment">// 设置 public 配置文件类型</span></span><br><span class="line">config.SetConfigType(<span class="string">&quot;yaml&quot;</span>)</span><br><span class="line"><span class="comment">// 设置配置文件存放的目录</span></span><br><span class="line">config.AddConfigPath(<span class="string">&quot;./config/config&quot;</span>)</span><br><span class="line"><span class="comment">// 读取该配置文件</span></span><br><span class="line">config.ReadInConfig()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 secret config</span></span><br><span class="line">config.SetConfigName(<span class="string">&quot;secret&quot;</span>)</span><br><span class="line">config.SetConfigType(<span class="string">&quot;yaml&quot;</span>)</span><br><span class="line">config.AddConfigPath(<span class="string">&quot;./config/secret&quot;</span>)</span><br><span class="line">config.MergeInConfig()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明</p><ul><li>SetConfigName 指定配置文件名，不需要加后缀</li><li>SetConfigType 指定配置文件类型，可以省略，viper会自动识别</li><li>AddConfigPath 添加配置文件所在目录，可以多个，告诉viper区哪里寻找配置文件</li><li>ReadInConfig 从前面告知的配置中加载配置文件</li><li>MergeInConfig 从前面告知的配置中加载配置文件并合并到之前</li></ul><p>上面演示的只是一种读取方式，viper还有其他的读取方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config *viper.Viper</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init 初始化配置文件解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">config = viper.New()</span><br><span class="line"><span class="comment">// 设置 public 配置文件名</span></span><br><span class="line">config.SetConfigFile(<span class="string">&quot;./config/config/config.yaml&quot;</span>)</span><br><span class="line"><span class="comment">// 读取该配置文件</span></span><br><span class="line">config.ReadInConfig()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 secret config</span></span><br><span class="line">config.SetConfigFile(<span class="string">&quot;./config/secret/secret.yaml&quot;</span>)</span><br><span class="line">config.MergeInConfig()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明</p><ul><li>SetConfigFile 指定配置文件的全路径</li></ul><p>从IO流中读取配置文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config *viper.Viper</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init 初始化配置文件解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">config = viper.New()</span><br><span class="line">f, _ := os.Open(<span class="string">&quot;./config/config/config.yaml&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">config.SetConfigType(<span class="string">&quot;yaml&quot;</span>)</span><br><span class="line">config.ReadConfig(f)</span><br><span class="line"></span><br><span class="line">s, _ := os.Open(<span class="string">&quot;./config/secret/secret.yaml&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> s.Close()</span><br><span class="line">config.SetConfigType(<span class="string">&quot;yaml&quot;</span>)</span><br><span class="line">config.MergeConfig(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明</p><ul><li>ReadConfig 读取io流，注意和ReadInConfig区分</li><li>SetConfigType 从流中读取需要指定文件类型</li></ul><h2 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h2><p>viper读取配置文件就是各种<code>Get</code></p><ul><li>Get 自动判断类型</li><li>GetTime 获取时间类型</li><li>GetString 获取字符串类型</li><li>GetBool 获取bool类型</li><li>GetInt 获取int类型</li><li>GetStringMap 获取map类型</li><li>…</li></ul><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(config.Get(<span class="string">&quot;username&quot;</span>))</span><br><span class="line">fmt.Println(config.Get(<span class="string">&quot;mysql&quot;</span>))</span><br><span class="line">fmt.Println(config.GetTime(<span class="string">&quot;timestamp&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>viper作为一个优秀的配置文件解析工具，他支持将配置信息序列化为结构体对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> config *viper.Viper</span><br><span class="line"><span class="keyword">var</span> AllConfig TotalConfig</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init 初始化配置文件解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">config = viper.New()</span><br><span class="line">config.SetConfigFile(<span class="string">&quot;./config/config/config.yaml&quot;</span>)</span><br><span class="line">config.ReadInConfig()</span><br><span class="line">config.SetConfigFile(<span class="string">&quot;./config/secret/secret.yaml&quot;</span>)</span><br><span class="line">config.MergeInConfig()</span><br><span class="line">config.Unmarshal(&amp;AllConfig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> basicinfo <span class="keyword">struct</span> &#123;</span><br><span class="line">RealName <span class="keyword">string</span></span><br><span class="line">Age      <span class="keyword">int</span></span><br><span class="line">Language []<span class="keyword">string</span></span><br><span class="line">Married  <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> hobby <span class="keyword">struct</span> &#123;</span><br><span class="line">Sport       []<span class="keyword">string</span></span><br><span class="line">Music       []<span class="keyword">string</span></span><br><span class="line">LuckyNumber <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</span><br><span class="line">Addr      <span class="keyword">string</span></span><br><span class="line">paswsword <span class="keyword">string</span></span><br><span class="line">db        <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> redis <span class="keyword">struct</span> &#123;</span><br><span class="line">Admin admin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mysql <span class="keyword">struct</span> &#123;</span><br><span class="line">Driver <span class="keyword">string</span></span><br><span class="line">Uri    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> jwt <span class="keyword">struct</span> &#123;</span><br><span class="line">Secret <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TotalConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">TimeStamp <span class="keyword">string</span></span><br><span class="line">Username  <span class="keyword">string</span></span><br><span class="line">BasicInfo basicinfo</span><br><span class="line">Hobby     hobby</span><br><span class="line">Redis     redis</span><br><span class="line">Mysql     mysql</span><br><span class="line">Jwt       jwt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Init()</span><br><span class="line">fmt.Println(AllConfig.BasicInfo.Married)</span><br><span class="line">fmt.Println(AllConfig.Jwt.Secret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang异常处理机制</title>
      <link href="/2020/06/18/golang%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/06/18/golang%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="对比其他语言"><a href="#对比其他语言" class="headerlink" title="对比其他语言"></a>对比其他语言</h1><p>其他语言比如Python用的是<code>try Except finally</code>的方式来进行异常处理,执行逻辑是:尝试执行一段代码,如果发生异常则执行…无论是否发生异常都执行…;相比起来go语言的异常处理就简单许多,因为程序中的异常基本上都是可预期的,所以GO语言处理异常的方式是返回这个异常,如果没有发生异常则该值为nil,只要判断这个预期的返回值是否是<code>nil</code>便知道有没有异常发生.go语言中还有一种<code>panic</code>机制,<code>panic</code>可以理解为致命的异常会中断程序的运行,但是通过<code>recover</code>函数可捕获这个<code>panic</code>让程序继续运行.</p><h1 id="error"><a href="#error" class="headerlink" title="error"></a>error</h1><p>GO语言中一个普通的错误被称为error,它本质是一个接口类型,可以在<code>builtin.go</code>中看到其定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The error built-in interface type is the conventional interface for</span></span><br><span class="line"><span class="comment">// representing an error condition, with the nil value representing no error.</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>error可以出现在很多地方,比如打开一个不存在的文件,还有数学运算错误等等.</p><p>例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> people <span class="keyword">interface</span> &#123;</span><br><span class="line">name() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, err := os.Open(<span class="string">&quot;不存在.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)<span class="comment">// open 不存在.go: no such file or directory</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建error"><a href="#创建error" class="headerlink" title="创建error"></a>创建error</h1><p>前面我们获得error的方法是接受别人写好函数的返回值,现在我们尝试自己创建一个error,</p><p>在errors包中有多个创建error的方法,其中最常用的是errors.New()方法,该方法接收一个字符串用于描述这个错误.</p><p>其实现如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="comment">// Each call to New returns a distinct error value even if the text is identical.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>New方法返回了一个errorString结构体并将参数text穿进这个结构体中,这个结构体因为实现了Error方法所以他是一个error类型.</p><p>利用errors.New方法创建新error的例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := errors.New(<span class="string">&quot;我自己创建的一个错误&quot;</span>)</span><br><span class="line">fmt.Println(err) <span class="comment">// 我自己创建的一个错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了errors.New()方法创建error外,还可以用fmt.Errorf函数创建新的error,让我们看看fmt.Errorf函数内部的实现:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">p := newPrinter()</span><br><span class="line">p.wrapErrs = <span class="literal">true</span></span><br><span class="line">p.doPrintf(format, a)</span><br><span class="line">s := <span class="keyword">string</span>(p.buf)</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> p.wrappedErr == <span class="literal">nil</span> &#123;</span><br><span class="line">err = errors.New(s)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">err = &amp;wrapError&#123;s, p.wrappedErr&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.free()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>var err error</code>之前的语句看不懂没关系, 我简单的说一下:创建了一个pp结构体指针,然后设置了wrapErrs为true,并调用doPrintf方法将我们的格式化输入转化成对应字符串,此时还存在p的缓冲区中,然后通过string进行类型转化将得到的字符串村进变量s.关键看那个判断语句,这说明,Errorf函数生成错误有两种方式,要么调用errors.New要么返回一个wrapError类型实例.errors.New已经介绍过,下面看看wrapError结构体:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> wrapError <span class="keyword">struct</span> &#123;</span><br><span class="line">msg <span class="keyword">string</span></span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *wrapError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.msg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信大家都能明白了吧</p><p>举个fmt.Errorf的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := fmt.Errorf(<span class="string">&quot;error error error&quot;</span>)</span><br><span class="line">fmt.Println(err) <span class="comment">// error error error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="番外篇-String-和-Error"><a href="#番外篇-String-和-Error" class="headerlink" title="番外篇 String() 和 Error()"></a>番外篇 String() 和 Error()</h1><p>在golang中如果直接打印一个普通对象,得到的结果就会向下面一样,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">p := &amp;People&#123;</span><br><span class="line">name: <span class="string">&quot;horika&quot;</span>,</span><br><span class="line">age:  <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(p) <span class="comment">// &amp;&#123;horika 10&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, p) <span class="comment">// &amp;&#123;horika %!s(int=10)&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许有时候我们需要在打印或者转换成字符串时想要让他输出自定义的一句话,这时我们可以给这个结构体增加一个<code>String</code>方法,如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;我叫%s, 我今年%d岁&quot;</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">p := &amp;People&#123;</span><br><span class="line">name: <span class="string">&quot;horika&quot;</span>,</span><br><span class="line">age:  <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(p)<span class="comment">// 我叫horika, 我今年10岁</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, p) <span class="comment">// 我叫horika, 我今年10岁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>!!!</strong> 注意如果我们定义的String方法是指针调用的那么我们必须打印指针对象才有效果,也就是你定义什么类型,就打印什么类型,同学们可以自己去尝试.</p><p>如果我们的结构体定义了一个<code>Error</code>方法,那么打印的时候会优先调用<code>Error</code>方法,如下</p><p><code>只定义Error方法的例子</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;[Error] 我叫%s, 我今年%d岁&quot;</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">p := &amp;People&#123;</span><br><span class="line">name: <span class="string">&quot;horika&quot;</span>,</span><br><span class="line">age:  <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(p)<span class="comment">// [Error] 我叫horika, 我今年10岁</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, p) <span class="comment">// [Error] 我叫horika, 我今年10岁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>即有String方法也有Error方法</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;[String] 我叫%s, 我今年%d岁&quot;</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;[Error] 我叫%s, 我今年%d岁&quot;</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">p := &amp;People&#123;</span><br><span class="line">name: <span class="string">&quot;horika&quot;</span>,</span><br><span class="line">age:  <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(p)<span class="comment">// [Error] 我叫horika, 我今年10岁</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, p) <span class="comment">// [Error] 我叫horika, 我今年10岁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果Error和String方法同时存在,Error方法会覆盖String方法,</p><p>看到这里我想你们就应该明白为什么我们之前打印一个error时只需要打印它本身而不用打印err.Error()了吧</p><h1 id="定义自己的错误"><a href="#定义自己的错误" class="headerlink" title="定义自己的错误"></a>定义自己的错误</h1><p>看了前面的介绍我相信大家都能自己写一个错误类型,无非分两步,1. 定义一个结构体,2. 该结构体实现 <code>Error() string</code>方法.然而事实真的就是这么简单.其实在前面的番外篇里已经有了自定义错误的影子</p><p>举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyIntNegativeError <span class="keyword">struct</span> &#123;</span><br><span class="line">msg <span class="keyword">string</span></span><br><span class="line">val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyIntNegativeError)</span><span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;[ERROR] reason %s; val: %d&quot;</span>, m.msg, m.val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyIntNegativeError</span><span class="params">(msg <span class="keyword">string</span>, val <span class="keyword">int</span>)</span> *<span class="title">MyIntNegativeError</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyIntNegativeError&#123;</span><br><span class="line">msg: msg,</span><br><span class="line">val: val,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sub10</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span>&#123;</span><br><span class="line">ret := a - <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ret &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, NewMyIntNegativeError(<span class="string">&quot;a必须大于10&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">a := <span class="number">9</span></span><br><span class="line"></span><br><span class="line">ret, err := Sub10(a)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;出错啦&quot;</span>, err)<span class="comment">// 出错啦 [ERROR] reason a必须大于10; val: 9</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了必须实现<code>Error</code>方法外,我一般习惯给自定义的错误实现一个构造函数.</p><h1 id="panic和recover"><a href="#panic和recover" class="headerlink" title="panic和recover"></a>panic和recover</h1><h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><p>panic是一个内建函数,他会产生一个严重的错误使程序中断执行,举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">0</span>&#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;出现数字3的倍数,我不想继续了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">panic: 出现数字3的倍数,我不想继续了</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">        &#x2F;home&#x2F;kain&#x2F;Documents&#x2F;code&#x2F;go_module&#x2F;file_io&#x2F;main.go:9 +0xf5</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2><p>recover可以捕获一个panic使程序恢复运行,当然你也可以再次抛出异常,通常我们都是在defer语句中执行recover,这很容易理解,因为我们必须等所有程序都执行完才能保证整个过程不会发生panic,举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">f1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">pan := <span class="built_in">recover</span>()</span><br><span class="line"><span class="keyword">if</span> pan != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我已经捕获了错误,错误是:&quot;</span>, pan)</span><br><span class="line">fmt.Printf(<span class="string">&quot;错误类型是%T\n&quot;</span>, pan)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;没有错误&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">0</span>&#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;出现数字3的倍数,我不想继续了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">我已经捕获了错误,错误是: 出现数字3的倍数,我不想继续了</span><br><span class="line">错误类型是string</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从源码解读golang文件操作</title>
      <link href="/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h1><h2 id="FileInfo接口"><a href="#FileInfo接口" class="headerlink" title="FileInfo接口"></a>FileInfo接口</h2><p>在<code>os</code>包中有一个<code>FileInfo</code>接口它包含了一个文件的基本信息,如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A FileInfo describes a file and is returned by Stat and Lstat.</span></span><br><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() <span class="keyword">string</span>       <span class="comment">// base name of the file</span></span><br><span class="line">Size() <span class="keyword">int64</span>        <span class="comment">// length in bytes for regular files; system-dependent for others</span></span><br><span class="line">Mode() FileMode     <span class="comment">// file mode bits</span></span><br><span class="line">ModTime() time.Time <span class="comment">// modification time</span></span><br><span class="line">IsDir() <span class="keyword">bool</span>        <span class="comment">// abbreviation for Mode().IsDir()</span></span><br><span class="line">Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// underlying data source (can return nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面描述可以看到FileInfo描述一个文件并且被Stat和Lstat方法返回</p><p>从<code>os</code>包中可以看到这两个函数的定义,记住里面的两个函数<code>statNolog</code>和<code>lstatNolog</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stat returns a FileInfo describing the named file.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(FileInfo, error)</span></span> &#123;</span><br><span class="line">testlog.Stat(name)</span><br><span class="line"><span class="keyword">return</span> statNolog(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lstat returns a FileInfo describing the named file.</span></span><br><span class="line"><span class="comment">// If the file is a symbolic link, the returned FileInfo</span></span><br><span class="line"><span class="comment">// describes the symbolic link. Lstat makes no attempt to follow the link.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lstat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(FileInfo, error)</span></span> &#123;</span><br><span class="line">testlog.Stat(name)</span><br><span class="line"><span class="keyword">return</span> lstatNolog(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fileStat结构体"><a href="#fileStat结构体" class="headerlink" title="fileStat结构体"></a>fileStat结构体</h2><p>同样在os包中定义了<code>fileState</code>结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A fileStat is the implementation of FileInfo returned by Stat and Lstat.</span></span><br><span class="line"><span class="keyword">type</span> fileStat <span class="keyword">struct</span> &#123;</span><br><span class="line">name    <span class="keyword">string</span></span><br><span class="line">size    <span class="keyword">int64</span></span><br><span class="line">mode    FileMode</span><br><span class="line">modTime time.Time</span><br><span class="line">sys     syscall.Stat_t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>types_unix.go</code>文件中定义了如下方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int64</span></span>        &#123; <span class="keyword">return</span> fs.size &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">Mode</span><span class="params">()</span> <span class="title">FileMode</span></span>     &#123; <span class="keyword">return</span> fs.mode &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">ModTime</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123; <span class="keyword">return</span> fs.modTime &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">Sys</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;   &#123; <span class="keyword">return</span> &amp;fs.sys &#125;</span><br></pre></td></tr></table></figure><p>在<code>types.go</code>中还定义以下两个方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> fs.name &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">IsDir</span><span class="params">()</span> <span class="title">bool</span></span>  &#123; <span class="keyword">return</span> fs.Mode().IsDir() &#125;</span><br></pre></td></tr></table></figure><p>可以看到这个结构体刚好实现了<code>FileInfo</code>接口</p><p>实际上,进入<code>statNolog</code>和<code>lstatNolog</code>可知,<code>Stat</code>和<code>Lsate</code>函数就是返回了指向<code>fileStat</code>的指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// statNolog stats a file with no test logging.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">statNolog</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(FileInfo, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> fs fileStat</span><br><span class="line">err := syscall.Stat(name, &amp;fs.sys)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;PathError&#123;<span class="string">&quot;stat&quot;</span>, name, err&#125;</span><br><span class="line">&#125;</span><br><span class="line">fillFileStatFromSys(&amp;fs, name)</span><br><span class="line"><span class="keyword">return</span> &amp;fs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lstatNolog lstats a file with no test logging.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lstatNolog</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(FileInfo, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> fs fileStat</span><br><span class="line">err := syscall.Lstat(name, &amp;fs.sys)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;PathError&#123;<span class="string">&quot;lstat&quot;</span>, name, err&#125;</span><br><span class="line">&#125;</span><br><span class="line">fillFileStatFromSys(&amp;fs, name)</span><br><span class="line"><span class="keyword">return</span> &amp;fs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以本质上就是利用<code>fileStat</code>结构体存放文件相关信息,并做操作</p><h2 id="查看文件信息"><a href="#查看文件信息" class="headerlink" title="查看文件信息"></a>查看文件信息</h2><p>介绍了这么多,写一个golang读取文件信息的例子,(当前目录下的go.mod文件)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fileInfo, err := os.Stat(<span class="string">&quot;go.mod&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;读取文件出错&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;文件名:&quot;</span>, fileInfo.Name())</span><br><span class="line">fmt.Println(<span class="string">&quot;文件大小:&quot;</span>, fileInfo.Size())</span><br><span class="line">fmt.Println(<span class="string">&quot;文件权限:&quot;</span>, fileInfo.Mode())</span><br><span class="line">fmt.Println(<span class="string">&quot;文件修改时间:&quot;</span>, fileInfo.ModTime())</span><br><span class="line">fmt.Println(<span class="string">&quot;文件是否是目录:&quot;</span>, fileInfo.IsDir())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件名: go.mod</span><br><span class="line">文件大小: 24</span><br><span class="line">文件权限: -rw-r--r--</span><br><span class="line">文件修改时间: 2020-06-16 09:04:23.418186928 +0800 CST</span><br><span class="line">文件是否是目录: false</span><br></pre></td></tr></table></figure><p>其实上面方法就是对应<code>FileInfo</code>接口中的方法，但是少了一个<code>Sys</code>方法，通过这个方法你可以获得更加详细的信息，这个比较特殊，如果你直接打印会得到类似如下的输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(fileInfo.Sys())</span><br><span class="line"><span class="comment">// &amp;&#123;2064 23337987 1 33188 1000 1000 0 0 24 4096 8 &#123;1592269464 801520234&#125; &#123;1592269463 418186928&#125; &#123;1592269463 418186928&#125; [0 0 0]&#125;</span></span><br></pre></td></tr></table></figure><p>其实<code>Sys</code>方法就是返回了<code>fileStat</code>的<code>sys</code>属性,上面我们已经看过<code>fileStat</code>的定义,可以发现<code>sys</code>属性就是一个<code>syscall.Stat_t</code>类型</p><p>这是<code>Stat_t</code>的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stat_t <span class="keyword">struct</span> &#123;</span><br><span class="line">Dev       <span class="keyword">uint64</span></span><br><span class="line">Ino       <span class="keyword">uint64</span></span><br><span class="line">Nlink     <span class="keyword">uint64</span></span><br><span class="line">Mode      <span class="keyword">uint32</span></span><br><span class="line">Uid       <span class="keyword">uint32</span></span><br><span class="line">Gid       <span class="keyword">uint32</span></span><br><span class="line">X__pad0   <span class="keyword">int32</span></span><br><span class="line">Rdev      <span class="keyword">uint64</span></span><br><span class="line">Size      <span class="keyword">int64</span></span><br><span class="line">Blksize   <span class="keyword">int64</span></span><br><span class="line">Blocks    <span class="keyword">int64</span></span><br><span class="line">Atim      Timespec</span><br><span class="line">Mtim      Timespec</span><br><span class="line">Ctim      Timespec</span><br><span class="line">X__unused [<span class="number">3</span>]<span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过反射来获取上述属性的信息,以获取 Ctim 为例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fileInfo, err := os.Stat(<span class="string">&quot;go.mod&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;读取文件出错&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ctim := reflect.ValueOf(fileInfo.Sys()).Elem().FieldByName(<span class="string">&quot;Ctim&quot;</span>).Field(<span class="number">0</span>)</span><br><span class="line">fmt.Println(Ctim) <span class="comment">// 1592269463</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>也许有人会奇怪,为什么<code>fileStat</code>结构体里没有文件路径相关信息,其实者不难理解,我们既然能够打开一个文件,前提就是我们知道这个文件放在哪里.而我接下来要做的操作知识针对文件路径,而不是文件本身.</p><p>针对路径golang中有一个专门的包<code>path</code></p><p>常用方法如下</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>filepath.IsAbs()</td><td>判断是否为绝对路径</td></tr><tr><td>filepath.Rel()</td><td>获取相对路径</td></tr><tr><td>filepath.Abs()</td><td>获取绝对路径</td></tr><tr><td>path.Join()</td><td>拼接路径</td></tr></tbody></table><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;path&quot;</span></span><br><span class="line"><span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">path1 := <span class="string">&quot;/home/kain/Documents/code/go_module/file_io/main.go&quot;</span></span><br><span class="line">path2 := <span class="string">&quot;./go.mod&quot;</span></span><br><span class="line">path3 := <span class="string">&quot;go.mod&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(filepath.IsAbs(path1))<span class="comment">// true</span></span><br><span class="line">fmt.Println(filepath.IsAbs(path2))  <span class="comment">// false</span></span><br><span class="line">fmt.Println(filepath.IsAbs(path3))  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">fmt.Println(filepath.Rel(<span class="string">&quot;/home/kain&quot;</span>, path1))  <span class="comment">// Documents/code/go_module/file_io/main.go &lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(filepath.Abs(path1))<span class="comment">// /home/kain/Documents/code/go_module/file_io/main.go &lt;nil&gt;</span></span><br><span class="line">fmt.Println(filepath.Abs(path2))    <span class="comment">// /home/kain/Documents/code/go_module/file_io/go.mod &lt;nil&gt;</span></span><br><span class="line">fmt.Println(filepath.Abs(path3))    <span class="comment">// /home/kain/Documents/code/go_module/file_io/go.mod &lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(path.Join(path1, <span class="string">&quot;.&quot;</span>))  <span class="comment">// /home/kain/Documents/code/go_module/file_io/main.go</span></span><br><span class="line">fmt.Println(path.Join(path1, <span class="string">&quot;..&quot;</span>)) <span class="comment">// /home/kain/Documents/code/go_module/file_io</span></span><br><span class="line">fmt.Println(path.Join(<span class="string">&quot;/home&quot;</span>, path2)) <span class="comment">// /home/go.mod</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件创建删除（目录）"><a href="#文件创建删除（目录）" class="headerlink" title="文件创建删除（目录）"></a>文件创建删除（目录）</h1><h2 id="检查文件是否存在"><a href="#检查文件是否存在" class="headerlink" title="检查文件是否存在"></a>检查文件是否存在</h2><p>golang中通过<code>Stat</code>返回的错误,然后调用<code>IsExist</code>或<code>IsNotExist</code>来判断是否存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(PathExist(<span class="string">&quot;test.txt&quot;</span>))    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">println</span>(PathExist(<span class="string">&quot;go.mod&quot;</span>))       <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PathExist</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">_, err := os.Stat(path)</span><br><span class="line"><span class="keyword">return</span> os.IsNotExist(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><h3 id="os-MKdir"><a href="#os-MKdir" class="headerlink" title="os.MKdir()"></a>os.MKdir()</h3><p>该函数用于创建一层目录,定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mkdir creates a new directory with the specified name and permission</span></span><br><span class="line"><span class="comment">// bits (before umask).</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mkdir</span><span class="params">(name <span class="keyword">string</span>, perm FileMode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> runtime.GOOS == <span class="string">&quot;windows&quot;</span> &amp;&amp; isWindowsNulName(name) &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;PathError&#123;<span class="string">&quot;mkdir&quot;</span>, name, syscall.ENOTDIR&#125;</span><br><span class="line">&#125;</span><br><span class="line">e := syscall.Mkdir(fixLongPath(name), syscallMode(perm))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;PathError&#123;<span class="string">&quot;mkdir&quot;</span>, name, e&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mkdir(2) itself won&#x27;t handle the sticky bit on *BSD and Solaris</span></span><br><span class="line"><span class="keyword">if</span> !supportsCreateWithStickyBit &amp;&amp; perm&amp;ModeSticky != <span class="number">0</span> &#123;</span><br><span class="line">e = setStickyBit(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">Remove(name)</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := os.MKdir(<span class="string">&quot;demo&quot;</span>, <span class="number">0777</span>)</span><br></pre></td></tr></table></figure><h3 id="os-MKdirAll"><a href="#os-MKdirAll" class="headerlink" title="os.MKdirAll()"></a>os.MKdirAll()</h3><p>该函数用于创建多层目录,定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MkdirAll</span><span class="params">(path <span class="keyword">string</span>, perm FileMode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Fast path: if we can tell whether path is a directory or file, stop with success or error.</span></span><br><span class="line">dir, err := Stat(path)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> dir.IsDir() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;PathError&#123;<span class="string">&quot;mkdir&quot;</span>, path, syscall.ENOTDIR&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Slow path: make sure parent exists and then call Mkdir for path.</span></span><br><span class="line">i := <span class="built_in">len</span>(path)</span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">0</span> &amp;&amp; IsPathSeparator(path[i<span class="number">-1</span>]) &#123; <span class="comment">// Skip trailing path separator.</span></span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">j := i</span><br><span class="line"><span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; !IsPathSeparator(path[j<span class="number">-1</span>]) &#123; <span class="comment">// Scan backward over element.</span></span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> j &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// Create parent.</span></span><br><span class="line">err = MkdirAll(fixRootDirectory(path[:j<span class="number">-1</span>]), perm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parent now exists; invoke Mkdir and use its result.</span></span><br><span class="line">err = Mkdir(path, perm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Handle arguments like &quot;foo/.&quot; by</span></span><br><span class="line"><span class="comment">// double-checking that directory doesn&#x27;t exist.</span></span><br><span class="line">dir, err1 := Lstat(path)</span><br><span class="line"><span class="keyword">if</span> err1 == <span class="literal">nil</span> &amp;&amp; dir.IsDir() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := os.MkdirAll(<span class="string">&quot;dir1/dir2/dir3&quot;</span>, os.ModePerm) <span class="comment">// os.ModePerm = 0777</span></span><br></pre></td></tr></table></figure><p>##　创建文件</p><h3 id="os-Creat"><a href="#os-Creat" class="headerlink" title="os.Creat()"></a>os.Creat()</h3><p>用该方法创建文本文件，如果文件已经存在，会将其覆盖，定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，他就是通过打开文件的方式来创建文件，通过 <code>O_TRUNC</code>标志，来覆盖原文件．</p><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Create(<span class="string">&quot;test.txt&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="删除文件（目录）"><a href="#删除文件（目录）" class="headerlink" title="删除文件（目录）"></a>删除文件（目录）</h2><h3 id="os-Remove"><a href="#os-Remove" class="headerlink" title="os.Remove()"></a>os.Remove()</h3><p>该方法用于删除文件或者空目录,定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// System call interface forces us to know</span></span><br><span class="line"><span class="comment">// whether name is a file or directory.</span></span><br><span class="line"><span class="comment">// Try both: it is cheaper on average than</span></span><br><span class="line"><span class="comment">// doing a Stat plus the right one.</span></span><br><span class="line">e := syscall.Unlink(name)</span><br><span class="line"><span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">e1 := syscall.Rmdir(name)</span><br><span class="line"><span class="keyword">if</span> e1 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Both failed: figure out which error to return.</span></span><br><span class="line"><span class="comment">// OS X and Linux differ on whether unlink(dir)</span></span><br><span class="line"><span class="comment">// returns EISDIR, so can&#x27;t use that. However,</span></span><br><span class="line"><span class="comment">// both agree that rmdir(file) returns ENOTDIR,</span></span><br><span class="line"><span class="comment">// so we can use that to decide which error is real.</span></span><br><span class="line"><span class="comment">// Rmdir might also return ENOTDIR if given a bad</span></span><br><span class="line"><span class="comment">// file path, like /etc/passwd/foo, but in that case,</span></span><br><span class="line"><span class="comment">// both errors will be ENOTDIR, so it&#x27;s okay to</span></span><br><span class="line"><span class="comment">// use the error from unlink.</span></span><br><span class="line"><span class="keyword">if</span> e1 != syscall.ENOTDIR &#123;</span><br><span class="line">e = e1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;PathError&#123;<span class="string">&quot;remove&quot;</span>, name, e&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := os.Remove(<span class="string">&quot;demo&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="os-RemoveAll"><a href="#os-RemoveAll" class="headerlink" title="os.RemoveAll()"></a>os.RemoveAll()</h3><p>该方法用于删除目录下面所有子节点,定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RemoveAll removes path and any children it contains.</span></span><br><span class="line"><span class="comment">// It removes everything it can but returns the first error</span></span><br><span class="line"><span class="comment">// it encounters. If the path does not exist, RemoveAll</span></span><br><span class="line"><span class="comment">// returns nil (no error).</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveAll</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> removeAll(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeAll()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeAll</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> path == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="comment">// fail silently to retain compatibility with previous behavior</span></span><br><span class="line"><span class="comment">// of RemoveAll. See issue 28830.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The rmdir system call does not permit removing &quot;.&quot;,</span></span><br><span class="line"><span class="comment">// so we don&#x27;t permit it either.</span></span><br><span class="line"><span class="keyword">if</span> endsWithDot(path) &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;PathError&#123;<span class="string">&quot;RemoveAll&quot;</span>, path, syscall.EINVAL&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple case: if Remove works, we&#x27;re done.</span></span><br><span class="line">err := Remove(path)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> || IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RemoveAll recurses by deleting the path base from</span></span><br><span class="line"><span class="comment">// its parent directory</span></span><br><span class="line">parentDir, base := splitPath(path)</span><br><span class="line"></span><br><span class="line">parent, err := Open(parentDir)</span><br><span class="line"><span class="keyword">if</span> IsNotExist(err) &#123;</span><br><span class="line"><span class="comment">// If parent does not exist, base cannot exist. Fail silently</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> parent.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := removeAllFrom(parent, base); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> pathErr, ok := err.(*PathError); ok &#123;</span><br><span class="line">pathErr.Path = parentDir + <span class="keyword">string</span>(PathSeparator) + pathErr.Path</span><br><span class="line">err = pathErr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := os.RemoveAll(<span class="string">&quot;dir1&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><p>对文件进行读写操作肯定要先打开文件</p><h2 id="打开关闭文件"><a href="#打开关闭文件" class="headerlink" title="打开关闭文件"></a>打开关闭文件</h2><h3 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h3><p>前面在创建文件时我们已经了解过了文件的打开,使用函数<code>os.OpenFile()</code>来实现,定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenFile is the generalized open call; most users will use Open</span></span><br><span class="line"><span class="comment">// or Create instead. It opens the named file with specified flag</span></span><br><span class="line"><span class="comment">// (O_RDONLY etc.). If the file does not exist, and the O_CREATE flag</span></span><br><span class="line"><span class="comment">// is passed, it is created with mode perm (before umask). If successful,</span></span><br><span class="line"><span class="comment">// methods on the returned File can be used for I/O.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line">   testlog.Open(name)</span><br><span class="line">   f, err := openFileNolog(name, flag, perm)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   f.appendMode = flag&amp;O_APPEND != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的内部是调用<code>openFileNolog</code>函数来实现,有兴趣的同学可以去了解一下</p><p>它接收的三个参数分别是文件路径,标志和权限,</p><p>标志就是打开方式,可以一种或多种,golang中的标志如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flags to OpenFile wrapping those of the underlying system. Not all</span></span><br><span class="line"><span class="comment">// flags may be implemented on a given system.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.</span></span><br><span class="line">O_RDONLY <span class="keyword">int</span> = syscall.O_RDONLY <span class="comment">// open the file read-only.</span></span><br><span class="line">O_WRONLY <span class="keyword">int</span> = syscall.O_WRONLY <span class="comment">// open the file write-only.</span></span><br><span class="line">O_RDWR   <span class="keyword">int</span> = syscall.O_RDWR   <span class="comment">// open the file read-write.</span></span><br><span class="line"><span class="comment">// The remaining values may be or&#x27;ed in to control behavior.</span></span><br><span class="line">O_APPEND <span class="keyword">int</span> = syscall.O_APPEND <span class="comment">// append data to the file when writing.</span></span><br><span class="line">O_CREATE <span class="keyword">int</span> = syscall.O_CREAT  <span class="comment">// create a new file if none exists.</span></span><br><span class="line">O_EXCL   <span class="keyword">int</span> = syscall.O_EXCL   <span class="comment">// used with O_CREATE, file must not exist.</span></span><br><span class="line">O_SYNC   <span class="keyword">int</span> = syscall.O_SYNC   <span class="comment">// open for synchronous I/O.</span></span><br><span class="line">O_TRUNC  <span class="keyword">int</span> = syscall.O_TRUNC  <span class="comment">// truncate regular writable file when opened.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>权限只在文件不存在时创建文件需要,如果只是普通打开文件,权限填0即可,再如果知识简单得到只读一个已存在的文件,可以使用<code>os.Open()</code>函数来实现,这是它的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open opens the named file for reading. If successful, methods on</span></span><br><span class="line"><span class="comment">// the returned file can be used for reading; the associated file</span></span><br><span class="line"><span class="comment">// descriptor has mode O_RDONLY.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> OpenFile(name, O_RDONLY, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道你们有没有发现,上述介绍的几个函数的第一个返回值是<code>os.File</code>类型的指针,这究竟是什么呢?</p><p>让我们来看看它的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File represents an open file descriptor.</span></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">*file <span class="comment">// os specific</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它又指向了<code>file</code>类型指针,那就看看这个<code>file</code>吧</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file is the real representation of *File.</span></span><br><span class="line"><span class="comment">// The extra level of indirection ensures that no clients of os</span></span><br><span class="line"><span class="comment">// can overwrite this data, which could cause the finalizer</span></span><br><span class="line"><span class="comment">// to close the wrong file descriptor.</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">pfd         poll.FD</span><br><span class="line">name        <span class="keyword">string</span></span><br><span class="line">dirinfo     *dirInfo <span class="comment">// nil unless directory being read</span></span><br><span class="line">nonblock    <span class="keyword">bool</span>     <span class="comment">// whether we set nonblocking mode</span></span><br><span class="line">stdoutOrErr <span class="keyword">bool</span>     <span class="comment">// whether this is stdout or stderr</span></span><br><span class="line">appendMode  <span class="keyword">bool</span>     <span class="comment">// whether file is opened for appending</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那个<code>FD</code>是文件描述符(file descriptor),有兴趣的同学可以展开看看<code>file</code>结构体的内部</p><p>下面我们来看看<code>File</code>结构体都支持哪些操作(这些方法可以在<code>file.go, stat_unix.go, file_unix.g, file_posix.go, dir.go</code>中找到)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">f.Fd()</span><br><span class="line">f.Stat()</span><br><span class="line">f.Name()</span><br><span class="line">f.Close()</span><br><span class="line">f.Write()</span><br><span class="line">f.Chdir()</span><br><span class="line">f.Chmod()</span><br><span class="line">f.Chown()</span><br><span class="line">f.Read()</span><br><span class="line">f.ReadAt()</span><br><span class="line">f.Readdir()</span><br><span class="line">f.Readdirnames()</span><br><span class="line">f.Seek()</span><br><span class="line">f.SetDeadline()</span><br><span class="line">f.SetReadDeadline()</span><br><span class="line">f.Sync()</span><br><span class="line">f.SyscallConn()</span><br><span class="line">f.Truncate()</span><br><span class="line">f.WriteAt()</span><br><span class="line">f.WriteString()</span><br></pre></td></tr></table></figure><p>虽然方法很多,但是常用的也就几个,无非是读写和关闭.下面我将介绍几个常用的函数,其余的你们有兴趣就去了解吧</p><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p><code>f.Close()</code>关闭一个打开的文件,方法定义如下,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ErrInvalid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f.file.<span class="built_in">close</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>f.file.close()</code>来关闭文件,这里就不深入了</p><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p><code>f.Read()</code>读取文件内容,方法定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read reads up to len(b) bytes from the File.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes read and any error encountered.</span></span><br><span class="line"><span class="comment">// At end of file, Read returns 0, io.EOF.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := f.checkValid(<span class="string">&quot;read&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line">n, e := f.read(b)</span><br><span class="line"><span class="keyword">return</span> n, f.wrapErr(<span class="string">&quot;read&quot;</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>n代表实际读取的字节数,其本质是调用read函数来实现读取,继续深入发现 <code>read</code>函数调用了<code>f.pfd.Read()</code>,该函数最后调用了<code>fd.eofError()</code>方法,在该方法内部,如果读取到最末尾,返回<code>io.EOF</code>错误.</p><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f *os.File</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span><span class="comment">// 存放读取字节数</span></span><br><span class="line"><span class="comment">// 初始化一个切片用于存放读取的数据</span></span><br><span class="line">bs := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">8</span>, <span class="number">1024</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">f,err = os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;文件打开失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意关闭文件</span></span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err = f.Read(bs)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> || err == io.EOF&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;文件读取结束&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bs[:n]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><h3 id="f-Write"><a href="#f-Write" class="headerlink" title="f.Write()"></a>f.Write()</h3><p>该方法用字节切片的方式写入文件,定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write writes len(b) bytes to the File.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes written and an error, if any.</span></span><br><span class="line"><span class="comment">// Write returns a non-nil error when n != len(b).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := f.checkValid(<span class="string">&quot;write&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line">n, e := f.write(b)</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n != <span class="built_in">len</span>(b) &#123;</span><br><span class="line">err = io.ErrShortWrite</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">epipecheck(f, e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">err = f.wrapErr(<span class="string">&quot;write&quot;</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f *os.File</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span><span class="comment">// 存放写入字节数</span></span><br><span class="line"></span><br><span class="line">f, err = os.OpenFile(<span class="string">&quot;test.txt&quot;</span>, os.O_RDWR|os.O_CREATE|os.O_APPEND, os.ModePerm)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;文件打开失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 别忘了关闭文件</span></span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">n, err = f.Write([]<span class="keyword">byte</span>(<span class="string">&quot;123abc你好&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;写入文件失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;成功写入%d个字节\n&quot;</span>, n)　<span class="comment">// 一个汉字3个字节</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意, 写文件就不能通过<code>Open</code>函数来打开了,<code>Open</code>函数是只读的</p><p>利用标志<code>os.O_CREATE</code>,会在文件不存在时创建</p><p>利用标志<code>os.O_APPEND</code>,表示追加写入</p><h3 id="f-WriteString"><a href="#f-WriteString" class="headerlink" title="f.WriteString()"></a>f.WriteString()</h3><p>该方法用字符串的方式写入文件,定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteString is like Write, but writes the contents of string s rather than</span></span><br><span class="line"><span class="comment">// a slice of bytes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> f.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到他的本质就是给你转换成字节切片,这个示例我就不演示了,相信大家都能看懂</p><p>留个思考题:<em>请大家阅读相关源码并说明<code>os.fileState</code>和<code>os.file</code>这两个结构体有何不同,各自的使用场景又是什么?</em></p><p> 有答案的可以在评论区留言</p><p><strong>如果你看到这里你应该知道了如何使用golang来实现文件的相关操作,但是你们肯定和我一样,觉得golang的文件读写操作很麻烦.下面我们来了解一下文件操作的另外两种方法 <code>ioutil</code>和<code>bufio</code></strong>,下面内容部分参考了GO语言中文文档,但文档中的有些内容已经过时,我已经将它更新.</p><h1 id="ioutil"><a href="#ioutil" class="headerlink" title="ioutil"></a>ioutil</h1><p>正如其名字ioutil这是一个读写操作包,这里举例一些常用的方法</p><ul><li><p><code>func ReadFile(filename string) ([]byte, error)</code></p><p>ReadFile 从filename指定的文件中读取数据并返回文件的内容。成功的调用返回的err为nil而非EOF。因为本函数定义为读取整个文件，它不会将读取返回的EOF视为应报告的错误。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">f, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="comment">// It&#x27;s a good but not certain bet that FileInfo will tell us exactly how much to</span></span><br><span class="line"><span class="comment">// read, so let&#x27;s try it but be prepared for the answer to be wrong.</span></span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int64</span> = bytes.MinRead</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fi, err := f.Stat(); err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// As initial capacity for readAll, use Size + a little extra in case Size</span></span><br><span class="line"><span class="comment">// is zero, and to avoid another allocation after Read has filled the</span></span><br><span class="line"><span class="comment">// buffer. The readAll call will read into its allocated internal buffer</span></span><br><span class="line"><span class="comment">// cheaply. If the size was wrong, we&#x27;ll either waste some space off the end</span></span><br><span class="line"><span class="comment">// or reallocate as needed, but in the overwhelmingly common case we&#x27;ll get</span></span><br><span class="line"><span class="comment">// it just right.</span></span><br><span class="line"><span class="keyword">if</span> size := fi.Size() + bytes.MinRead; size &gt; n &#123;</span><br><span class="line">n = size</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> readAll(f, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出,ReadFile函数本质也是利用os.File结构体,并调用<code>readAll</code>函数处理,这里就不深入了,感兴趣的同学可以去看看,</p><p>例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">bs, err := ioutil.ReadFile(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;文件打开出错&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="keyword">string</span>(bs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>func WriteFile(filename string, data []byte, perm os.FileMode) error</code></p><p>函数向filename指定的文件中写入数据。如果文件不存在将按给出的权限创建文件，否则在写入数据之前清空文件。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteFile writes data to a file named by filename.</span></span><br><span class="line"><span class="comment">// If the file does not exist, WriteFile creates it with permissions perm</span></span><br><span class="line"><span class="comment">// (before umask); otherwise WriteFile truncates it before writing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="keyword">string</span>, data []<span class="keyword">byte</span>, perm os.FileMode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">f, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = f.Write(data)</span><br><span class="line"><span class="keyword">if</span> err1 := f.Close(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">err = err1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你没看错这就是这个函数的源码,是不是非常眼熟,这和我们之前写的代码十分相似.</p><p>例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := ioutil.WriteFile(<span class="string">&quot;hello.txt&quot;</span>, []<span class="keyword">byte</span>(<span class="string">&quot;hello世界&quot;</span>),os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;文件打开失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>func ReadDir(dirname string) ([]os.FileInfo, error)</code></p><p>返回dirname指定的目录的目录信息的有序列表。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadDir reads the directory named by dirname and returns</span></span><br><span class="line"><span class="comment">// a list of directory entries sorted by filename.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadDir</span><span class="params">(dirname <span class="keyword">string</span>)</span> <span class="params">([]os.FileInfo, error)</span></span> &#123;</span><br><span class="line">f, err := os.Open(dirname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">list, err := f.Readdir(<span class="number">-1</span>)</span><br><span class="line">f.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">sort.Slice(list, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> list[i].Name() &lt; list[j].Name() &#125;)</span><br><span class="line"><span class="keyword">return</span> list, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的底层也是利用<code>os.File</code>结构体,然后调用os.File的Readdir方法,并对结构进行排序输出</p><p>例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fs, err := ioutil.ReadDir(<span class="string">&quot;dir1&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;文件打开失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> fs&#123;</span><br><span class="line">fmt.Println(i, v.Name(), v.IsDir(), v.Size(), v.ModTime())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>func ReadAll(r io.Reader) ([]byte, error)</code></p><p>ReadAll读取数据直到EOF或遇到error，返回读取的数据和遇到的错误。成功的调用返回的err为nil而非EOF。因为本函数定义为读取r直到EOF，它不会将读取返回的EOF视为应报告的错误。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadAll reads from r until an error or EOF and returns the data it read.</span></span><br><span class="line"><span class="comment">// A successful call returns err == nil, not err == EOF. Because ReadAll is</span></span><br><span class="line"><span class="comment">// defined to read from src until EOF, it does not treat an EOF from Read</span></span><br><span class="line"><span class="comment">// as an error to be reported.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> readAll(r, bytes.MinRead)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它接收一个参数类型为<code>io.Reader</code>,通过读源码可以看出它就是一个实现了<code>Read</code>函数的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经知道<code>os.File</code>就是实现了<code>Read</code>方法,所以我们可以将一个<code>os.File</code>结构体传进去,</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> bs []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> f *os.File</span><br><span class="line"></span><br><span class="line">f, err = os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;打开文件失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">bs, err = ioutil.ReadAll(f)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;文件读取失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="keyword">string</span>(bs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现<code>ReadFile</code>和<code>ReadAll</code>方法非常的像,只不过<code>ReadFile</code>方法内部对文件进打开操作,而<code>ReadAll</code>是在外面手动打开文件然后传进去</p></li><li><p><code>func TempDir(dir, pattern string) (name string, err error) </code></p><p>在dir目录里创建一个新的临时文件夹(其实本质就是普通文件,用作临时存储场景,需要手动删除),该文件夹的命名规则如下,使用将<code>pattern</code>用<code>*</code>分开,取最后一个做后缀,前面的做前缀,中间拼接随机数字,该操作可在其源码中看到,如下</p></li></ul>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">(dir, pattern <span class="keyword">string</span>)</span> <span class="params">(name <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> dir == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">dir = os.TempDir()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prefix, suffix := prefixAndSuffix(pattern)</span><br><span class="line"></span><br><span class="line">nconflict := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">try := filepath.Join(dir, prefix+nextRandom()+suffix)</span><br><span class="line">err = os.Mkdir(try, <span class="number">0700</span>)</span><br><span class="line"><span class="keyword">if</span> os.IsExist(err) &#123;</span><br><span class="line"><span class="keyword">if</span> nconflict++; nconflict &gt; <span class="number">10</span> &#123;</span><br><span class="line">randmu.Lock()</span><br><span class="line">rand = reseed()</span><br><span class="line">randmu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := os.Stat(dir); os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">name = try</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其中<code>prefixAndSuffix</code>函数定义如下</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prefixAndSuffix</span><span class="params">(pattern <span class="keyword">string</span>)</span> <span class="params">(prefix, suffix <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pos := strings.LastIndex(pattern, <span class="string">&quot;*&quot;</span>); pos != <span class="number">-1</span> &#123;</span><br><span class="line">prefix, suffix = pattern[:pos], pattern[pos+<span class="number">1</span>:]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prefix = pattern</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  举个例子</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name, err := ioutil.TempDir(<span class="string">&quot;dir1&quot;</span>, <span class="string">&quot;kain*huck&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;文件夹创建失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(name) <span class="comment">// dir1/kain037615429huck</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>func TempFile(dir, pattern string) (f *os.File, err error)</code></p><p>在dir目录下创建一个新的临时文件,文件名是通过使用pattern并在末尾添加一个随机字符串生成的。如果pattern包含一个“*”，随机字符串将替换最后一个“*”。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempFile</span><span class="params">(dir, pattern <span class="keyword">string</span>)</span> <span class="params">(f *os.File, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> dir == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">dir = os.TempDir()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prefix, suffix := prefixAndSuffix(pattern)</span><br><span class="line"></span><br><span class="line">nconflict := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">name := filepath.Join(dir, prefix+nextRandom()+suffix)</span><br><span class="line">f, err = os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, <span class="number">0600</span>)</span><br><span class="line"><span class="keyword">if</span> os.IsExist(err) &#123;</span><br><span class="line"><span class="keyword">if</span> nconflict++; nconflict &gt; <span class="number">10</span> &#123;</span><br><span class="line">randmu.Lock()</span><br><span class="line">rand = reseed()</span><br><span class="line">randmu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, err := ioutil.TempFile(<span class="string">&quot;dir1&quot;</span>, <span class="string">&quot;kain*huck&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;文件创建失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(f.Name())<span class="comment">// dir1/kain115329465huck</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bufio"><a href="#bufio" class="headerlink" title="bufio"></a>bufio</h1><p>bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，创建另一个也实现了该接口，且同时还提供了缓冲和一些文本I/O的帮助函数的对象。</p><h2 id="bufio-Reader"><a href="#bufio-Reader" class="headerlink" title="bufio.Reader"></a><code>bufio.Reader</code></h2><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reader implements buffering for an io.Reader object.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">buf          []<span class="keyword">byte</span></span><br><span class="line">rd           io.Reader <span class="comment">// reader provided by the client</span></span><br><span class="line">r, w         <span class="keyword">int</span>       <span class="comment">// buf read and write positions</span></span><br><span class="line">err          error</span><br><span class="line">lastByte     <span class="keyword">int</span> <span class="comment">// last byte read for UnreadByte; -1 means invalid</span></span><br><span class="line">lastRuneSize <span class="keyword">int</span> <span class="comment">// size of last rune read for UnreadRune; -1 means invalid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用方法</p><ul><li><p><code>func NewReader(rd io.Reader) *Reader</code></p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewReader returns a new Reader whose buffer has the default size.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewReaderSize(rd, defaultBufSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NewReader调用<code>NewReaderSize</code>创建一个具有默认大小缓冲的Reader指针</p><p>defauleBufSize</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">defaultBufSize = <span class="number">4096</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><code>func NewReaderSize(rd io.Reader, size int) *Reader</code></p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewReaderSize returns a new Reader whose buffer has at least the specified</span></span><br><span class="line"><span class="comment">// size. If the argument io.Reader is already a Reader with large enough</span></span><br><span class="line"><span class="comment">// size, it returns the underlying Reader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="keyword">int</span>)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line"><span class="comment">// Is it already a Reader?</span></span><br><span class="line">b, ok := rd.(*Reader)</span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; <span class="built_in">len</span>(b.buf) &gt;= size &#123;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> size &lt; minReadBufferSize &#123;</span><br><span class="line">size = minReadBufferSize</span><br><span class="line">&#125;</span><br><span class="line">r := <span class="built_in">new</span>(Reader)</span><br><span class="line">r.reset(<span class="built_in">make</span>([]<span class="keyword">byte</span>, size), rd)</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数就是上述<code>NewReader</code>中被调用的函数,他可以让我们手动的提供缓冲大小,从代码可以看到,所谓缓冲就是一个byte切片,该切片会被赋值给<code>Reader</code>结构体的<code>buf</code>,</p><p>reset</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">reset</span><span class="params">(buf []<span class="keyword">byte</span>, r io.Reader)</span></span> &#123;</span><br><span class="line">*b = Reader&#123;</span><br><span class="line">buf:          buf,</span><br><span class="line">rd:           r,</span><br><span class="line">lastByte:     <span class="number">-1</span>,</span><br><span class="line">lastRuneSize: <span class="number">-1</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>func (b *Reader) Reset(r io.Reader)</code></p><p>Reset丢弃缓冲中的数据，清除任何错误，将b重设为其下层从r读取数据。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reset discards any buffered data, resets all state, and switches</span></span><br><span class="line"><span class="comment">// the buffered reader to read from r.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Reset</span><span class="params">(r io.Reader)</span></span> &#123;</span><br><span class="line">b.reset(b.buf, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部实现非常简单,就是调用函数<code>reset</code>(这个函数在上面已经看过了),将当前的<code>Reader</code>中的<code>rd</code>属性(io.Reader)重新重设为<code>r</code></p></li><li><p><code>func (b *Reader) Buffered() int</code></p><p>Buffered返回缓冲中现有的可读取的字节数。</p><p>定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffered returns the number of bytes that can be read from the current buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> b.w - b.r &#125;</span><br></pre></td></tr></table></figure><p>这个就不解释了</p></li><li><p><code>func (b *Reader) Peek(n int) ([]byte, error)</code></p><p>Peek返回输入流的下n个字节，而不会移动读取位置。返回的[]byte只在下一次调用读取操作前合法。如果Peek返回的切片长度比n小，它也会返会一个错误说明原因。如果n比缓冲尺寸还大，返回的错误将是ErrBufferFull。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Peek</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrNegativeCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.lastByte = <span class="number">-1</span></span><br><span class="line">b.lastRuneSize = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> b.w-b.r &lt; n &amp;&amp; b.w-b.r &lt; <span class="built_in">len</span>(b.buf) &amp;&amp; b.err == <span class="literal">nil</span> &#123;</span><br><span class="line">b.fill() <span class="comment">// b.w-b.r &lt; len(b.buf) =&gt; buffer is not full</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="built_in">len</span>(b.buf) &#123;</span><br><span class="line"><span class="keyword">return</span> b.buf[b.r:b.w], ErrBufferFull</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 &lt;= n &lt;= len(b.buf)</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> avail := b.w - b.r; avail &lt; n &#123;</span><br><span class="line"><span class="comment">// not enough data in buffer</span></span><br><span class="line">n = avail</span><br><span class="line">err = b.readErr()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">err = ErrBufferFull</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b.buf[b.r : b.r+n], err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别看前面这么多,那都是一些特殊情况的判断处理,看最后一句得知其实该函数就是返回了缓冲区的切</p></li><li><p><code>func (b *Reader) Read(p []byte) (n int, err error)</code></p><p>Read读取数据写入p。本方法返回写入p的字节数。本方法一次调用最多会调用下层Reader接口一次Read方法，因此返回值n可能小于len(p)。读取到达结尾时，返回值n将为0而err将为io.EOF。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">n = <span class="built_in">len</span>(p)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> b.Buffered() &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, b.readErr()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b.r == b.w &#123;</span><br><span class="line"><span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, b.readErr()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= <span class="built_in">len</span>(b.buf) &#123;</span><br><span class="line"><span class="comment">// Large read, empty buffer.</span></span><br><span class="line"><span class="comment">// Read directly into p to avoid copy.</span></span><br><span class="line">n, b.err = b.rd.Read(p)</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(errNegativeRead)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">b.lastByte = <span class="keyword">int</span>(p[n<span class="number">-1</span>])</span><br><span class="line">b.lastRuneSize = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n, b.readErr()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// One read.</span></span><br><span class="line"><span class="comment">// Do not use b.fill, which will loop.</span></span><br><span class="line">b.r = <span class="number">0</span></span><br><span class="line">b.w = <span class="number">0</span></span><br><span class="line">n, b.err = b.rd.Read(b.buf)</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(errNegativeRead)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, b.readErr()</span><br><span class="line">&#125;</span><br><span class="line">b.w += n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy as much as we can</span></span><br><span class="line">n = <span class="built_in">copy</span>(p, b.buf[b.r:b.w])</span><br><span class="line">b.r += n</span><br><span class="line">b.lastByte = <span class="keyword">int</span>(b.buf[b.r<span class="number">-1</span>])</span><br><span class="line">b.lastRuneSize = <span class="number">-1</span></span><br><span class="line"><span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中可以看到<code>n, b.err = b.rd.Read(p)</code>,说明这内部是调用io.Read方法.然后将buf中的可用内容尽可能的复制给p.</p><p>鉴于篇幅过长,以下其他常用方法就留给读者自己去分析吧,</p><ul><li><p><code>func (b *Reader) ReadByte() (c byte, err error)</code></p><p>ReadByte读取并返回一个字节。如果没有可用的数据，会返回错误。</p></li><li><p><code>func (b *Reader) ReadRune() (r rune, size int, err error)</code></p><p>ReadRune读取一个utf-8编码的unicode码值，返回该码值、其编码长度和可能的错误。如果utf-8编码非法，读取位置只移动1字节，返回U+FFFD，返回值size为1而err为nil。如果没有可用的数据，会返回错误。</p></li><li><p><code>func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</code></p><p>ReadLine是一个低水平的行数据读取原语。大多数调用者应使用ReadBytes(‘\n’)或ReadString(‘\n’)代替，或者使用Scanner。</p><p>ReadLine尝试返回一行数据，不包括行尾标志的字节。如果行太长超过了缓冲，返回值isPrefix会被设为true，并返回行的前面一部分。该行剩下的部分将在之后的调用中返回。返回值isPrefix会在返回该行最后一个片段时才设为false。返回切片是缓冲的子切片，只在下一次读取操作之前有效。ReadLine要么返回一个非nil的line，要么返回一个非nil的err，两个返回值至少一个非nil。</p><p>返回的文本不包含行尾的标志字节（”\r\n”或”\n”）。如果输入流结束时没有行尾标志字节，方法不会出错，也不会指出这一情况。在调用ReadLine之后调用UnreadByte会总是吐出最后一个读取的字节（很可能是该行的行尾标志字节），即使该字节不是ReadLine返回值的一部分。</p></li><li><p><code>func (b *Reader) ReadString(delim byte) (string, error)</code></p><p>ReadString读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的字符串。如果ReadString方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadString方法返回的切片不以delim结尾时，会返回一个非nil的错误。</p></li><li><p><code>func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</code></p><p>ReadSlice读取直到第一次遇到delim字节，返回缓冲里的包含已读取的数据和delim字节的切片。该返回值只在下一次读取操作之前合法。如果ReadSlice放在在读取到delim之前遇到了错误，它会返回在错误之前读取的数据在缓冲中的切片以及该错误（一般是io.EOF）。如果在读取到delim之前缓冲就被写满了，ReadSlice失败并返回ErrBufferFull。因为ReadSlice的返回值会被下一次I/O操作重写，调用者应尽量使用ReadBytes或ReadString替代本法功法。当且仅当ReadBytes方法返回的切片不以delim结尾时，会返回一个非nil的错误。</p></li><li><p><code>func (b *Reader) ReadBytes(delim byte) ([]byte, error)</code></p><p>ReadBytes读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的切片。如果ReadBytes方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadBytes方法返回的切片不以delim结尾时，会返回一个非nil的错误。</p></li></ul><p>例子1:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f,err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">reader := bufio.NewReader(f)</span><br><span class="line">p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">12</span>)</span><br><span class="line">n, err :=reader.Read(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp;  err != io.EOF &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(n)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(p))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子2:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f,err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">reader := bufio.NewReader(f)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF&#123;</span><br><span class="line">fmt.Println(str)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(str)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="bufio-Writer"><a href="#bufio-Writer" class="headerlink" title="bufio.Writer"></a><code>bufio.Writer</code></h2><p><code>bufio.Writer</code>其实和<code>bufio.Reader</code>操作很对应.</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Writer implements buffering for an io.Writer object.</span></span><br><span class="line"><span class="comment">// If an error occurs writing to a Writer, no more data will be</span></span><br><span class="line"><span class="comment">// accepted and all subsequent writes, and Flush, will return the error.</span></span><br><span class="line"><span class="comment">// After all data has been written, the client should call the</span></span><br><span class="line"><span class="comment">// Flush method to guarantee all data has been forwarded to</span></span><br><span class="line"><span class="comment">// the underlying io.Writer.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">struct</span> &#123;</span><br><span class="line">err error</span><br><span class="line">buf []<span class="keyword">byte</span></span><br><span class="line">n   <span class="keyword">int</span></span><br><span class="line">wr  io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面列举几个最最常用的方法</p><ul><li><p><code>func NewWriter(w io.Writer) *Writer</code></p><p>NewWriter创建一个具有默认大小缓冲、写入w的*Writer。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewWriter returns a new Writer whose buffer has the default size.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span> *<span class="title">Writer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewWriterSize(w, defaultBufSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法调用<code>NewWriterSize</code>,返回一个带有默认缓冲区的<code>Writer</code>指针</p><p>defaultBufSize</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">defaultBufSize = <span class="number">4096</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><code>func NewWriterSize(w io.Writer, size int) *Writer</code></p><p>NewWriterSize创建一个具有最少有size尺寸的缓冲、写入w的<em>Writer。如果参数w已经是一个具有足够大缓冲的</em>Writer类型值，会返回w。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewWriterSize returns a new Writer whose buffer has at least the specified</span></span><br><span class="line"><span class="comment">// size. If the argument io.Writer is already a Writer with large enough</span></span><br><span class="line"><span class="comment">// size, it returns the underlying Writer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriterSize</span><span class="params">(w io.Writer, size <span class="keyword">int</span>)</span> *<span class="title">Writer</span></span> &#123;</span><br><span class="line"><span class="comment">// Is it already a Writer?</span></span><br><span class="line">b, ok := w.(*Writer)</span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; <span class="built_in">len</span>(b.buf) &gt;= size &#123;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> size &lt;= <span class="number">0</span> &#123;</span><br><span class="line">size = defaultBufSize</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;Writer&#123;</span><br><span class="line">buf: <span class="built_in">make</span>([]<span class="keyword">byte</span>, size),</span><br><span class="line">wr:  w,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的实现过程和<code>NewReaderSize</code>如出一辙,只不过<code>NewReaderSize</code>中调用了<code>reset</code>方法,这里直接初始化指针对象</p></li><li><p><code>func (b *Writer) Reset(w io.Writer)</code></p><p>Reset丢弃缓冲中的数据，清除任何错误，将b重设为将其输出写入w。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reset discards any unflushed buffered data, clears any error, and</span></span><br><span class="line"><span class="comment">// resets b to write its output to w.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Reset</span><span class="params">(w io.Writer)</span></span> &#123;</span><br><span class="line">b.err = <span class="literal">nil</span></span><br><span class="line">b.n = <span class="number">0</span></span><br><span class="line">b.wr = w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就不多做解释了,一眼就明白</p></li><li><p><code>func (b *Writer) Buffered()</code></p><p>Buffered返回缓冲中已使用的字节数。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffered returns the number of bytes that have been written into the current buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> b.n &#125;</span><br></pre></td></tr></table></figure><p>这个方法就更不用解释了</p></li><li><p><code>func (b *Writer) Available() int</code></p><p>Available返回缓冲中还有多少字节未使用。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Available returns how many bytes are unused in the buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Available</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(b.buf) - b.n &#125;</span><br></pre></td></tr></table></figure><p>不解释</p></li><li><p><code>func (b *Writer) Write(p []byte) (nn int, err error)</code></p><p>Write将p的内容写入缓冲。返回写入的字节数。如果返回值nn &lt; len(p)，还会返回一个错误说明原因。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(nn <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(p) &gt; b.Available() &amp;&amp; b.err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> b.Buffered() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Large write, empty buffer.</span></span><br><span class="line"><span class="comment">// Write directly from p to avoid copy.</span></span><br><span class="line">n, b.err = b.wr.Write(p)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">n = <span class="built_in">copy</span>(b.buf[b.n:], p)</span><br><span class="line">b.n += n</span><br><span class="line">b.Flush()</span><br><span class="line">&#125;</span><br><span class="line">nn += n</span><br><span class="line">p = p[n:]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nn, b.err</span><br><span class="line">&#125;</span><br><span class="line">n := <span class="built_in">copy</span>(b.buf[b.n:], p)</span><br><span class="line">b.n += n</span><br><span class="line">nn += n</span><br><span class="line"><span class="keyword">return</span> nn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>n, b.err = b.wr.Write(p)</code>可得这是通过调用<code>io.Writer</code>接口中的<code>Write</code>方法,</p><p><code>n := copy(b.buf[b.n:], p)</code>这一句和前面Read方法刚好相反,这是将p复制给buf的可用部分</p></li><li><p><code>func (b *Writer) WriteString(s string) (int, error)</code></p><p>WriteString写入一个字符串。返回写入的字节数。如果返回值nn &lt; len(s)，还会返回一个错误说明原因。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">nn := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(s) &gt; b.Available() &amp;&amp; b.err == <span class="literal">nil</span> &#123;</span><br><span class="line">n := <span class="built_in">copy</span>(b.buf[b.n:], s)</span><br><span class="line">b.n += n</span><br><span class="line">nn += n</span><br><span class="line">s = s[n:]</span><br><span class="line">b.Flush()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nn, b.err</span><br><span class="line">&#125;</span><br><span class="line">n := <span class="built_in">copy</span>(b.buf[b.n:], s)</span><br><span class="line">b.n += n</span><br><span class="line">nn += n</span><br><span class="line"><span class="keyword">return</span> nn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键语句<code>n := copy(b.buf[b.n:], s)</code>不解释</p></li><li><p><code>func (b *Writer) Flush() error</code></p><p>Flush方法将缓冲中的数据写入下层的io.Writer接口。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Flush</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> b.err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b.n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := b.wr.Write(b.buf[<span class="number">0</span>:b.n])</span><br><span class="line"><span class="keyword">if</span> n &lt; b.n &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">err = io.ErrShortWrite</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; n &lt; b.n &#123;</span><br><span class="line"><span class="built_in">copy</span>(b.buf[<span class="number">0</span>:b.n-n], b.buf[n:b.n])</span><br><span class="line">&#125;</span><br><span class="line">b.n -= n</span><br><span class="line">b.err = err</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">b.n = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下,如果b有错误就直接返回错误,如果b中没有写入值,则不做任何处理,否则就将缓冲中的n个值写进底层io.Writer中,如果写入的值数量小于缓冲取的值并且没有出错,则将err定义为<code>io.ErrShortWrite</code>错误,如果err不为空,并且写进底层<code>io.Writer</code>中的数据小于缓冲中原有的数据时,将剩余的数据写进缓冲区开头,将缓冲区已用空间设置为原来大小减去写人底层大小.如果err为空则代表成功将所有缓冲数据写入<code>io.Writer</code>将已用空间置为0</p></li></ul><p>其他<code>bufio</code>中的方法就留给读者自己去探索吧!</p><p>举个例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, err := os.OpenFile(<span class="string">&quot;test.txt&quot;</span>, os.O_RDWR|os.O_CREATE|os.O_APPEND, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">writer := bufio.NewWriter(f)</span><br><span class="line">writer.WriteString(<span class="string">&quot;让我康康是哪位靓仔看到了这句话\n&quot;</span>)</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">&quot;原来是你!\n&quot;</span>))</span><br><span class="line"></span><br><span class="line">writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:最后一定要flush一下,否则数据就不会写入文件,注意使用<code>OpenFile</code>函数打开文件并指定可写,否则将写不进去.</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-堆排序</title>
      <link href="/2020/05/27/python-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/05/27/python-%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序算法流程"><a href="#堆排序算法流程" class="headerlink" title="堆排序算法流程"></a>堆排序算法流程</h2><p>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong> </p><h2 id="用python实现"><a href="#用python实现" class="headerlink" title="用python实现"></a>用python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span>(<span class="params">intList: [int]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    end = len(intList) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> end &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 进行大顶堆的构造</span></span><br><span class="line">        heap(intList, end)</span><br><span class="line">        <span class="comment"># 交换第一个与最后一个的位置</span></span><br><span class="line">        intList[<span class="number">0</span>], intList[end] = intList[end], intList[<span class="number">0</span>]</span><br><span class="line">        end -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap</span>(<span class="params">intList: [int], end: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    i = end</span><br><span class="line">    <span class="comment"># 判断end是否是孤立</span></span><br><span class="line">    <span class="keyword">if</span> end % <span class="number">2</span>:</span><br><span class="line">        <span class="comment"># 孤立</span></span><br><span class="line">        <span class="comment"># 判断end和父元素的大小</span></span><br><span class="line">        <span class="keyword">if</span> intList[int((end<span class="number">-1</span>)/<span class="number">2</span>)] &lt; intList[end]:</span><br><span class="line">            intList[int((end<span class="number">-1</span>)/<span class="number">2</span>)</span><br><span class="line">                    ], intList[end] = intList[end], intList[int((end<span class="number">-1</span>)/<span class="number">2</span>)]</span><br><span class="line">        i = end<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 判断两个孩纸节点和父元素的大小</span></span><br><span class="line">        father = intList[int((i<span class="number">-2</span>)/<span class="number">2</span>)]</span><br><span class="line">        leftChild = intList[i<span class="number">-1</span>]</span><br><span class="line">        rightChild = intList[i]</span><br><span class="line">        maxIndex = i <span class="keyword">if</span> rightChild &gt; leftChild <span class="keyword">else</span> i<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> father &lt; intList[maxIndex]:</span><br><span class="line">            intList[int(</span><br><span class="line">                (i<span class="number">-2</span>)/<span class="number">2</span>)], intList[maxIndex] = intList[maxIndex],  intList[int((i<span class="number">-2</span>)/<span class="number">2</span>)]</span><br><span class="line">        i -= <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang-堆排序</title>
      <link href="/2020/05/27/golang-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/05/27/golang-%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序算法流程"><a href="#堆排序算法流程" class="headerlink" title="堆排序算法流程"></a>堆排序算法流程</h2><p>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong> </p><h2 id="用golang实现"><a href="#用golang实现" class="headerlink" title="用golang实现"></a>用golang实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(intList []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">end := <span class="built_in">len</span>(intList) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> end &gt;= <span class="number">0</span>&#123;</span><br><span class="line">heap(intList, end)</span><br><span class="line">intList[<span class="number">0</span>], intList[end] = intList[end], intList[<span class="number">0</span>]</span><br><span class="line">end--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heap</span><span class="params">(intList []<span class="keyword">int</span>, end <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">i := end</span><br><span class="line"><span class="comment">// 判断end是否是奇数</span></span><br><span class="line"><span class="keyword">if</span> end%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// 比较end和其父亲的大小</span></span><br><span class="line"><span class="keyword">if</span> intList[end] &gt; intList[(end<span class="number">-1</span>)/<span class="number">2</span>] &#123;</span><br><span class="line"><span class="comment">// 和父亲交换位置</span></span><br><span class="line">intList[end], intList[(end<span class="number">-1</span>)/<span class="number">2</span>] = intList[(end<span class="number">-1</span>)/<span class="number">2</span>], intList[end]</span><br><span class="line">&#125;</span><br><span class="line">i = end - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ; i &gt; <span class="number">0</span>; i -= <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 判断孩子和父亲的大小</span></span><br><span class="line">father := intList[(i<span class="number">-2</span>)/<span class="number">2</span>]</span><br><span class="line">leftChild := intList[i<span class="number">-1</span>]</span><br><span class="line">rightChild := intList[i]</span><br><span class="line">maxIndex := i <span class="comment">// 两个孩子中大的一个的下标</span></span><br><span class="line"><span class="keyword">if</span> leftChild &gt; rightChild&#123;</span><br><span class="line">maxIndex = i<span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> father &lt; intList[maxIndex] &#123;</span><br><span class="line">intList[(i<span class="number">-2</span>)/<span class="number">2</span>], intList[maxIndex] = intList[maxIndex], intList[(i<span class="number">-2</span>)/<span class="number">2</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-归并排序</title>
      <link href="/2020/05/26/python-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/05/26/python-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="归并排序算法流程"><a href="#归并排序算法流程" class="headerlink" title="归并排序算法流程"></a>归并排序算法流程</h2><p>并归排序采用的是分治的思想,先将乱序的数组逐级拆分成一个个小部分,最底层每个部分长度为一(各个部分视为有序),然后在将有序的部分按照完全二叉树两两合并逐级往上,直到排序结束</p><p>参考如下图片(来源:<a href="https://www.cnblogs.com/chengxiao/p/6194356.html">https://www.cnblogs.com/chengxiao/p/6194356.html</a>)</p><p><img src="/images/fenzhi_1.png" alt="img"></p><p>每部分的合并规则如下:</p><p><img src="/images/guibin_1.png" alt="img"></p><h2 id="用python实现"><a href="#用python实现" class="headerlink" title="用python实现"></a>用python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">intList: list</span>) -&gt; list:</span></span><br><span class="line">    length = len(intList)</span><br><span class="line">    <span class="comment"># 长度为1直接返回</span></span><br><span class="line">    <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> intList</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先分</span></span><br><span class="line">    middle = int(length / <span class="number">2</span>)</span><br><span class="line">    left = mergeSort(intList[:middle])</span><br><span class="line">    right = mergeSort(intList[middle:])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 后治</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left: list, right: list</span>) -&gt; list:</span></span><br><span class="line">    leftLen = len(left)</span><br><span class="line">    rightLen = len(right)</span><br><span class="line">    <span class="comment"># 定义i, j指向左右列表的开始</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 定义临时列表</span></span><br><span class="line">    temp = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt; leftLen <span class="keyword">and</span> j &lt; rightLen:</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">            <span class="comment"># 将左边的值放入temp中</span></span><br><span class="line">            temp.append(left[i])</span><br><span class="line">            <span class="comment"># i++</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将右边的值放入temp</span></span><br><span class="line">            temp.append(right[j])</span><br><span class="line">            <span class="comment"># j++</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结束循环后会多有一个列表有余</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; leftLen:</span><br><span class="line">        temp = temp+left[i:]</span><br><span class="line">    <span class="keyword">elif</span> j &lt; rightLen:</span><br><span class="line">        temp = temp + right[j:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang-归并排序</title>
      <link href="/2020/05/26/golang-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/05/26/golang-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="归并排序算法流程"><a href="#归并排序算法流程" class="headerlink" title="归并排序算法流程"></a>归并排序算法流程</h2><p>并归排序采用的是分治的思想,先将乱序的数组逐级拆分成一个个小部分,最底层每个部分长度为一(各个部分视为有序),然后在将有序的部分按照完全二叉树两两合并逐级往上,直到排序结束</p><p>参考如下图片(来源:<a href="https://www.cnblogs.com/chengxiao/p/6194356.html">https://www.cnblogs.com/chengxiao/p/6194356.html</a>)</p><p><img src="/images/fenzhi_1.png" alt="img"></p><p>每部分的合并规则如下:</p><p><img src="/images/guibin_1.png" alt="img"></p><h2 id="用golang实现"><a href="#用golang实现" class="headerlink" title="用golang实现"></a>用golang实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span><span class="params">(intList []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(intList)</span><br><span class="line"><span class="comment">// 长度为0直接退出</span></span><br><span class="line"><span class="keyword">if</span> length &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> intList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先分</span></span><br><span class="line">middle := length / <span class="number">2</span></span><br><span class="line">left := MergeSort(intList[:middle])</span><br><span class="line">right := MergeSort(intList[middle:])</span><br><span class="line"><span class="comment">// 后治</span></span><br><span class="line"><span class="keyword">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">leftLen := <span class="built_in">len</span>(left)</span><br><span class="line">rightLen := <span class="built_in">len</span>(right)</span><br><span class="line"><span class="comment">// 定义i,j指针指向left,right的,开始</span></span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="comment">// 定义临时切片</span></span><br><span class="line">temp := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i &lt; leftLen &amp;&amp; j &lt; rightLen &#123;</span><br><span class="line"><span class="keyword">if</span> left[i] &lt; right[j] &#123;</span><br><span class="line"><span class="comment">// 将左边的值放入temp</span></span><br><span class="line">temp =<span class="built_in">append</span>(temp, left[i])</span><br><span class="line"><span class="comment">// i++</span></span><br><span class="line">i++</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 将右边的值放入temp</span></span><br><span class="line">temp =<span class="built_in">append</span>(temp, right[j])</span><br><span class="line"><span class="comment">// j++</span></span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结束循环后会多有一个切片有余</span></span><br><span class="line"><span class="keyword">if</span> i &lt; leftLen &#123;</span><br><span class="line"><span class="comment">// 如果左边有余</span></span><br><span class="line">temp = <span class="built_in">append</span>(temp, left[i:]...)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> j &lt; rightLen &#123;</span><br><span class="line"><span class="comment">// 如果右边有余</span></span><br><span class="line">temp = <span class="built_in">append</span>(temp, right[j:]...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang-channel</title>
      <link href="/2020/05/26/golang-channel/"/>
      <url>/2020/05/26/golang-channel/</url>
      
        <content type="html"><![CDATA[<p>在golang中channel用于<code>goroutine</code>之间的通信,在阅读这篇文章之前,我已经默认你已经熟悉了(至少了解了)goroutine</p><h2 id="1-channel的定义"><a href="#1-channel的定义" class="headerlink" title="1. channel的定义"></a>1. channel的定义</h2><p>channel是引用类型,需要实用make来创建channel,如下</p><p><code>make(chan Type, [buffer])</code></p><p>make对于channel接收两个参数,第一个是通道的类型,第二个是个可选参数代表通道缓冲区的大小(省略代表无缓冲),比如创建一个用于传递<code>int</code>类型的通道可以如下定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)<span class="comment">// 无缓冲</span></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>) <span class="comment">// 带有两个缓冲的通道</span></span><br></pre></td></tr></table></figure><p><em>要想使用通道必须make! 以下的种种操作都是基于已经make后的channel,不再讨论由于通道没有make而引起的低级错误</em></p><h2 id="2-channel的操作"><a href="#2-channel的操作" class="headerlink" title="2. channel的操作"></a>2. channel的操作</h2><h3 id="1-向channel中放入元素"><a href="#1-向channel中放入元素" class="headerlink" title="1. 向channel中放入元素"></a>1. 向channel中放入元素</h3><ul><li><p>我们可以使用<code>&lt;-</code>符号指向<code>channel</code>来将元素放入channel中</p></li><li><p><em>注意向通道中传值必须要求该通道还有容量(缓冲),而且通道不能关闭</em></p></li><li><p><em>对于无缓冲的或者缓冲已经满了的channel不可以轻易的传入值,必须要有goroutine同时在取元素才可以放入</em></p></li></ul><p><strong>向一个有缓冲,非满的channel传值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 定义一个带有一个缓冲的通道</span></span><br><span class="line">c &lt;- <span class="number">1</span>   <span class="comment">// 向通道中传入一个1,正常</span></span><br></pre></td></tr></table></figure><p><strong>向一个有缓冲,满的channel传值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 定义一个带有一个缓冲的通道</span></span><br><span class="line">c &lt;- <span class="number">1</span>   <span class="comment">// 向通道中传入一个值,这个值传入后填满了该通道</span></span><br><span class="line">c &lt;- <span class="number">2</span>                 <span class="comment">// 再向通道中传入一个值,报错!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br></pre></td></tr></table></figure><p><strong>向一个无缓冲,的channel传值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 定义一个无缓冲通道</span></span><br><span class="line">c &lt;- <span class="number">1</span>              <span class="comment">// 向无缓冲通道传值,报错!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br></pre></td></tr></table></figure><p>其实上述两种错误均是由于通道满了而引起的(无缓冲的通道可以看成是缓冲为0的通道),解决方法很简单,只要保证有个goroutine同时在从该通道中取值即可,我这里针对<code>向一个有缓冲,满的channel传值</code>给出解决思路</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">c &lt;- <span class="number">1</span>  <span class="comment">// 因为我们定义的通道带有一个缓冲,</span></span><br><span class="line">        <span class="comment">// 所以在发布任务之前允许存在最多一个任务投递,也可以写在发布任务之后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环用于发布任务</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> doWork(c)<span class="comment">// 如果通道现在是空的 goroutine会等待,</span></span><br><span class="line">                <span class="comment">// 如果检测到现在是空的且没有任务投递,就会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c &lt;- <span class="number">2</span><span class="comment">// 多余的任务投递必须在任务发布之后</span></span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(i <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">a := &lt;-i</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d号开始工作了\n&quot;</span>, a)</span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>) <span class="comment">// 模拟耗时</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d号结束工作了,输出:%d\n&quot;</span>, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于空channel传值报错的解决思路就留给读者了</p><h3 id="2-从channel中取出元素"><a href="#2-从channel中取出元素" class="headerlink" title="2. 从channel中取出元素"></a>2. 从channel中取出元素</h3><ul><li><p>我们可以使用<code>&lt;-</code>符号指向<code>变量</code>来将channel中的元素放<code>变量</code>中</p><p>此时可以接收两个值一个数值一个状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-c   <span class="comment">// c是通道,v是取到的值,ok是状态,正常时是true,从关闭的空通道取值是false</span></span><br></pre></td></tr></table></figure></li><li><p>可以通过<code>range</code>取值</p></li><li><p><em>注意从通道中取值必须要求该通道还有值</em></p></li><li><p><em>对于无缓冲的或者缓冲已经空了的channel不可以轻易的取出值,必须要同时在放元素才可以取出</em></p></li><li><p>可以向已经关闭的通道取值</p></li></ul><p><strong>ok为true的例子</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">a, ok := &lt;-c</span><br><span class="line">fmt.Println(a, ok)  <span class="comment">// 输出 1 true</span></span><br></pre></td></tr></table></figure><p><strong>ok为false的例子</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">a, ok := &lt;-c</span><br><span class="line">fmt.Println(a, ok)  <span class="comment">// 输出 0 false</span></span><br></pre></td></tr></table></figure><p><strong>ok的应用–循环取值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    v, ok := &lt;- c</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>range取值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">c &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> c&#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>向一个有缓冲,非空的channel取值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 定义一个带有一个缓冲的通道</span></span><br><span class="line">c &lt;- <span class="number">1</span>   <span class="comment">// 向通道中传入一个1,使通道非空</span></span><br><span class="line">i := &lt;-c   <span class="comment">// 从通道中取出一个值赋给变量i</span></span><br><span class="line"><span class="comment">// 如果只是想取出值而不想对该值做任何其他操作,可以这么写    &lt;-c   左边省略接收者</span></span><br></pre></td></tr></table></figure><p><strong>向一个有缓冲,空的channel取值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 定义一个带有一个缓冲的通道</span></span><br><span class="line">&lt;-c                    <span class="comment">// 向空通道中取出一个值,报错!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br></pre></td></tr></table></figure><p><strong>向一个无缓冲,的channel取值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 定义一个无缓冲通道</span></span><br><span class="line">&lt;-c                 <span class="comment">// 向无缓冲通道取值,报错!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br></pre></td></tr></table></figure><p>其实上述两种错误均是由于通道空了而引起的(无缓冲的通道可以看成是缓冲为0的通道),解决方法很简单,只要保证同时在从该通道中存值即可,我这里针对<code>向一个有缓冲,空的channel取值</code>给出解决思路</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> doWork(c)</span><br><span class="line">&lt;-c<span class="comment">// 取值必须在放值之后</span></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(i <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Printf(<span class="string">&quot;goroutine开始工作了\n&quot;</span>, )</span><br><span class="line">time.Sleep(time.Second * <span class="number">2</span>) <span class="comment">// 模拟耗时</span></span><br><span class="line">i &lt;- <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;goroutine结束工作了,放入:%d\n&quot;</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于空channel取值报错的解决思路就留给读者了</p><h3 id="3-关闭通道"><a href="#3-关闭通道" class="headerlink" title="3. 关闭通道"></a>3. 关闭通道</h3><p>对于一个通道我们可以使用<code>close</code>内置函数来进行关闭,关闭后的通道具有以下特点</p><ul><li>向一个已经关闭的通道发送值是不允许的,会报错</li><li>从一个已经关闭但是里面还有值的通道取值是允许的,可以正常获取到值</li><li>从一个已经关闭但是为空的通道取值是允许的,会获取通道类型元素的零值</li><li>不可以再次关闭一个已经关闭的通道,会报错</li><li>已经关闭的通道无法再次打开</li></ul><p><strong>例子1: 向一个已经关闭的通道发送值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">c &lt;- <span class="number">1</span><span class="comment">// 报错!!!!!!!!!!!</span></span><br></pre></td></tr></table></figure><p><strong>例子2: 从一个已经关闭但是里面还有值的通道取值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">a := &lt;-c</span><br><span class="line">fmt.Println(a)<span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><p><strong>例子3: 从一个已经关闭但是为空的通道取值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">a := &lt;-c</span><br><span class="line">fmt.Println(a)  <span class="comment">// 输出 0 </span></span><br></pre></td></tr></table></figure><p><strong>例子4: 关闭一个已经关闭的通道</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line"><span class="built_in">close</span>(c) <span class="comment">// 报错: panic: close of closed channel</span></span><br></pre></td></tr></table></figure><h2 id="3-单向通道"><a href="#3-单向通道" class="headerlink" title="3. 单向通道"></a>3. 单向通道</h2><ul><li>在函数中使用通道时我们可以限制其为只读通道或者只写通道</li></ul><p><strong>定义只读通道的例子</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(i &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">&lt;-i <span class="comment">// 只能取值</span></span><br><span class="line"><span class="comment">//i &lt;- 1 // 存值操作将不被允许</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义只写通道的例子</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(i <span class="keyword">chan</span> &lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">i &lt;- <span class="number">1</span>      <span class="comment">// 只能存值</span></span><br><span class="line"><span class="comment">//&lt;-i// 取值操作将不被允许</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang-快速排序</title>
      <link href="/2020/05/26/golang-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/05/26/golang-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序算法流程"><a href="#快速排序算法流程" class="headerlink" title="快速排序算法流程"></a>快速排序算法流程</h2><ol><li>选定一个基准值(任意选,以第一个为例)</li><li>定义左右指针指向左右两端</li><li>左指针往右移动,如果遇到大于基准值的数就把它和右指针的值调换位置,然后左指针不动,右指针开始向左移动,如果遇到小于基准值的数就把他和左指针的值调换位置,然后开始移动左指针,以此类推,知道左右指针相遇</li><li>递归上述过程知道排序结束</li></ol><h2 id="用golang实现"><a href="#用golang实现" class="headerlink" title="用golang实现"></a>用golang实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(intList []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果长度小于等于1就直接结束</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(intList) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 将第一个值选定为基准值</span></span><br><span class="line">flag := intList[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 定义左右指针</span></span><br><span class="line">left, right := <span class="number">0</span>, <span class="built_in">len</span>(intList)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= right; &#123;</span><br><span class="line"><span class="keyword">if</span> intList[i] &gt; flag &#123;</span><br><span class="line">intList[i], intList[right] = intList[right], intList[i]</span><br><span class="line">right--</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">intList[i], intList[left] = intList[left], intList[i]</span><br><span class="line">i++</span><br><span class="line">left++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line">QuickSort(intList[:left])</span><br><span class="line">QuickSort(intList[left+<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang-引用类型与地址</title>
      <link href="/2020/05/25/golang-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%9C%B0%E5%9D%80/"/>
      <url>/2020/05/25/golang-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p>go语言中的<code>引用类型</code>(我更愿意称其为<code>指向类型</code>)其实就是<code>存放地址的类型</code>,比如<code>slice</code>,<code>map</code>,<code>channel</code>,和其他指针类型(<code>*int</code>…)</p><p>要实用这些(存放地址的)类型之前就必须要为其分配<code>内存</code>.下面我一一举例说明一下(以下操作均在函数内部操作,意味着可以使用<code>:=</code>来声明定义变量)</p><h2 id="1-值类型的指针形式"><a href="#1-值类型的指针形式" class="headerlink" title="1. 值类型的指针形式"></a>1. 值类型的指针形式</h2><p><em>以int为例</em></p><ul><li><p>一个错误的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i *<span class="keyword">int</span></span><br><span class="line">*i = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>panic: runtime error: invalid memory address or nil pointer dereference</p><p>错误原因,i为指针变量,但是未被分配地址就试图操作其内容</p></li><li><p>解决方法(写法一)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i *<span class="keyword">int</span></span><br><span class="line">i = <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">*i = <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>解决方法(写法二)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">*i = <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>new函数</p><p>new函数用于给本身不带有指针类型的类型带上指针,这话是我给出的解释,说白了就是输入<code>值类型</code>返回<code>该类型的指针</code>.new函数可以分配内存并且初始化为零值.这是他的函数定义:<code>func new(Type) *Type</code></p></li></ul><h2 id="2-Slice"><a href="#2-Slice" class="headerlink" title="2. Slice"></a>2. Slice</h2><p>slice本身就是一个带指针的类型(引用类型),所以使用他之前必须分配地址,但他比较特殊,由于<code>append</code>函数的功能,我们几乎不会遇到<code>slice</code>内存未分配的函数,更多的是遇到下标越界</p><ul><li><p>声明时为分配内存的例子一</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span><span class="comment">// 定义一个存放int的切片,未分配内存</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 报错,panic: runtime error: index out of range [0] with length 0</span></span><br></pre></td></tr></table></figure></li><li><p>声明时为分配内存的例子二</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> <span class="comment">// 定义一个存放int的切片,未分配内存</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>) <span class="comment">// 未报错</span></span><br></pre></td></tr></table></figure><p>有些人可能会感到奇怪,这里明明没有分配内存怎么可以使用slice而不报错,原因就是,append函数会自动分配内存(其实就是扩容策略,没有发生下标越界错误也是因为扩容策略),这是append函数的文档:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The append built-in function appends elements to the end of a slice. If</span></span><br><span class="line"><span class="comment">// it has sufficient capacity, the destination is resliced to accommodate the</span></span><br><span class="line"><span class="comment">// new elements. If it does not, a new underlying array will be allocated.</span></span><br><span class="line"><span class="comment">// Append returns the updated slice. It is therefore necessary to store the</span></span><br><span class="line"><span class="comment">// result of append, often in the variable holding the slice itself:</span></span><br><span class="line"><span class="comment">//slice = append(slice, elem1, elem2)</span></span><br><span class="line"><span class="comment">//slice = append(slice, anotherSlice...)</span></span><br><span class="line"><span class="comment">// As a special case, it is legal to append a string to a byte slice, like this:</span></span><br><span class="line"><span class="comment">//slice = append([]byte(&quot;hello &quot;), &quot;world&quot;...)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []Type, elems ...Type)</span> []<span class="title">Type</span></span></span><br></pre></td></tr></table></figure></li><li><p>make函数对于slice</p><p>make函数是用于对<code>slice</code>,<code>map</code>,<code>channell</code>专属的内存分配函数,它的返回值是类型本身,因为这三种类型本身带有指针,另外make函数对这三种类型有智能的判断,对slice来说,make函数是这种样子<code>make(sliceType, length int, capacity int)sliceType</code>,它接受三个参数,分别是切片类型,长度,和容量,其中容量可以省略(和length相同),如果length大于0, 则已经被分配的空间会先存放类型零值.</p></li><li><p>声明时分配内存的写法一</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">s = <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">fmt.Println(s) <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">s = <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">fmt.Println(s) <span class="comment">// [0 0 0]</span></span><br></pre></td></tr></table></figure></li><li><p>声明时分配内存的写法二</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p>不使用make函数分配内存的写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这种写法只能用于<code>:=</code>,其实就是通过<code>&#123;&#125;</code>来事先初始化,已经初始化了,肯定也就分配内存了,只不过上面的写法是初始化为空的初始化,再举个例子更好的帮大家理解一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-map"><a href="#3-map" class="headerlink" title="3. map"></a>3. map</h2><p>如slice一样,map也是一个带指针的类型(引用类型)</p><ul><li><p>一个错误的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">m[<span class="string">&quot;age&quot;</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>panic: assignment to entry in nil map</p><p>错误原因:map是引用类型,未分配内存便尝试操作其中的内容</p></li><li><p>make函数对于map</p><p>和slice不同,make函数对于map是这样子的<code>make(mapType, capacity int)mapType</code>,它只接受两个参数分别是map类型和容量,如果传递多个参数会编译时报错,和slice一样capacity可以被省略.<strong>值得注意的是虽然第二个值是容量,但是map并不能使用<code>cap</code>函数获取其容量,而且通过<code>len</code>函数获得是map的长度而不是容量</strong>,举个例子说明一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(m)) <span class="comment">// 0</span></span><br><span class="line">m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;horika&quot;</span></span><br><span class="line"><span class="comment">// fmt.Println(cap(m))  // panic</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(m)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>通过make函数给map分配内存写法一</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">1</span>) <span class="comment">// 容量可以被省略 m = make(map[string]string)</span></span><br></pre></td></tr></table></figure></li><li><p>通过make函数给map分配内存写法二</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></li><li><p>不通过make函数分配内存的写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>][<span class="keyword">int</span>]&#123;&#125;</span><br></pre></td></tr></table></figure><p>原理和slice的这种写法一样,通过<code>:=</code>和<code>&#123;&#125;</code>来进行初始化,一旦被初始化了,也就被分配内存了.举个初始化不为空的例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-channel"><a href="#4-channel" class="headerlink" title="4. channel"></a>4. channel</h2><p>在go语言中channel是为了<code>goroutine</code>的通信,他也是一种引用类型.<code>channel</code>的使用必须通过<code>make</code>函数分配内存.</p><ul><li><p>一个错误的例子一</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 定义一个传递int的通道</span></span><br><span class="line"><span class="keyword">go</span> printI(c)   <span class="comment">// 尝试向一个为分配内存的通道取值; 这是事先定义的接收一个int通道的函数,</span></span><br><span class="line">   <span class="comment">// 如果没有这一句下面的操作会堵塞,因为为分配的通道肯定是没有缓冲的</span></span><br><span class="line">c &lt;- <span class="number">1</span>   <span class="comment">// 尝试向一个没有分配内存的通道传值</span></span><br></pre></td></tr></table></figure><p>无论是传值还是取值都会报错</p><p>goroutine 1 [chan send (nil chan)]:</p><p>goroutine 18 [chan receive (nil chan)]:</p></li><li><p>一个错误的例子二</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 定义一个传递int的通道</span></span><br><span class="line"><span class="built_in">close</span>(c)   <span class="comment">// 尝试关闭一个没有分配内存的通道</span></span><br></pre></td></tr></table></figure><p>panic: close of nil channel</p><p>如果关闭一个没有没有分配内存的通道也会报错</p></li><li><p>make函数对于channel</p><p>与以上两种类型都不同make函数对于channel是这样的<code>make(chanType, buffer int)chanType</code>,它接收两个参数,第一个是通道的类型,第二个是缓冲大小(省略则是无缓冲通道).</p></li><li><p>改正上述例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> printI(c)</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> printI(c)</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br></pre></td></tr></table></figure><p>当然如果带有缓冲,传值时就不怕阻塞了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArchLinux安装后的配置</title>
      <link href="/2020/03/12/ArchLinux%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/03/12/ArchLinux%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-添加archlinuxcn源"><a href="#1-添加archlinuxcn源" class="headerlink" title="1. 添加archlinuxcn源"></a>1. 添加<code>archlinuxcn</code>源</h2><p>在 <code>/etc/pacman.conf</code> 文件末尾添加以下两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">Server &#x3D; https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;archlinuxcn&#x2F;$arch</span><br></pre></td></tr></table></figure><p>然后安装 GPG key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syu</span><br><span class="line">sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure><h2 id="2-配置aur"><a href="#2-配置aur" class="headerlink" title="2. 配置aur"></a>2. 配置aur</h2><p>安装yay</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S yay</span><br></pre></td></tr></table></figure><p>修改<code>aururl</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay --aururl &quot;https:&#x2F;&#x2F;aur.tuna.tsinghua.edu.cn&quot; --save</span><br></pre></td></tr></table></figure><h2 id="3-更换shell为zsh"><a href="#3-更换shell为zsh" class="headerlink" title="3. 更换shell为zsh"></a>3. 更换<code>shell</code>为<code>zsh</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s &#x2F;bin&#x2F;zsh</span><br></pre></td></tr></table></figure><p>重启即可生效</p><h2 id="4-安装oh-my-zsh及插件"><a href="#4-安装oh-my-zsh及插件" class="headerlink" title="4. 安装oh-my-zsh及插件"></a>4. 安装<code>oh-my-zsh</code>及插件</h2><p>先确保git，wget, curl已经安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S git wget curl</span><br></pre></td></tr></table></figure><p>安装ohmyzsh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(wget https:&#x2F;&#x2F;raw.github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;master&#x2F;tools&#x2F;install.sh -O -)&quot;</span><br></pre></td></tr></table></figure><p>安装历史记录插件和语法检查插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.oh-my-zsh&#x2F;plugins</span><br><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestions.git</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-syntax-highlighting.git</span><br></pre></td></tr></table></figure><p>下载好后在<code>～/.zshrc</code>文件中加入上述插件</p><p>找到<code>plugins=(git)</code>，改为如下（sudo插件无须下载，效果为连按两次<code>esc</code>键给命令加上<code>sudo</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins&#x3D;(</span><br><span class="line">git</span><br><span class="line">sudo</span><br><span class="line">zsh-syntax-highlighting</span><br><span class="line">zsh-autosuggestions</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使插件生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~&#x2F;.zshrc</span><br></pre></td></tr></table></figure><h2 id="5-安装输入法"><a href="#5-安装输入法" class="headerlink" title="5. 安装输入法"></a>5. 安装输入法</h2><p>安装fcitx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx-im</span><br><span class="line">sudo pacman -S fcitx-cofigtool</span><br></pre></td></tr></table></figure><p>在家目录下创建<code>.xprofile</code>文件并写入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export XIM&#x3D;fcitx</span><br><span class="line">export XIM_PROGRAM&#x3D;fcitx</span><br><span class="line">export GTK_IM_MODULE&#x3D;fcitx</span><br><span class="line">export QT_IM_MODULE&#x3D;fcitx</span><br><span class="line">export XMODIFIERS&#x3D;&quot;@im&#x3D;fcitx&quot;</span><br></pre></td></tr></table></figure><p>然后安装喜欢的输入法，这里推荐实用讯飞输入法（搜狗输入法有bug可能用不了）</p><p>讯飞输入法需要去aur里安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S iflyime</span><br></pre></td></tr></table></figure><p>重启查看<code>fcitx 配置</code>是否已经添加了讯飞输入法</p><h2 id="6-配置开发环境"><a href="#6-配置开发环境" class="headerlink" title="6. 配置开发环境"></a>6. 配置开发环境</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>下载pip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S python-pip</span><br></pre></td></tr></table></figure><p>设置pip源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config set global.index-url https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure><h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><ol><li><p>安装go</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S go</span><br></pre></td></tr></table></figure></li><li><p>选择一个go工作目录</p><p>我这里以<code>～/Documents/go</code>为例</p><p>在<code>～/Documents/go</code>下新建三个文件夹分别为<code>src</code>,<code>bin</code>,<code>pkg</code></p></li><li><p>配置环境变量（注意改为你自己的工作目录,<code>GOROOT=/usr/lib/go</code>和我一样，这是安装目录）</p><p>编辑<code>～/.xprofile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export GOROOT&#x3D;&#x2F;usr&#x2F;lib&#x2F;go</span><br><span class="line">export GOPATH&#x3D;~&#x2F;Documents&#x2F;go# 这两行你需要 </span><br><span class="line">export GOBIN&#x3D;~&#x2F;Documents&#x2F;go&#x2F;bin# 修改为自己的</span><br><span class="line">export PATH&#x3D;$PATH:$GOROOT&#x2F;bin:$GOBIN</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .xprofile</span><br></pre></td></tr></table></figure></li><li><p>配置GOPROXY</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.io,direct</span><br></pre></td></tr></table></figure></li></ol><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p>查看当前系统中已经存在的jdk有哪些</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archlinux-java status</span><br></pre></td></tr></table></figure><p>选中其中一个为默认jdk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo archlinux-java set &#96;上面列表中列出的名字其中一个&#96;</span><br></pre></td></tr></table></figure><p>安装最新版jdk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S jdk</span><br></pre></td></tr></table></figure><p>安装jdk8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S jdk8-openjdk</span><br></pre></td></tr></table></figure><h3 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h3><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nodejs npm</span><br></pre></td></tr></table></figure><p>npm使用淘宝镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>安装vue-cli</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli</span><br></pre></td></tr></table></figure><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>安装docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syu docker</span><br></pre></td></tr></table></figure><p>免sudo执行docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gpasswd -a $&#123;USER&#125; docker</span><br></pre></td></tr></table></figure><p>配置docker国内镜像</p><p>在<code>/etc/docker</code>目录下新建<code>daemon.json</code>文件,写入下面内容(网易镜像)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启docker生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><ol><li>安装Maria DB</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S mariadb</span><br></pre></td></tr></table></figure><ol start="2"><li>配置目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mariadb-install-db --user&#x3D;mysql --basedir&#x3D;&#x2F;usr --datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql</span><br></pre></td></tr></table></figure><ol start="3"><li>启动Maria DB</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure><ol start="4"><li>为root用户设置一个新密码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysqladmin -u root password &#39;123456&#39;</span><br></pre></td></tr></table></figure><p>至此已经可以进入数据库了，命令<code>mysql -u root -p</code></p><ol start="5"><li><p>root用用户开启远程访问</p><p> 先进入数据库</p><ol><li><p>选中mysql数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>更改root的访问权限</p><p>   可以先查看当前权限信息（不是必须）</p><p>   <code>select user,authentication_string,host from user;</code></p><p> 123456 为你设置的root用户密码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>刷新数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>将mysql设为开机自启</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systmctl enable mysql</span><br></pre></td></tr></table></figure><h3 id="其他环境"><a href="#其他环境" class="headerlink" title="其他环境"></a>其他环境</h3><p>可以选择通过<code>docker</code>来安装</p><h2 id="7-安装常用软件"><a href="#7-安装常用软件" class="headerlink" title="7. 安装常用软件"></a>7. 安装常用软件</h2><h3 id="1-聊天类"><a href="#1-聊天类" class="headerlink" title="1. 聊天类"></a>1. 聊天类</h3><ul><li><p>qq(wine)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S deepin.com.qq.im</span><br></pre></td></tr></table></figure><p>或者qq(linux)，这个不推荐，太难用了(但是是官方的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S qq-linux</span><br></pre></td></tr></table></figure><p>或者tim</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S deepin.com.qq.office</span><br></pre></td></tr></table></figure><p>或者qq轻聊版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S deepin.com.qq.im.light</span><br></pre></td></tr></table></figure></li><li><p>微信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S deepin.com.wechat2</span><br></pre></td></tr></table></figure></li><li><p>telegram</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S telegram-desktop</span><br></pre></td></tr></table></figure></li><li><p>deepin qq和微信在<code>kde</code>桌面下可能遇到打不开的问题,解决方法如下</p><p>安装如下程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S gnome-settings-daemon</span><br></pre></td></tr></table></figure><p>执行以下操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp &#x2F;etc&#x2F;xdg&#x2F;autostart&#x2F;org.gnome.SettingsDaemon.XSettings.desktop ~&#x2F;.config&#x2F;autostart</span><br></pre></td></tr></table></figure><p>后打开设置，找到<code>开机和关机</code>中的<code>自动启动</code>，将<code>GNOME Settings Daemon&#39;s xsettings plugin</code>设置为已启用，注意要先点击右下角的<code>高级</code>按钮，在弹出框中选中<code>只在Plasma中自动启用</code>，确定即可</p></li></ul><h3 id="2-办公类"><a href="#2-办公类" class="headerlink" title="2. 办公类"></a>2. 办公类</h3><ul><li><p>WPS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S wps-office ttf-wps-fonts wps-office-mui-zh-cn</span><br></pre></td></tr></table></figure></li><li><p>typora</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S typora</span><br></pre></td></tr></table></figure></li><li><p>mindmaster（亿图思维导图）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S yay mindmaster-cn</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-开发类"><a href="#3-开发类" class="headerlink" title="3. 开发类"></a>3. 开发类</h3><ul><li><p>vscode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S code</span><br></pre></td></tr></table></figure></li><li><p>postman</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S postman-bin</span><br></pre></td></tr></table></figure></li><li><p>eclipse（java）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S eclipse-java </span><br></pre></td></tr></table></figure></li><li><p>pycharm</p><p>专业版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S pycharm-professional</span><br></pre></td></tr></table></figure><p>社区版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S pycharm-community-edition </span><br></pre></td></tr></table></figure></li><li><p>IDEA</p><p>专业版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S intellij-idea-ultimate-edition</span><br></pre></td></tr></table></figure><p>社区版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S intellij-idea-community-edition</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-娱乐类"><a href="#4-娱乐类" class="headerlink" title="4. 娱乐类"></a>4. 娱乐类</h3><ul><li><p>网易云音乐</p><p>官方版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S netease-cloud-music</span><br></pre></td></tr></table></figure><p>非dde桌面下可能遇到无法输入中文的问题，需要做以下修改</p><ol><li>安装<code>qcef</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yay -S qcef</span><br></pre></td></tr></table></figure><ol><li>修改<code>/opt/netease/netease-cloud-music/netease-cloud-music.bash</code>文件为以下内容</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">HERE&#x3D;&quot;$(dirname &quot;$(readlink -f &quot;$&#123;0&#125;&quot;)&quot;)&quot;</span><br><span class="line">export XDG_CURRENT_DESKTOP&#x3D;DDE </span><br><span class="line">exec &quot;$&#123;HERE&#125;&quot;&#x2F;netease-cloud-music $@</span><br></pre></td></tr></table></figure><p>民间大神版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S electron-netease-cloud-music</span><br></pre></td></tr></table></figure></li><li><p>qq音乐（wine）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S deepin.com.qq.qqmusic</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-实用工具类"><a href="#5-实用工具类" class="headerlink" title="5. 实用工具类"></a>5. 实用工具类</h3><ul><li><p>谷歌浏览器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure></li><li><p>火狐浏览器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S firefox</span><br></pre></td></tr></table></figure></li><li><p>virtual box</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S virtualbox</span><br></pre></td></tr></table></figure><p>选择<code>virtualbox-host-modules-arch</code>模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S linux-headers</span><br></pre></td></tr></table></figure><p>将当前用户加入<code>vboxusers</code>组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gpasswd -a $USER vboxusers</span><br></pre></td></tr></table></figure><p>其他可选相关项</p><p>注意如果遇到让你选择类型，记得选和第一步一样的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S virtualbox-guest-dkms</span><br><span class="line">sudo pacman -S virtualbox-guest-iso</span><br><span class="line">sudo pacman -S virtualbox-guest-utils</span><br><span class="line">yay -S virtualbox-ext-oracle</span><br></pre></td></tr></table></figure><p>重启</p></li><li><p>百度网盘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S baidunetdisk-bin</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-不可描述类"><a href="#6-不可描述类" class="headerlink" title="6. 不可描述类"></a>6. 不可描述类</h3><ul><li><p>qv2ray</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S qv2ray</span><br><span class="line">sudo pacman -S v2ray</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-美化grub启动界面"><a href="#8-美化grub启动界面" class="headerlink" title="8. 美化grub启动界面"></a>8. 美化grub启动界面</h2><ol><li><p>去商店下载主题包</p><p> <a href="https://www.gnome-look.org/">gnome-look</a></p><p><a href="https://store.kde.org/">kde-look</a></p><p>访问有点慢。。。</p></li><li><p>解压下载好的主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -xf 主题包名</span><br></pre></td></tr></table></figure></li><li><p>复制到grub主题目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -r 主题包名 &#x2F;usr&#x2F;share&#x2F;grub&#x2F;themes&#x2F; </span><br></pre></td></tr></table></figure></li><li><p>修改文件添加主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;default&#x2F;grub</span><br></pre></td></tr></table></figure><p>找到<code>#GRUB_THEME=</code>去掉注释，该为对应的主题名称，就像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_THEME&#x3D;&quot;&#x2F;usr&#x2F;share&#x2F;grub&#x2F;themes&#x2F;主题包名&#x2F;theme.txt&quot;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python从图片中提取文字</title>
      <link href="/2020/03/12/Python%E4%BB%8E%E5%9B%BE%E7%89%87%E4%B8%AD%E6%8F%90%E5%8F%96%E6%96%87%E5%AD%97/"/>
      <url>/2020/03/12/Python%E4%BB%8E%E5%9B%BE%E7%89%87%E4%B8%AD%E6%8F%90%E5%8F%96%E6%96%87%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-系统安装teseract和英文中文语言包"><a href="#1-系统安装teseract和英文中文语言包" class="headerlink" title="1. 系统安装teseract和英文中文语言包"></a>1. 系统安装<code>teseract</code>和英文中文语言包</h2><p>arch下安装十分简单，pacman会自动帮我们解决所有依赖</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S tesseract tesseract-data-eng tesseract-data-chi_sim</span><br></pre></td></tr></table></figure><h2 id="2-python安装必要的第三方库"><a href="#2-python安装必要的第三方库" class="headerlink" title="2. python安装必要的第三方库"></a>2. python安装必要的第三方库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install pillow</span><br><span class="line">sudo pip install pytesseract</span><br></pre></td></tr></table></figure><h2 id="2-代码展示"><a href="#2-代码展示" class="headerlink" title="2. 代码展示"></a>2. 代码展示</h2><p>分别识别中文，英文，数字</p><p>我测试时识别的图片在代码同一目录下的img目录下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">BASE_DIR = os.path.dirname(__file__)</span><br><span class="line"></span><br><span class="line">zh_img = os.path.join(BASE_DIR, <span class="string">&quot;img/zh_demo.png&quot;</span>)</span><br><span class="line">en_img = os.path.join(BASE_DIR, <span class="string">&quot;img/en_demo.png&quot;</span>)</span><br><span class="line">num_img = os.path.join(BASE_DIR, <span class="string">&quot;img/num_demo.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">zh = pytesseract.image_to_string(Image.open(zh_img), lang=<span class="string">&quot;chi_sim&quot;</span>).replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>)    <span class="comment"># 中文识别有时不是特别准确，识别结果中间有空格</span></span><br><span class="line">en = pytesseract.image_to_string(Image.open(en_img))    <span class="comment"># 也只有识别规矩的英文和数字了，可以用来破解低级验证码</span></span><br><span class="line">num = pytesseract.image_to_string(Image.open(num_img))</span><br><span class="line"></span><br><span class="line">print(zh)<span class="comment"># 山重水覆疑无路,柳暗花明又一村</span></span><br><span class="line">print(en)<span class="comment"># kainhuck</span></span><br><span class="line">print(num)<span class="comment"># 0771-5785703</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArchLinux安装(BIOS)</title>
      <link href="/2020/03/10/ArchLinux%E5%AE%89%E8%A3%85/"/>
      <url>/2020/03/10/ArchLinux%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="1-联网"><a href="#1-联网" class="headerlink" title="1. 联网"></a>1. 联网</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wifi-menu</span><br></pre></td></tr></table></figure><p><em>检查是否联通</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><h2 id="2-更新系统时钟"><a href="#2-更新系统时钟" class="headerlink" title="2. 更新系统时钟"></a>2. 更新系统时钟</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-ntp true</span><br></pre></td></tr></table></figure><h2 id="3-磁盘分区"><a href="#3-磁盘分区" class="headerlink" title="3. 磁盘分区"></a>3. 磁盘分区</h2><p>用下面命令检查你要安装的磁盘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>这里假设安装到<code>/dev/sda</code>，然后用下面命令对磁盘分区</p><p>fdisk用法</p><ul><li>g 建立gpt分区表</li><li>n 新建分区</li><li>w 写入磁盘</li><li>p 打印信息</li><li>d 删除分区</li><li>t 指定类型</li><li>q 不保存退出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk &#x2F;dev&#x2F;sda</span><br></pre></td></tr></table></figure><p>这里我给出我的方案：</p><table><thead><tr><th>类形</th><th>磁盘大小</th><th>磁盘序号</th></tr></thead><tbody><tr><td>boot分区</td><td>500m</td><td>/dev/sda1</td></tr><tr><td>swap分区</td><td>6G</td><td>/dev/sda2</td></tr><tr><td>根分区</td><td>其余</td><td>/dev/sda3</td></tr></tbody></table><p>home目录我是在系统安装好后进行的，你们也可以在这一步进行</p><h2 id="4-格式化分区"><a href="#4-格式化分区" class="headerlink" title="4. 格式化分区"></a>4. 格式化分区</h2><p>将boot分区格式化为 <code>ext2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext2 &#x2F;dev&#x2F;sda1</span><br></pre></td></tr></table></figure><p>将swap分区格式化为<code>swap</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap &#x2F;dev&#x2F;sda2</span><br></pre></td></tr></table></figure><p>打开swap分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon &#x2F;dev&#x2F;sda2</span><br></pre></td></tr></table></figure><p>将根目录/home目录格式化为<code>ext4</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 &#x2F;dev&#x2F;sda3</span><br></pre></td></tr></table></figure><h2 id="5-挂载分区"><a href="#5-挂载分区" class="headerlink" title="5. 挂载分区"></a>5. 挂载分区</h2><h3 id="1-先将根分区挂载到-mnt目录"><a href="#1-先将根分区挂载到-mnt目录" class="headerlink" title="1. 先将根分区挂载到/mnt目录"></a>1. 先将根分区挂载到<code>/mnt</code>目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;sda3 &#x2F;mnt</span><br></pre></td></tr></table></figure><h4 id="2-再在-mnt目录下新建boot目录"><a href="#2-再在-mnt目录下新建boot目录" class="headerlink" title="2. 再在/mnt目录下新建boot目录"></a>2. 再在<code>/mnt</code>目录下新建<code>boot</code>目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;mnt&#x2F;boot</span><br></pre></td></tr></table></figure><h3 id="3-最后将boot分区挂载在刚刚创建的-mnt-boot目录"><a href="#3-最后将boot分区挂载在刚刚创建的-mnt-boot目录" class="headerlink" title="3. 最后将boot分区挂载在刚刚创建的/mnt/boot目录"></a>3. 最后将boot分区挂载在刚刚创建的<code>/mnt/boot</code>目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;boot</span><br></pre></td></tr></table></figure><h2 id="6-开始安装系统"><a href="#6-开始安装系统" class="headerlink" title="6. 开始安装系统"></a>6. 开始安装系统</h2><h3 id="1-先配置软件源（推荐选择清华源）"><a href="#1-先配置软件源（推荐选择清华源）" class="headerlink" title="1. 先配置软件源（推荐选择清华源）"></a>1. 先配置软件源（推荐选择清华源）</h3><p>搜索<code>tuna</code>将其粘贴到文件第一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist</span><br></pre></td></tr></table></figure><h3 id="2-刷新一下"><a href="#2-刷新一下" class="headerlink" title="2. 刷新一下"></a>2. 刷新一下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syy</span><br></pre></td></tr></table></figure><h3 id="3-然后开始安装系统到-dev-sda1也就是挂载点-mnt"><a href="#3-然后开始安装系统到-dev-sda1也就是挂载点-mnt" class="headerlink" title="3. 然后开始安装系统到/dev/sda1也就是挂载点/mnt"></a>3. 然后开始安装系统到<code>/dev/sda1</code>也就是挂载点<code>/mnt</code></h3><p>其中必须安装的有<code>base</code> <code>linux</code> <code>linux-firmware</code>，推介也把<code>base-devel</code>安装上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap &#x2F;mnt base linux linux-firmware base-devel</span><br></pre></td></tr></table></figure><h3 id="4-安装完成之后需生成fstab文件"><a href="#4-安装完成之后需生成fstab文件" class="headerlink" title="4. 安装完成之后需生成fstab文件"></a>4. 安装完成之后需生成<code>fstab</code>文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab -U &#x2F;mnt &gt;&gt; &#x2F;mnt&#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure><h2 id="7-切换环境"><a href="#7-切换环境" class="headerlink" title="7. 切换环境"></a>7. 切换环境</h2><h3 id="1-切换到刚刚安装好的系统"><a href="#1-切换到刚刚安装好的系统" class="headerlink" title="1. 切换到刚刚安装好的系统"></a>1. 切换到刚刚安装好的系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot &#x2F;mnt</span><br></pre></td></tr></table></figure><h3 id="2-配置时区"><a href="#2-配置时区" class="headerlink" title="2. 配置时区"></a>2. 配置时区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</span><br></pre></td></tr></table></figure><h3 id="3-设置硬件时间"><a href="#3-设置硬件时间" class="headerlink" title="3. 设置硬件时间"></a>3. 设置硬件时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><h3 id="4-安装vim-我习惯了使用vim编辑"><a href="#4-安装vim-我习惯了使用vim编辑" class="headerlink" title="4. 安装vim(我习惯了使用vim编辑)"></a>4. 安装vim(我习惯了使用vim编辑)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S vim</span><br></pre></td></tr></table></figure><h3 id="5-设置语言"><a href="#5-设置语言" class="headerlink" title="5. 设置语言"></a>5. 设置语言</h3><h4 id="1-将-etc-locale-gen中en-US-UTF-8和zh-CN-UTF-8的注释去掉"><a href="#1-将-etc-locale-gen中en-US-UTF-8和zh-CN-UTF-8的注释去掉" class="headerlink" title="1. 将/etc/locale.gen中en_US.UTF-8和zh_CN.UTF-8的注释去掉"></a>1. 将/etc/locale.gen中<code>en_US.UTF-8</code>和<code>zh_CN.UTF-8</code>的注释去掉</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;locale.gen</span><br></pre></td></tr></table></figure><h4 id="2-然后生成一下"><a href="#2-然后生成一下" class="headerlink" title="2. 然后生成一下"></a>2. 然后生成一下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale-gen</span><br></pre></td></tr></table></figure><h4 id="3-配置-etc-locale-conf文件"><a href="#3-配置-etc-locale-conf文件" class="headerlink" title="3. 配置 /etc/locale.conf文件"></a>3. 配置 /etc/locale.conf文件</h4><p>在 <code>/etc/locale.conf</code>文件中写入<code>LANG=en_US.UTF-8</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo LANG&#x3D;en_US.UTF-8 &gt;&gt; &#x2F;etc&#x2F;locale.conf</span><br></pre></td></tr></table></figure><h3 id="6-设置root用户密码"><a href="#6-设置root用户密码" class="headerlink" title="6. 设置root用户密码"></a>6. 设置root用户密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><h3 id="7-安装网络相关的包"><a href="#7-安装网络相关的包" class="headerlink" title="7. 安装网络相关的包"></a>7. 安装网络相关的包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S iw wpa_supplicant dialog net-tools networkmanager dhcpcd</span><br></pre></td></tr></table></figure><p>设置网络工具开机自启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable NetworkManager</span><br><span class="line">systemctl enable dhcpcd</span><br></pre></td></tr></table></figure><h3 id="8-按装cpu编码"><a href="#8-按装cpu编码" class="headerlink" title="8. 按装cpu编码"></a>8. 按装cpu编码</h3><p>如果是<code>intel</code>cpu</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S intel-ucode</span><br></pre></td></tr></table></figure><p>如果是<code>amd</code>cpu</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S amd-ucode</span><br></pre></td></tr></table></figure><h3 id="9-安装引导"><a href="#9-安装引导" class="headerlink" title="9. 安装引导"></a>9. 安装引导</h3><p>注意第二条命令是你安装系统的盘符，如果你安装在<code>/dev/sdb</code>就填<code>/dev/sdb</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub</span><br><span class="line">grub-install &#x2F;dev&#x2F;sda</span><br><span class="line">grub-mkconfig -o &#x2F;boot&#x2F;grub&#x2F;grub.cfg</span><br></pre></td></tr></table></figure><h3 id="10-给你的系统取个名字"><a href="#10-给你的系统取个名字" class="headerlink" title="10. 给你的系统取个名字"></a>10. 给你的系统取个名字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo yourname &gt; &#x2F;etc&#x2F;hostname </span><br></pre></td></tr></table></figure><p><strong><em>到此系统就安装好了，先别急着退出，接下来开始安装桌面</em></strong></p><h2 id="8-开始按装kde-plasma"><a href="#8-开始按装kde-plasma" class="headerlink" title="8. 开始按装kde-plasma"></a>8. 开始按装kde-plasma</h2><h3 id="1-安装Xorg"><a href="#1-安装Xorg" class="headerlink" title="1. 安装Xorg"></a>1. 安装Xorg</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xorg</span><br></pre></td></tr></table></figure><h3 id="2-安装触摸板驱动"><a href="#2-安装触摸板驱动" class="headerlink" title="2. 安装触摸板驱动"></a>2. 安装触摸板驱动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xf86-input-synaptics</span><br></pre></td></tr></table></figure><h3 id="3-安装字体"><a href="#3-安装字体" class="headerlink" title="3. 安装字体"></a>3. 安装字体</h3><p>超级喜欢<code>dejavu</code>字体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S ttf-dejavu wqy-microhei</span><br></pre></td></tr></table></figure><h3 id="4-创建用户"><a href="#4-创建用户" class="headerlink" title="4. 创建用户"></a>4. 创建用户</h3><p>将新建用户移入<code>wheel</code>组并指定shell为<code>bash</code>(以后可修改)</p><p>kain 为我设置的用户，你们可以取别的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -G wheel -s &#x2F;bin&#x2F;bash kain</span><br></pre></td></tr></table></figure><p>为新用户设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd kain</span><br></pre></td></tr></table></figure><p>为新用户添加管理员权限（可以使用sudo命令）</p><p>将文件<code>/etc/sudoers</code>中的<code>wheel ALL=(ALL) ALL</code>那一行前面的注释去掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure><h3 id="5-开始安装桌面"><a href="#5-开始安装桌面" class="headerlink" title="5. 开始安装桌面"></a>5. 开始安装桌面</h3><h3 id="1-安装桌面及基本应用"><a href="#1-安装桌面及基本应用" class="headerlink" title="1. 安装桌面及基本应用"></a>1. 安装桌面及基本应用</h3><p>其中<code>plasma</code>是必须的<code>kde-applications</code>是一些常用软件包括终端和文件管理器等，还有许多小游戏（为了方便推荐安装上）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S plasma kde-applications</span><br></pre></td></tr></table></figure><h3 id="2-激活登录窗口sddm"><a href="#2-激活登录窗口sddm" class="headerlink" title="2. 激活登录窗口sddm"></a>2. 激活登录窗口<code>sddm</code></h3><p>sddm已经被包含进<code>plasma</code>中，无需另外安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable sddm</span><br></pre></td></tr></table></figure><h3 id="3-安装声音"><a href="#3-安装声音" class="headerlink" title="3. 安装声音"></a>3. 安装声音</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S alsa-utils pulseaudio pulseaudio-alsa</span><br></pre></td></tr></table></figure><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h3><p>解决kde中部分应用无法使用全局菜单栏的问题，需安装下面的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S libdbusmenu-glib</span><br></pre></td></tr></table></figure><p>到这里arch已经完全安装结束了</p><h2 id="9-退出当前环境"><a href="#9-退出当前环境" class="headerlink" title="9. 退出当前环境"></a>9. 退出当前环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><h2 id="10-卸载分区"><a href="#10-卸载分区" class="headerlink" title="10. 卸载分区"></a>10. 卸载分区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount -R &#x2F;mnt</span><br></pre></td></tr></table></figure><h2 id="11-重启"><a href="#11-重启" class="headerlink" title="11. 重启"></a>11. 重启</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>拔掉u盘</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-requests使用socks5代理</title>
      <link href="/2020/03/05/Python-request%E4%BD%BF%E7%94%A8socks5%E4%BB%A3%E7%90%86/"/>
      <url>/2020/03/05/Python-request%E4%BD%BF%E7%94%A8socks5%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装PySocks"><a href="#1-安装PySocks" class="headerlink" title="1. 安装PySocks"></a>1. 安装PySocks</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install PySocks -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure><h2 id="2-使用代理"><a href="#2-使用代理" class="headerlink" title="2. 使用代理"></a>2. 使用代理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> socks</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">socks.set_default_proxy(socks.SOCKS5, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1080</span>)</span><br><span class="line">socket.socket = socks.socksocket</span><br><span class="line">r = requests.get(url)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-pymongo使用</title>
      <link href="/2020/02/27/python-pymongo%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/02/27/python-pymongo%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="pymongo操作手册"><a href="#pymongo操作手册" class="headerlink" title="pymongo操作手册"></a>pymongo操作手册</h1><h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><ul><li><strong>方法一</strong>(推荐)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&quot;localhost&quot;</span>,port=<span class="number">27017</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>方法二</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&quot;mongodb://127.0.0.1:27017/&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="指定数据库"><a href="#指定数据库" class="headerlink" title="指定数据库"></a>指定数据库</h1><ul><li><strong>方法一</strong>(推荐)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db = client[<span class="string">&quot;dbName&quot;</span>]<span class="comment"># 指定dbName数据库</span></span><br></pre></td></tr></table></figure><ul><li><strong>方法二</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db &#x3D; client.test</span><br></pre></td></tr></table></figure><h1 id="指定集合"><a href="#指定集合" class="headerlink" title="指定集合"></a>指定集合</h1><ul><li><strong>方法一</strong>(推荐)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collection = db[<span class="string">&quot;colName&quot;</span>]<span class="comment"># 指定colName集合</span></span><br></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collection = db.colName</span><br></pre></td></tr></table></figure><h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><h2 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h2><blockquote><p>insert()方法可以插入一条或多条数据，返回主键<code>_id</code>或<code>_id</code>列表</p></blockquote><p><strong>插入一条数据示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">person_1 = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;kainhuck&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;boy&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hobby&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;python&quot;</span>, <span class="string">&quot;golang&quot;</span>, <span class="string">&quot;dart&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = collection.insert(person_1)</span><br><span class="line">print(ret)<span class="comment"># 输出: 5e575bc1601c0c6e37bbde3b</span></span><br></pre></td></tr></table></figure><p><strong>插入多条示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">person_1 = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;kainhuck&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;boy&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hobby&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;python&quot;</span>, <span class="string">&quot;golang&quot;</span>, <span class="string">&quot;dart&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">person_2 = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;kainhuck&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;boy&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hobby&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;python&quot;</span>, <span class="string">&quot;golang&quot;</span>, <span class="string">&quot;dart&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = collection.insert([person_1, person_2])</span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># 输出: [ObjectId(&#x27;5e575c417c310d22c0fda767&#x27;), ObjectId(&#x27;5e575c417c310d22c0fda768&#x27;)]</span></span><br></pre></td></tr></table></figure><p>但是现在官方已经不推荐使用该方法，而是使用下面两种方法</p><h2 id="insert-one"><a href="#insert-one" class="headerlink" title="insert_one()"></a>insert_one()</h2><blockquote><p>插入单条记录，返回InsertOneResult对象</p><p>通过 inserted_id 属性获取<code>_id</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">person_1 = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;kainhuck&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;boy&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hobby&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;python&quot;</span>, <span class="string">&quot;golang&quot;</span>, <span class="string">&quot;dart&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = collection.insert_one(person_1)</span><br><span class="line">print(ret)<span class="comment"># 输出: &lt;pymongo.results.InsertOneResult object at 0x7fbebae38b00&gt;</span></span><br><span class="line">print(ret.inserted_id)<span class="comment"># 输出: 5e575d179fd474694b4b0d76</span></span><br></pre></td></tr></table></figure><h2 id="insert-many"><a href="#insert-many" class="headerlink" title="insert_many()"></a>insert_many()</h2><blockquote><p>插入多条数据，返回InsertManyResult对象</p><p>通过 inserted_ids 属性获取<code>_id</code>列表</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">person_1 = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;kainhuck&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;boy&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hobby&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;python&quot;</span>, <span class="string">&quot;golang&quot;</span>, <span class="string">&quot;dart&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">person_2 = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;kainhuck&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;boy&quot;</span>,</span><br><span class="line">    <span class="string">&quot;hobby&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;python&quot;</span>, <span class="string">&quot;golang&quot;</span>, <span class="string">&quot;dart&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = collection.insert_many([person_1, person_2])</span><br><span class="line">print(ret)<span class="comment"># 输出: &lt;pymongo.results.InsertManyResult object at 0x7fc17e7a8d80&gt;</span></span><br><span class="line">print(ret.inserted_ids)</span><br><span class="line"><span class="comment"># 输出: [ObjectId(&#x27;5e575de663ea85cf36ac6083&#x27;), ObjectId(&#x27;5e575de663ea85cf36ac6084&#x27;)]</span></span><br></pre></td></tr></table></figure><h1 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h1><p>查询参数语法同 <code>MongoDB</code>语法</p><table><thead><tr><th>符号</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>$lt</code></td><td>小于</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$lt&#39;: 20&#125;&#125;</code></td></tr><tr><td><code>$gt</code></td><td>大于</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$gt&#39;: 20&#125;&#125;</code></td></tr><tr><td><code>$lte</code></td><td>小于等于</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$lte&#39;: 20&#125;&#125;</code></td></tr><tr><td><code>$gte</code></td><td>大于等于</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$gte&#39;: 20&#125;&#125;</code></td></tr><tr><td><code>$ne</code></td><td>不等于</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$ne&#39;: 20&#125;&#125;</code></td></tr><tr><td><code>$in</code></td><td>在范围内</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$in&#39;: [20, 23]&#125;&#125;</code></td></tr><tr><td><code>$nin</code></td><td>不在范围内</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$nin&#39;: [20, 23]&#125;&#125;</code></td></tr></tbody></table><p>另外，还可以进行正则匹配查询。例如，查询名字以M开头的学生数据，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results = collection.find(&#123;<span class="string">&#x27;name&#x27;</span>: &#123;<span class="string">&#x27;$regex&#x27;</span>: <span class="string">&#x27;^M.*&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这里使用<code>$regex</code>来指定正则匹配，<code>^M.*</code>代表以M开头的正则表达式。</p><p>这里将一些功能符号再归类为下表。</p><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>示例含义</th></tr></thead><tbody><tr><td><code>$regex</code></td><td>匹配正则表达式</td><td><code>&#123;&#39;name&#39;: &#123;&#39;$regex&#39;: &#39;^M.*&#39;&#125;&#125;</code></td><td><code>name</code>以M开头</td></tr><tr><td><code>$exists</code></td><td>属性是否存在</td><td><code>&#123;&#39;name&#39;: &#123;&#39;$exists&#39;: True&#125;&#125;</code></td><td><code>name</code>属性存在</td></tr><tr><td><code>$type</code></td><td>类型判断</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$type&#39;: &#39;int&#39;&#125;&#125;</code></td><td><code>age</code>的类型为<code>int</code></td></tr><tr><td><code>$mod</code></td><td>数字模操作</td><td><code>&#123;&#39;age&#39;: &#123;&#39;$mod&#39;: [5, 0]&#125;&#125;</code></td><td>年龄模5余0</td></tr><tr><td><code>$text</code></td><td>文本查询</td><td><code>&#123;&#39;$text&#39;: &#123;&#39;$search&#39;: &#39;Mike&#39;&#125;&#125;</code></td><td><code>text</code>类型的属性中包含<code>Mike</code>字符串</td></tr><tr><td><code>$where</code></td><td>高级条件查询</td><td><code>&#123;&#39;$where&#39;: &#39;obj.fans_count == obj.follows_count&#39;&#125;</code></td><td>自身粉丝数等于关注数</td></tr></tbody></table><h2 id="find-one"><a href="#find-one" class="headerlink" title="find_one()"></a>find_one()</h2><blockquote><p>返回一个结果，dict类型或者None</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">per = collection.find_one(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;kainhuck&quot;</span>&#125;)</span><br><span class="line">print(per)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># &#123;&#x27;_id&#x27;: ObjectId(&#x27;5e575bb73570a50e5dea473a&#x27;), &#x27;name&#x27;: &#x27;kainhuck&#x27;, &#x27;gender&#x27;: &#x27;boy&#x27;, &#x27;hobby&#x27;: [&#x27;python&#x27;, &#x27;golang&#x27;, &#x27;dart&#x27;]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h2><blockquote><p>返回多个结果，是一个迭代器</p><p>不加参数表示全部查询</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pers = collection.find(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;kainhuck&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> pers:</span><br><span class="line">    print(each)</span><br></pre></td></tr></table></figure><h2 id="count-documents"><a href="#count-documents" class="headerlink" title="count_documents()"></a>count_documents()</h2><blockquote><p>统计满足条件的个数</p><p>不加参数表示统计所有个数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count = collection.count_documents(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;kainhuck&quot;</span>&#125;)</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure><h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><blockquote><p>将返回结果按条件排序，返回迭代起</p><p>pymongo.ASCENDING   升序</p><p>pymongo.DESCENDING 降序</p><p>返回迭代器</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results = db.collection.find().sort(<span class="string">&#x27;name&#x27;</span>, pymongo.ASCENDING) <span class="comment"># 升序(默认)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results = db.collection.find().sort(<span class="string">&#x27;name&#x27;</span>, pymongo.DESCENDING)  <span class="comment">#降序</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多列排序</span></span><br><span class="line">results = db.collection.find().sort([</span><br><span class="line">  (<span class="string">&quot;name&quot;</span>, pymongo.ASCENDING),(<span class="string">&quot;age&quot;</span>, pymongo.DESCENDING)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h2 id="skip"><a href="#skip" class="headerlink" title="skip()"></a>skip()</h2><blockquote><p>跳过记录数</p><p>0 代表不跳过</p><p>返回迭代器</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results = collection.find().skip(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="limit"><a href="#limit" class="headerlink" title="limit()"></a>limit()</h2><blockquote><p>返回上限</p><p>0 代表无上限</p><p>返回迭代器</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results &#x3D; collection.find().limit(10)</span><br></pre></td></tr></table></figure><h1 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h1><p>查询参数语法同 <code>MongoDB</code>语法</p><h2 id="update-one"><a href="#update-one" class="headerlink" title="update_one()"></a>update_one()</h2><blockquote><p>修改单条文档，返回结果是UpdateResult类型</p><p>调用<code>matched_count</code>和<code>modified_count</code>属性分别获取匹配的条数和影响的条数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = collection.update_one(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;kainhuck&quot;</span>&#125;, &#123;<span class="string">&quot;$set&quot;</span>: &#123;<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;girl&quot;</span>&#125;&#125;)</span><br><span class="line">print(ret.matched_count)<span class="comment"># 输出: 1</span></span><br><span class="line">print(ret.modified_count)<span class="comment"># 输出: 1</span></span><br></pre></td></tr></table></figure><h2 id="update-many"><a href="#update-many" class="headerlink" title="update_many()"></a>update_many()</h2><blockquote><p>修改多条文档，返回结果是UpdateResult类型</p><p>调用<code>matched_count</code>和<code>modified_count</code>属性分别获取匹配的条数和影响的条数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = collection.update_many(&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;kainhuck&quot;</span>&#125;, &#123;<span class="string">&quot;$set&quot;</span>: &#123;<span class="string">&quot;gender&quot;</span>: <span class="string">&quot;girl&quot;</span>&#125;&#125;)</span><br><span class="line">print(ret.matched_count)<span class="comment"># 输出: 9</span></span><br><span class="line">print(ret.modified_count)<span class="comment"># 输出: 8</span></span><br></pre></td></tr></table></figure><h1 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h1><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><blockquote><p>删除指定条件的所有数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = db.collection.remove(&#123;<span class="string">&quot;age&quot;</span> : &#123;<span class="string">&quot;$gte&quot;</span> : <span class="number">10</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line">print(result)  <span class="comment"># &#123;&#x27;ok&#x27;: 3, &#x27;n&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure><h2 id="delete-one"><a href="#delete-one" class="headerlink" title="delete_one()"></a>delete_one()</h2><blockquote><p>删除第一条符合条件的数据，返回DeleteResult类型数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = collection.delete_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;kainhuck&#x27;</span>&#125;)</span><br><span class="line">print(result.deleted_count)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><h2 id="delete-many"><a href="#delete-many" class="headerlink" title="delete_many()"></a>delete_many()</h2><blockquote><p>删除所有符合条件的数据，返回DeleteResult类型数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = collection.delete_many(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;kainhuck&#x27;</span>&#125;)</span><br><span class="line">print(result.deleted_count)  <span class="comment"># 8</span></span><br></pre></td></tr></table></figure><p> <strong>其他方法</strong></p><ul><li><code>find_one_and_delete()</code> </li><li><code>find_one_and_replace()</code></li><li><code>find_one_and_update()</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb安装&amp;基本操作</title>
      <link href="/2020/02/27/mongodb%E5%AE%89%E8%A3%85-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/02/27/mongodb%E5%AE%89%E8%A3%85-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h1 id="一-安装"><a href="#一-安装" class="headerlink" title="一. 安装"></a>一. 安装</h1><p>这里展示使用<code>docker</code>安装<code>mongoDB</code></p><ul><li>拉取最新MongoDB镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mongo</span><br></pre></td></tr></table></figure><ul><li>运行容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name mongo -p 27017:27017 mongo --auth</span><br></pre></td></tr></table></figure><blockquote><p><strong>–auth</strong>：需要密码才能访问容器服务</p></blockquote><ul><li>为mongo添加用户和设置密码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docoker exec -it mongo mongo admin</span><br></pre></td></tr></table></figure><p><em>创建一个名为 admin，密码为 123456 的用户</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.createUser(&#123; user:&#39;admin&#39;,pwd:&#39;123456&#39;,roles:[ &#123; role:&#39;userAdminAnyDatabase&#39;, db: &#39;admin&#39;&#125;]&#125;);</span><br></pre></td></tr></table></figure><p><em>尝试使用上面创建的用户信息进行连接</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.auth(&#39;admin&#39;, &#39;123456&#39;)</span><br></pre></td></tr></table></figure><ul><li>进入mongo</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mongo mongo</span><br><span class="line">&gt; db.auth(&#39;admin&#39;, &#39;123456&#39;)</span><br></pre></td></tr></table></figure><h1 id="二-入门"><a href="#二-入门" class="headerlink" title="二. 入门"></a>二. 入门</h1><h2 id="1-了解基本概念"><a href="#1-了解基本概念" class="headerlink" title="1. 了解基本概念"></a>1. 了解基本概念</h2><table><thead><tr><th align="left">SQL术语/概念</th><th align="left">MongoDB术语/概念</th><th align="left">解释/说明</th></tr></thead><tbody><tr><td align="left">database</td><td align="left">database</td><td align="left">数据库</td></tr><tr><td align="left">table</td><td align="left">collection</td><td align="left">数据库表/集合</td></tr><tr><td align="left">row</td><td align="left">document</td><td align="left">数据记录行/文档</td></tr><tr><td align="left">column</td><td align="left">field</td><td align="left">数据字段/域</td></tr><tr><td align="left">index</td><td align="left">index</td><td align="left">索引</td></tr><tr><td align="left">table joins</td><td align="left"></td><td align="left">表连接,MongoDB不支持</td></tr><tr><td align="left">primary key</td><td align="left">primary key</td><td align="left">主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table><p>RDBMS 与 MongoDB 对应的术语：</p><table><thead><tr><th align="left">RDBMS</th><th align="left">MongoDB</th></tr></thead><tbody><tr><td align="left">数据库</td><td align="left">数据库</td></tr><tr><td align="left">表格</td><td align="left">集合</td></tr><tr><td align="left">行</td><td align="left">文档</td></tr><tr><td align="left">列</td><td align="left">字段</td></tr><tr><td align="left">表联合</td><td align="left">嵌入文档</td></tr><tr><td align="left">主键</td><td align="left">主键 (MongoDB 提供了 key 为 _id )</td></tr></tbody></table><p>下表为MongoDB中常用的几种数据类型。</p><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">String</td><td align="left">字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td></tr><tr><td align="left">Integer</td><td align="left">整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td></tr><tr><td align="left">Boolean</td><td align="left">布尔值。用于存储布尔值（真/假）。</td></tr><tr><td align="left">Double</td><td align="left">双精度浮点值。用于存储浮点值。</td></tr><tr><td align="left">Min/Max keys</td><td align="left">将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td></tr><tr><td align="left">Array</td><td align="left">用于将数组或列表或多个值存储为一个键。</td></tr><tr><td align="left">Timestamp</td><td align="left">时间戳。记录文档修改或添加的具体时间。</td></tr><tr><td align="left">Object</td><td align="left">用于内嵌文档。</td></tr><tr><td align="left">Null</td><td align="left">用于创建空值。</td></tr><tr><td align="left">Symbol</td><td align="left">符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td></tr><tr><td align="left">Date</td><td align="left">日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td></tr><tr><td align="left">Object ID</td><td align="left">对象 ID。用于创建文档的 ID。</td></tr><tr><td align="left">Binary Data</td><td align="left">二进制数据。用于存储二进制数据。</td></tr><tr><td align="left">Code</td><td align="left">代码类型。用于在文档中存储 JavaScript 代码。</td></tr><tr><td align="left">Regular expression</td><td align="left">正则表达式类型。用于存储正则表达式。</td></tr></tbody></table><h2 id="2-链接数据库"><a href="#2-链接数据库" class="headerlink" title="2. 链接数据库"></a>2. 链接数据库</h2><p><strong>uri</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodb:&#x2F;&#x2F;[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][&#x2F;[database][?options]]</span><br></pre></td></tr></table></figure><ul><li><strong>mongodb://</strong> 这是固定的格式，必须要指定。</li><li><strong>username:password@</strong> 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登陆这个数据库</li><li><strong>host1</strong> 必须的指定至少一个host, host1 是这个URI唯一要填写的。它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。</li><li><strong>portX</strong> 可选的指定端口，如果不填，默认为27017</li><li><strong>/database</strong> 如果指定username:password@，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库。</li><li><strong>?options</strong> 是连接选项。如果不使用/database，则前面需要加上/。所有连接选项都是键值对name=value，键值对之间通过&amp;或;（分号）隔开</li></ul><h2 id="3-基本语法"><a href="#3-基本语法" class="headerlink" title="3. 基本语法"></a>3. 基本语法</h2><h3 id="列出所有数据库"><a href="#列出所有数据库" class="headerlink" title="列出所有数据库"></a>列出所有数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure><p>注意：空数据库是不显示的</p><h3 id="查看当前所在数据库"><a href="#查看当前所在数据库" class="headerlink" title="查看当前所在数据库"></a>查看当前所在数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db</span><br></pre></td></tr></table></figure><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use DATABASE_NAME</span><br></pre></td></tr></table></figure><p>如果数据库不存在，则创建数据库，否则切换到指定数据库。</p><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(name, options)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>name: 要创建的集合名称</li><li>options: 可选参数, 指定有关内存大小及索引的选项</li></ul><p>options 可以是如下参数：</p><table><thead><tr><th align="left">字段</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">capped</td><td align="left">布尔</td><td align="left">（可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。 <strong>当该值为 true 时，必须指定 size 参数。</strong></td></tr><tr><td align="left">autoIndexId</td><td align="left">布尔</td><td align="left">（可选）如为 true，自动在 _id 字段创建索引。默认为 false。</td></tr><tr><td align="left">size</td><td align="left">数值</td><td align="left">（可选）为固定集合指定一个最大值，以千字节计（KB）。 <strong>如果 capped 为 true，也需要指定该字段。</strong></td></tr><tr><td align="left">max</td><td align="left">数值</td><td align="left">（可选）指定固定集合中包含文档的最大数量。</td></tr></tbody></table><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&quot;mycol&quot;, &#123; capped : true, autoIndexId : true, size : </span><br><span class="line">   6142800, max : 10000 &#125; )</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&quot;mycol&quot;)</span><br></pre></td></tr></table></figure><p><em>在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合。</em></p><h3 id="查看集合"><a href="#查看集合" class="headerlink" title="查看集合"></a>查看集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show collections</span><br></pre></td></tr></table></figure><h3 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.drop()</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><p>如果成功删除选定集合，则 drop() 方法返回 true，否则返回 false。</p><h3 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.insert(document)</span><br></pre></td></tr></table></figure><p>document是个json格式</p><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><h4 id="update"><a href="#update" class="headerlink" title="update()"></a>update()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>query</strong> : update的查询条件，类似sql update查询内where后面的。</li><li><strong>update</strong> : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</li><li><strong>upsert</strong> : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li><li><strong>multi</strong> : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li><li><strong>writeConcern</strong> :可选，抛出异常的级别。</li></ul><p><strong>例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.col.update(&#123;&#39;title&#39;:&#39;MongoDB 教程&#39;&#125;,&#123;$set:&#123;&#39;title&#39;:&#39;MongoDB&#39;&#125;&#125;,&#123;multi:true&#125;)</span><br></pre></td></tr></table></figure><h4 id="save"><a href="#save" class="headerlink" title="save()"></a>save()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.collection.save(</span><br><span class="line">   &lt;document&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>document</strong> : 文档数据。</li><li><strong>writeConcern</strong> :可选，抛出异常的级别。</li></ul><p>使用 db.col.save(document) 命令。如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。</p><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>query</strong> :（可选）删除的文档的条件。</li><li><strong>justOne</strong> : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</li><li><strong>writeConcern</strong> :（可选）抛出异常的级别。</li></ul><p>如果你只想删除第一条找到的记录可以设置 justOne 为 1，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)</span><br></pre></td></tr></table></figure><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(query, projection)</span><br></pre></td></tr></table></figure><ul><li><strong>query</strong> ：可选，使用查询操作符指定查询条件</li><li><strong>projection</strong> ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</li></ul><p>如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.col.find().pretty()</span><br></pre></td></tr></table></figure><p>除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档。</p><p><strong>MongoDB 与 RDBMS Where 语句比较</strong></p><p>如果你熟悉常规的 SQL 数据，通过下表可以更好的理解 MongoDB 的条件语句查询：</p><table><thead><tr><th align="left">操作</th><th align="left">格式</th><th align="left">范例</th><th align="left">RDBMS中的类似语句</th></tr></thead><tbody><tr><td align="left">等于</td><td align="left"><code>&#123;:</code>}</td><td align="left"><code>db.col.find(&#123;&quot;by&quot;:&quot;foo&quot;&#125;).pretty()</code></td><td align="left"><code>where by = &#39;foo&#39;</code></td></tr><tr><td align="left">小于</td><td align="left"><code>&#123;:&#123;$lt:&#125;&#125;</code></td><td align="left"><code>db.col.find(&#123;&quot;likes&quot;:&#123;$lt:50&#125;&#125;).pretty()</code></td><td align="left"><code>where likes &lt; 50</code></td></tr><tr><td align="left">小于或等于</td><td align="left"><code>&#123;:&#123;$lte:&#125;&#125;</code></td><td align="left"><code>db.col.find(&#123;&quot;likes&quot;:&#123;$lte:50&#125;&#125;).pretty()</code></td><td align="left"><code>where likes &lt;= 50</code></td></tr><tr><td align="left">大于</td><td align="left"><code>&#123;:&#123;$gt:&#125;&#125;</code></td><td align="left"><code>db.col.find(&#123;&quot;likes&quot;:&#123;$gt:50&#125;&#125;).pretty()</code></td><td align="left"><code>where likes &gt; 50</code></td></tr><tr><td align="left">大于或等于</td><td align="left"><code>&#123;:&#123;$gte:&#125;&#125;</code></td><td align="left"><code>db.col.find(&#123;&quot;likes&quot;:&#123;$gte:50&#125;&#125;).pretty()</code></td><td align="left"><code>where likes &gt;= 50</code></td></tr><tr><td align="left">不等于</td><td align="left"><code>&#123;:&#123;$ne:&#125;&#125;</code></td><td align="left"><code>db.col.find(&#123;&quot;likes&quot;:&#123;$ne:50&#125;&#125;).pretty()</code></td><td align="left"><code>where likes != 50</code></td></tr></tbody></table><p><strong>OR条件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.col.find(</span><br><span class="line">   &#123;</span><br><span class="line">      $or: [</span><br><span class="line">         &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">).pretty()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis.conf 配置文件解析</title>
      <link href="/2020/02/10/redis-conf-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/02/10/redis-conf-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="最重要三个配置"><a href="#最重要三个配置" class="headerlink" title="最重要三个配置"></a>最重要三个配置</h2><h3 id="1-bind-127-0-0-1"><a href="#1-bind-127-0-0-1" class="headerlink" title="1. bind 127.0.0.1"></a>1. bind 127.0.0.1</h3><p>需要注释掉这一行,使别的主机可以访问</p><h3 id="2-daemonize-no"><a href="#2-daemonize-no" class="headerlink" title="2. daemonize no"></a>2. daemonize no</h3><p>需要改为yes,使其后台运行</p><h3 id="3-requirepass-foobared"><a href="#3-requirepass-foobared" class="headerlink" title="3.  requirepass foobared"></a>3.  requirepass foobared</h3><p>为redis配置密码</p><h2 id="主要配置说明"><a href="#主要配置说明" class="headerlink" title="主要配置说明"></a>主要配置说明</h2><table><thead><tr><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td>daemonize no</td><td>Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td></tr><tr><td>pidfile /var/run/redis.pid</td><td>当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定</td></tr><tr><td>port 6379</td><td>指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</td></tr><tr><td>bind 127.0.0.1</td><td>绑定的主机地址</td></tr><tr><td>timeout 300</td><td>当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能</td></tr><tr><td>loglevel notice</td><td>指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td></tr><tr><td>logfile stdout</td><td>日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</td></tr><tr><td>databases 16</td><td>设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</td></tr><tr><td>save <seconds> <changes></td><td>Redis 默认配置文件中提供了三个条件： <code>save 900 1</code>  <code>save 300 10 </code>  <code>save 60 10000 </code>    分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td></tr><tr><td>rdbcompression yes</td><td>指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td></tr><tr><td>dbfilename dump.rdb</td><td>指定本地数据库文件名，默认值为 dump.rdb</td></tr><tr><td>dir ./</td><td>指定本地数据库存放目录</td></tr><tr><td>slaveof <masterip> <masterport></td><td>设置当本机为 slav 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td></tr><tr><td>masterauth <master-password></td><td>当 master 服务设置了密码保护时，slav 服务连接 master 的密码</td></tr><tr><td>requirepass foobared</td><td>设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭</td></tr><tr><td>maxclients 128</td><td>设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td></tr><tr><td>maxmemory <bytes></td><td>指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td></tr><tr><td>appendonly no</td><td>指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td></tr><tr><td>appendfilename appendonly.aof</td><td>指定更新日志文件名，默认为 appendonly.aof</td></tr><tr><td>appendfsync everysec</td><td>指定更新日志条件，共有 3 个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快）, always：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）, everysec：表示每秒同步一次（折中，默认值）</td></tr><tr><td>vm-enabled no</td><td>指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td></tr><tr><td>vm-swap-file /tmp/redis.swap</td><td>虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享</td></tr><tr><td>vm-max-memory 0</td><td>将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td></tr><tr><td>vm-page-size 32</td><td>Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td></tr><tr><td>vm-pages 134217728</td><td>设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td></tr><tr><td>vm-max-threads 4</td><td>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</td></tr><tr><td>glueoutputbuf yes</td><td>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td></tr><tr><td>hash-max-zipmap-entries 64</td><td>指定在超过一定的数量的元素时，采用一种特殊的哈希算法</td></tr><tr><td>hash-max-zipmap-value 512</td><td>指定在最大的元素超过某一临界值时，采用一种特殊的哈希算法</td></tr><tr><td>activerehashing yes</td><td>指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td></tr><tr><td>include /path/to/local.conf</td><td>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</td></tr></tbody></table><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis 常用操作</title>
      <link href="/2020/02/10/redis-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/02/10/redis-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="redis数据类型即操作"><a href="#redis数据类型即操作" class="headerlink" title="redis数据类型即操作"></a>redis数据类型即操作</h2><h3 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1. 字符串"></a>1. 字符串</h3><ul><li><p><strong>set</strong></p><p>设置字符串</p><p>格式: set key value</p><p>例子: set name kainhuck</p></li><li><p><strong>get</strong></p><p>获取字符串的值</p><p>格式: get key</p><p>例子: get name</p></li><li><p><strong>incr</strong></p><p>对值做加一操作</p><p>要求: 该字符串为数字字符串</p><p>格式: incr key</p><p>例子: incr age</p></li><li><p><strong>inrcby</strong></p><p>对值加指定值</p><p>要求: 该字符串为数字字符串</p><p>格式: incrby key num</p><p>例子: incrby age 50</p></li></ul><h3 id="2-hash"><a href="#2-hash" class="headerlink" title="2.hash"></a>2.hash</h3><p>类似Python中的字典</p><ul><li><p><strong>hset</strong></p><p>设置哈希的一组key和value</p><p>格式: hset hashname key value</p><p>例子: hset user:01 name kainhuck</p><p>例子: hset user:01 age 18</p></li><li><p><strong>hget</strong></p><p>获取哈希一组key对应的value</p><p>格式: hget hashname key</p><p>例子: hget user:01 name</p></li><li><p><strong>hmset</strong></p><p>设置哈希的多组key和value</p><p>格式: hmset hashname key1 value1 key2 value2 ….</p><p>例子: hmset user:01 name kainhuck age 18</p></li><li><p><strong>hmget</strong></p><p>获取哈希多组key对应的value</p><p>格式: hmget hashname key1 key2 …</p><p>例子: hmget user:01 name age</p></li><li><p><strong>hgetall</strong></p><p>获取哈希所有key对应的value</p><p>格式: hgetall hashname</p><p>例子: hgetall user:01</p></li></ul><h3 id="3-链表"><a href="#3-链表" class="headerlink" title="3.链表"></a>3.链表</h3><ul><li><p><strong>lpush</strong></p><p>从左边向链表添加元素</p><p>格式: lpush listname value</p><p>例子: lpush namelist kainhuck</p></li><li><p><strong>lrange</strong></p><p>获取链表中的数据</p><p>格式: lrange listname start end</p><p>格式: lrange namelist 0 -1</p></li><li><p><strong>rpush</strong></p><p>从右边向链表添加元素</p><p>格式: rpush listname value</p><p>例子: rpush namelist kainhuck</p></li><li><p><strong>ltrim</strong></p><p>截取链表,删除其他</p><p>格式: ltrim listname start end</p><p>例子: ltrim namelist 0 1</p></li><li><p><strong>lpop</strong></p><p>从左边将链表元素弹出</p><p>格式: lpop listname</p><p>例子: lpop namelist</p></li><li><p><strong>llen</strong></p><p>获取链表长度</p><p>格式: llen listname</p><p>例子: llen namelist</p></li></ul><h3 id="4-集合"><a href="#4-集合" class="headerlink" title="4.集合"></a>4.集合</h3><ul><li><p><strong>sadd</strong></p><p>向集合中添加元素</p><p>格式: sadd setname value</p><p>例子: sadd idset 1</p></li><li><p><strong>smembers</strong></p><p>获取集合元素</p><p>格式: smembers setname </p><p>例子: smembers idset</p></li><li><p><strong>sdiff</strong></p><p>获取集合差集(集合1中存在,集合2中不存在)</p><p>格式: sdiff setname1 setname2</p><p>例子: sdiff set1 set2</p></li><li><p><strong>sinter</strong></p><p>获取交集</p><p>格式: sdiff setname1 setname2</p><p>例子: sdiff set1 set2</p></li><li><p><strong>sunion</strong></p><p>获取并集</p><p>格式: sunion setname1 setname2</p><p>例子: sunion set1 set2</p></li><li><p><strong>scard</strong></p><p>获取集合中的元素个数</p><p>格式: scard setname</p><p>例子: scard set1</p></li></ul><h3 id="5-有序集合"><a href="#5-有序集合" class="headerlink" title="5.有序集合"></a>5.有序集合</h3><p>元素由两部分组成: 序号和值</p><p>取出有序集合里面的元素时,要根据序号排序,取出</p><ul><li><p><strong>zadd</strong></p><p>向有序集合中添加元素,默认是升序排列</p><p>格式: zadd zsetname number value</p><p>例子: zadd zset 10 kainhuck</p><p>例子: zadd zset 12 hahaha</p></li><li><p><strong>zrange</strong></p><p>按序号升序获取有序集合内容</p><p>格式: zrange zsetname start end</p><p>例子: zrange zset 0 -1</p></li><li><p><strong>zrevrange</strong></p><p>按序号降序获取有序集合内容</p><p>格式: zrevrange zsetname start end</p><p>例子: zrevrange zset 0 -1</p></li><li><p><strong>zcard</strong></p><p>获取有序集合长度</p><p>格式: zcard zsetname</p><p>例子: zcard zset</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux中由sda变sdb引起的问题解决</title>
      <link href="/2019/12/16/linux%E4%B8%AD%E7%94%B1sda%E5%8F%98sdb%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2019/12/16/linux%E4%B8%AD%E7%94%B1sda%E5%8F%98sdb%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>我的电脑有一个128G的固态以及一个500G的机械，我将系统安装在128G固态中，于是将500G的机械(<code>/dev/sdb</code>)挂在在<code>/home</code>目录下，安装完系统后执行<code>lsblk</code>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0 111.8G  0 disk </span><br><span class="line">├─sda1   8:1    0   103G  0 part /</span><br><span class="line">└─sda2   8:2    0   8.8G  0 part [SWAP]</span><br><span class="line">sdb      8:16   0 465.8G  0 disk </span><br><span class="line">└─sdb1   8:17   0 465.8G  0 part /home</span><br></pre></td></tr></table></figure><p>以下是我的<code>/etc/fstab</code>文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /etc/fstab: static file system information.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use <span class="string">&#x27;blkid&#x27;</span> to <span class="built_in">print</span> the universally unique identifier <span class="keyword">for</span> a device; this may</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> be used with UUID= as a more robust way to name devices that works even <span class="keyword">if</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> disks are added and removed. See fstab(5).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;file system&gt;             &lt;mount point&gt;  &lt;<span class="built_in">type</span>&gt;  &lt;options&gt;  &lt;dump&gt;  &lt;pass&gt;</span></span><br><span class="line">UUID=74ea269b-c104-4a07-87bc-e8857660d294 /              ext4    defaults,noatime,discard 0 1</span><br><span class="line">UUID=a9651492-6e3b-4105-9890-1382cd0f90c2 swap           swap    defaults,noatime,discard 0 2</span><br><span class="line">tmpfs                                     /tmp           tmpfs   defaults,noatime,mode=1777 0 0</span><br><span class="line">/dev/sdb1   /home          ext4    defaults                 1 2 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h1><p>在一次登录时发现，我的普通管理员用户不能登录系统，后用root用户登录后发现<code>/home</code>目录下并没有我的普通用户目录，相反我的<code>/homoe</code>目录下的内容与根目录下相同，执行<code>lsblk</code>命令后才意识到是我的<code>sda</code>与<code>sdb</code>交换了顺序，也就是当前将我的固态当成<code>sdb</code>挂载到了<code>/home</code>目录下，而原本的机械由于变成了<code>sda</code>而没有被挂载。而存在于我机械上的普通管理员目录也就没有被挂载，所以我的普通管理员就无法登录</p><h1 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h1><p>修改<code>/etc/fstab</code>文件，将原本要挂载的<code>/dev/sdb</code>换成对应的<code>UUID</code>即可（因为sda和sdb可能会变，而UUID是不会变的）。</p><p>通过命令<code>sudo blkid</code>查看对应设备的UUID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo blkid      </span><br><span class="line">[sudo] kain 的密码：</span><br><span class="line">/dev/sdb1: UUID=&quot;60bcf279-8ad3-4a7f-ac31-f423808fdd7c&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;eb3ed663-01&quot;</span><br><span class="line">/dev/sda1: UUID=&quot;74ea269b-c104-4a07-87bc-e8857660d294&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;e8799392-01&quot;</span><br><span class="line">/dev/sda2: UUID=&quot;a9651492-6e3b-4105-9890-1382cd0f90c2&quot; TYPE=&quot;swap&quot; PARTUUID=&quot;e8799392-02&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改后的<code>/etc/fstab</code>文件如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /etc/fstab: static file system information.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use <span class="string">&#x27;blkid&#x27;</span> to <span class="built_in">print</span> the universally unique identifier <span class="keyword">for</span> a device; this may</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> be used with UUID= as a more robust way to name devices that works even <span class="keyword">if</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> disks are added and removed. See fstab(5).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;file system&gt;             &lt;mount point&gt;  &lt;<span class="built_in">type</span>&gt;  &lt;options&gt;  &lt;dump&gt;  &lt;pass&gt;</span></span><br><span class="line">UUID=74ea269b-c104-4a07-87bc-e8857660d294 /              ext4    defaults,noatime,discard 0 1</span><br><span class="line">UUID=a9651492-6e3b-4105-9890-1382cd0f90c2 swap           swap    defaults,noatime,discard 0 2</span><br><span class="line">tmpfs                                     /tmp           tmpfs   defaults,noatime,mode=1777 0 0</span><br><span class="line">UUID=60bcf279-8ad3-4a7f-ac31-f423808fdd7c /home          ext4    defaults                 1 2 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tornado中的xsrf</title>
      <link href="/2019/10/16/tornado%E4%B8%AD%E7%9A%84xsrf/"/>
      <url>/2019/10/16/tornado%E4%B8%AD%E7%9A%84xsrf/</url>
      
        <content type="html"><![CDATA[<h1 id="XSRF"><a href="#XSRF" class="headerlink" title="XSRF"></a>XSRF</h1><p>XSRF即为<strong>跨站请求伪造</strong></p><p>这个漏洞利用了浏览器的一个允许恶意攻击者在受害者网站注入脚本使未授权请求代表一个已登录用户的安全漏洞。</p><h2 id="了解XSRF"><a href="#了解XSRF" class="headerlink" title="了解XSRF"></a>了解XSRF</h2><p>当一个网站的图片SRC属性为另一个网站的链接时，浏览器加载这个网站的这张图片时就会访问另一个网站。</p><h2 id="防范请求伪造"><a href="#防范请求伪造" class="headerlink" title="防范请求伪造"></a>防范请求伪造</h2><p>重要的请求尽可能使用post方法，但这并不是万能的，因为post方法也会被伪造（如HTML表单或XMLHTTPRequest API来向你的应用发送POST请求）。</p><p>为了防范伪造POST请求，我们会要求每个请求包括一个参数值作为令牌（token）来匹配存储在cookie中的对应值。我们的应用将通过一个cookie头和一个隐藏的HTML表单元素向页面提供令牌。当一个合法页面的表单被提交时，它将包括表单值和已存储的cookie。如果两者匹配，我们的应用认定请求有效。</p><p>由于第三方站点没有访问cookie数据的权限，他们将不能在请求中包含令牌cookie。这有效地防止了不可信网站发送未授权的请求。</p><h2 id="使用Tornado的XSRF保护"><a href="#使用Tornado的XSRF保护" class="headerlink" title="使用Tornado的XSRF保护"></a>使用Tornado的XSRF保护</h2><p>在setting中做如下设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">settings = &#123;</span><br><span class="line">    <span class="string">&quot;cookie_secret&quot;</span>: <span class="string">&quot;bZJc2sWbQLKos6GkHn/VB9oXwQt8S0R0kRvJ5/xJ89E=&quot;</span>,</span><br><span class="line">    <span class="string">&quot;xsrf_cookies&quot;</span>: <span class="literal">True</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个应用标识被设置时，Tornado将拒绝请求参数中不包含正确的_xsrf值的POST、PUT和DELETE请求。Tornado将会在幕后处理_xsrf cookies，但你必须在你的HTML表单中包含XSRF令牌以确保授权合法请求。要做到这一点，只需要在你的模板中包含一个xsrf_form_html调用即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/purchase&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br><span class="line">    &#123;% raw xsrf_form_html() %&#125;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;title&quot;</span> /&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;quantity&quot;</span> /&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;Check Out&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>实现原理</p><ol><li>为浏览器设置了一个名为_xsrf的安全cookie,这个cookie在关闭浏览器后会失效</li><li>为模板表单添加了一个隐藏域,名为_xsrf,值为_xsrf这个cookie的值</li></ol><h3 id="手动设置-xsrf的cookie"><a href="#手动设置-xsrf的cookie" class="headerlink" title="手动设置_xsrf的cookie"></a>手动设置_xsrf的cookie</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetXSRFCookieHandler</span>(<span class="params">RequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 设置_xsrf的cookie</span></span><br><span class="line">        self.xsrf_token</span><br><span class="line">        self.finish(<span class="string">&quot;ok&quot;</span>)</span><br></pre></td></tr></table></figure><p>为了让用户一访问就加载上，通常将其放在请求主页的Handler中，而一般将静态页面作为主页，所以在StaticHandler中添加即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义自己的StaticFileHandler</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticFileHandler</span>(<span class="params">StaticFileHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        super(StaticFileHandler, self).__init__(*args, **kwargs)</span><br><span class="line">        self.xsrf_token</span><br></pre></td></tr></table></figure><h2 id="XSRF令牌和AJAX请求"><a href="#XSRF令牌和AJAX请求" class="headerlink" title="XSRF令牌和AJAX请求"></a>XSRF令牌和AJAX请求</h2><p>AJAX请求也需要一个_xsrf参数，但不是必须显式地在渲染页面时包含一个_xsrf值，而是通过脚本在客户端查询浏览器获得cookie值。下面的两个函数透明地添加令牌值给AJAX POST请求。第一个函数通过名字获取cookie，而第二个函数是一个添加_xsrf参数到传递给postJSON函数数据对象的便捷函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="built_in">document</span>.cookie.match(<span class="string">&quot;\\b&quot;</span> + name + <span class="string">&quot;=([^;]*)\\b&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> c ? c[<span class="number">1</span>] : <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jQuery.postJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url, data, callback</span>) </span>&#123;</span><br><span class="line">    data._xsrf = getCookie(<span class="string">&quot;_xsrf&quot;</span>);</span><br><span class="line">    jQuery.ajax(&#123;</span><br><span class="line">        url: url,</span><br><span class="line">        data: jQuery.param(data),</span><br><span class="line">        dataType: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">        type: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        success: callback</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> tornado </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python深拷贝与浅拷贝</title>
      <link href="/2019/10/16/python%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2019/10/16/python%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><p><em>浅拷贝:只拷贝了一个地址,即和原变量指向同一个地址空间</em></p><p><em>深拷贝:复制了原变脸指向空间里的内容,并开辟了新的空间</em></p><p><strong>所有的等号赋值是浅拷贝</strong></p><p>深拷贝需要用到<code>copy</code>模块</p><p>深拷贝举例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">b = copy.deepcopy(a)</span><br><span class="line">print(<span class="string">&quot;a == b&quot;</span>, a == b)</span><br><span class="line">print(<span class="string">&quot;a is b&quot;</span>, a <span class="keyword">is</span> b)</span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D;&#x3D; b True</span><br><span class="line">a is b False</span><br></pre></td></tr></table></figure><p>几点说明:</p><p>deepcopy()函数是会递归深拷贝,即比如列表里面有列表会统统深拷贝</p><p>注意copy.copy()函数:</p><ol><li>如果拷贝的对象是个可变的则只对第一层深拷贝,</li><li>如果拷贝的对象是个不可变的(比如:元组)则进行浅拷贝</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*-coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]] <span class="comment">#原始对象</span></span><br><span class="line"> </span><br><span class="line">b = a                       <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)            <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)        <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"> </span><br><span class="line">a.append(<span class="number">5</span>)                 <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">&#x27;c&#x27;</span>)            <span class="comment">#修改对象a中的[&#x27;a&#x27;, &#x27;b&#x27;]数组对象</span></span><br><span class="line"> </span><br><span class="line">print( <span class="string">&#x27;a = &#x27;</span>, a )</span><br><span class="line">print( <span class="string">&#x27;b = &#x27;</span>, b )</span><br><span class="line">print( <span class="string">&#x27;c = &#x27;</span>, c )</span><br><span class="line">print( <span class="string">&#x27;d = &#x27;</span>, d )</span><br><span class="line">以上实例执行输出结果为：</span><br><span class="line"></span><br><span class="line">(<span class="string">&#x27;a = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>])</span><br><span class="line">(<span class="string">&#x27;b = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>])</span><br><span class="line">(<span class="string">&#x27;c = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]])</span><br><span class="line">(<span class="string">&#x27;d = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]])</span><br></pre></td></tr></table></figure><p>切片复制列表是深拷贝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">5</span>]: alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]                                                                         </span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: blist = alist                                                                             </span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: id(alist)                                                                                 </span><br><span class="line">Out[<span class="number">7</span>]: <span class="number">140069425918792</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: id(blist)                                                                                 </span><br><span class="line">Out[<span class="number">8</span>]: <span class="number">140069425918792</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: clist = alist[::]                                                                         </span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: id(clist)                                                                                </span><br><span class="line">Out[<span class="number">10</span>]: <span class="number">140069426299464</span></span><br></pre></td></tr></table></figure><p>字典拷贝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">38</span>]: a = &#123;<span class="number">1</span>:[<span class="number">1</span>,<span class="number">2</span>]&#125;                                                                        </span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: b = a.copy()                                                                         </span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: c = a.copy()                                                                         </span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: b[<span class="number">1</span>].append(<span class="number">3</span>)                                                                       </span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: a,b,c                                                                                </span><br><span class="line">Out[<span class="number">42</span>]: (&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: b[<span class="number">1</span>].append(<span class="string">&#x27;b&#x27;</span>)                                                                     </span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: a,b,c                                                                                </span><br><span class="line">Out[<span class="number">44</span>]: (&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>]&#125;)</span><br><span class="line">    </span><br><span class="line">--------------------------------------------------------------------------------------------    </span><br><span class="line">In [<span class="number">46</span>]: a = &#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;                                                                     </span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: b = copy.deepcopy(a)                                                                 </span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: a[<span class="number">1</span>].append(<span class="string">&#x27;a&#x27;</span>)                                                                     </span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: a,b                                                                                  </span><br><span class="line">Out[<span class="number">49</span>]: (&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br></pre></td></tr></table></figure><h2 id="在使用列表时的一些常见误区"><a href="#在使用列表时的一些常见误区" class="headerlink" title="在使用列表时的一些常见误区"></a>在使用列表时的一些常见误区</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists = [[]] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists</span><br><span class="line"> [[], [], []]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists</span><br><span class="line"> [[<span class="number">3</span>], [<span class="number">3</span>], [<span class="number">3</span>]]</span><br></pre></td></tr></table></figure><p>具体的原因在于 [[]] 是一个包含了一个空列表的单元素列表,所以 [[]] * 3 结果中的三个元素都是对这一个空列表的引用。修改 lists 中的任何一个元素实际上都是对这一个空列表的修改。你可以用以下方式创建以不同列表为元素的列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists[<span class="number">1</span>].append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists[<span class="number">2</span>].append(<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists</span><br><span class="line">[[<span class="number">3</span>], [<span class="number">5</span>], [<span class="number">7</span>]]</span><br></pre></td></tr></table></figure><p><strong>作为函数参数时</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to</span>(<span class="params">num, aList=[]</span>):</span></span><br><span class="line">    aList.append(num)</span><br><span class="line">    <span class="keyword">return</span> aList</span><br><span class="line"></span><br><span class="line">print(add_to(<span class="number">1</span>))    <span class="comment"># 输出 [1]</span></span><br><span class="line">print(add_to(<span class="number">2</span>))    <span class="comment"># 输出 [1, 2]</span></span><br><span class="line">print(add_to(<span class="number">3</span>))    <span class="comment"># 输出 [1, 2, 3]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to</span>(<span class="params">num, aList=[]</span>):</span></span><br><span class="line">    <span class="keyword">if</span> aList:</span><br><span class="line">        aList = []</span><br><span class="line">    aList.append(num)</span><br><span class="line">    <span class="keyword">return</span> aList</span><br><span class="line"></span><br><span class="line">print(add_to(<span class="number">1</span>))    <span class="comment"># 输出 [1]</span></span><br><span class="line">print(add_to(<span class="number">2</span>))    <span class="comment"># 输出 [2]</span></span><br><span class="line">print(add_to(<span class="number">3</span>))    <span class="comment"># 输出 [3]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
