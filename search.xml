<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Telegram Bot使用文档</title>
      <link href="/2020/09/01/Telegram-Bot%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
      <url>/2020/09/01/Telegram-Bot%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Telegram-Bot-使用文档"><a href="#Telegram-Bot-使用文档" class="headerlink" title="Telegram Bot 使用文档"></a>Telegram Bot 使用文档</h1><p><a href="https://core.telegram.org/bots/api">官方文档</a></p><h2 id="创建机器人"><a href="#创建机器人" class="headerlink" title="创建机器人"></a>创建机器人</h2><p>在telegram中我们可以通过和一个名为<code>BotFather</code>的机器人交互来申请我们自己的机器人，具体步骤如下</p><ol><li><p>添加BotFather为好友</p><p><a href="https://telegram.me/botfather">点击这里</a>添加botfather</p></li><li><p>打开和botfather的对话框发送 <code>/newbot</code></p><p>这一步过后botfather会提示你输入你要创建的机器人的名字，这个名字可以随意，是我们称呼它的名字</p></li><li><p>设置自定义机器人的名字（这个名字不同于上一步的名字，这个名字是唯一的）结尾必须是<code>_bot</code>或者<code>Bot</code>，不能包含中文, 标点符号</p></li><li><p>如果上一步执行成功那么botfather会返回该机器人的token，大概长这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123456789:ABCDEfghiJK4314daDSadSa7</span><br></pre></td></tr></table></figure><p>记住这个token,到这里机器人就创建好了</p></li></ol><h2 id="将机器人添加到群组里"><a href="#将机器人添加到群组里" class="headerlink" title="将机器人添加到群组里"></a>将机器人添加到群组里</h2><p>进入机器人信息页面，点击<code>更多</code>，点击<code>添加到群组</code>，选择一个群组即可</p><h2 id="获取群组chat-id"><a href="#获取群组chat-id" class="headerlink" title="获取群组chat_id"></a>获取群组chat_id</h2><p>通常来说我们都需要让机器人在一个群组里工作，所以首先我们需要将机器人添加到我们指定的群组，在群组里发送随意消息并@这个机器人，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello @your_bot</span><br></pre></td></tr></table></figure><p>然后浏览器打开这个链接，注意替换为你的token</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.telegram.org&#x2F;bot&lt;token&gt;&#x2F;getUpdates</span><br></pre></td></tr></table></figure><p>你看到的是一个json，格式如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ok&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;update_id&quot;</span>: <span class="number">414941268</span>,</span><br><span class="line">      <span class="attr">&quot;message&quot;</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;chat&quot;: &#123;</span><br><span class="line">          &quot;id&quot;: -465512321,</span><br><span class="line">          ...</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中找到chat.id这就是当前群组的id,以后发消息都是发到这个id.</p><h2 id="机器人发送请求"><a href="#机器人发送请求" class="headerlink" title="机器人发送请求"></a>机器人发送请求</h2><h3 id="请求接口"><a href="#请求接口" class="headerlink" title="请求接口"></a>请求接口</h3><p>telegram发送消息的方式类似与钉钉机器人，都是向一个api发送http请求，而且对于同一个API<code>telegram</code>支持<code>GET</code>和<code>POST</code>两种请求方式.请求的api格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.telegram.org&#x2F;bot&lt;token&gt;&#x2F;&lt;method&gt;</span><br></pre></td></tr></table></figure><p>其中token为你的机器人token，method为telegram给定的方法，在获取群组chat_id那一步就使用了telegram的其中一个方法(getUpdates),其他方法后面会介绍</p><h3 id="携带参数"><a href="#携带参数" class="headerlink" title="携带参数"></a>携带参数</h3><p>请求api时有些方法需要携带参数，telegram支持的传参方式/类型如下</p><ul><li>URL查询参数</li><li>application/x-www-form-urlencoded</li><li>application/json</li><li>multipart/form-data(上传文件使用这个content-type)</li></ul><h3 id="获取响应"><a href="#获取响应" class="headerlink" title="获取响应"></a>获取响应</h3><p>对于每次请求telegram都会有一个响应，响应的内容是一个json，格式如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ok&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中返回的result可以是telegram定义的对象或者是对象的列表</p><h2 id="telegram对象"><a href="#telegram对象" class="headerlink" title="telegram对象"></a>telegram对象</h2><p>telegram机器人的几乎所有操作都是一个一个对象的操作。</p><p>telegram定义了许多场景下的对象，<a href="https://core.telegram.org/bots/api#available-types">详见</a>，这里举例一些常见的</p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>该对象表示传入的更新，比如接收到用户发来的新消息，就会获得新的更新</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">update_id</td><td align="left">Integer</td><td align="left">更新的唯一标识符。 更新标识符从某个正数开始，并依次增加。 如果您使用的是Webhooks，则此ID变得尤为方便，因为它使您可以忽略重复的更新或在错误的情况下恢复正确的更新顺序。 如果至少有一个星期没有新更新，则将随机选择下一个更新的标识符，而不是顺序选择。</td></tr><tr><td align="left">message</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。任何形式的新传入消息-文本，照片，贴纸等。</td></tr><tr><td align="left">edited_message</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。机器人已知并已编辑的消息的新版本</td></tr><tr><td align="left">channel_post</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。任何形式的新传入频道帖子-文字，照片，贴纸等。</td></tr><tr><td align="left">edited_channel_post</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。机器人已知并已编辑的频道发布的新版本</td></tr><tr><td align="left">inline_query</td><td align="left"><a href="https://core.telegram.org/bots/api#inlinequery">InlineQuery</a></td><td align="left">可选的。新的传入内联查询</td></tr><tr><td align="left">chosen_inline_result</td><td align="left"><a href="https://core.telegram.org/bots/api#choseninlineresult">ChosenInlineResult</a></td><td align="left">可选的。用户选择并发送给其聊天伙伴的内联查询的结果。请参阅收集反馈的文档，以获取有关如何为您的机器人启用这些更新的详细信息。</td></tr><tr><td align="left">callback_query</td><td align="left"><a href="https://core.telegram.org/bots/api#callbackquery">CallbackQuery</a></td><td align="left">可选的。新传入的回调查询</td></tr><tr><td align="left">shipping_query</td><td align="left"><a href="https://core.telegram.org/bots/api#shippingquery">ShippingQuery</a></td><td align="left">可选的。新的收货查询。仅适用于价格灵活的发票</td></tr><tr><td align="left">pre_checkout_query</td><td align="left"><a href="https://core.telegram.org/bots/api#precheckoutquery">PreCheckoutQuery</a></td><td align="left">可选的。新的传入预结帐查询。包含有关结帐的完整信息</td></tr><tr><td align="left">poll</td><td align="left"><a href="https://core.telegram.org/bots/api#poll">Poll</a></td><td align="left">可选的。新的投票状态。机器人仅接收有关僵尸程序发送的有关已停止的投票和投票的更新</td></tr><tr><td align="left">poll_answer</td><td align="left"><a href="https://core.telegram.org/bots/api#poll_answer">PollAnswer</a></td><td align="left">可选的。用户在非匿名调查中更改了答案。僵尸程序仅在由僵尸程序本身发送的民意调查中才能获得新的选票。</td></tr></tbody></table><p>任何给定的更新中最多只能存在一个可选参数。</p><h3 id="User"><a href="#User" class="headerlink" title="User"></a>User</h3><p>该对象表示telegram的一个用户或者机器人</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">Integer</td><td align="left">该用户或机器人的唯一标识</td></tr><tr><td align="left">is_bot</td><td align="left">Boolean</td><td align="left">标识该用户是否是机器人，True如果是机器人</td></tr><tr><td align="left">first_name</td><td align="left">String</td><td align="left">用户或者机器人的first_name</td></tr><tr><td align="left">last_name</td><td align="left">String</td><td align="left">可选。用户或者机器人的last_name</td></tr><tr><td align="left">username</td><td align="left">String</td><td align="left">可选。用户或者机器人的username</td></tr><tr><td align="left">language_code</td><td align="left">String</td><td align="left">可选。用户语言的IETF语言标签</td></tr><tr><td align="left">can_join_groups</td><td align="left">Boolean</td><td align="left">可选。返回True如果该机器人可以被邀请加入群组，只在<code>getMe</code>方法返回</td></tr><tr><td align="left">can_read_all_group_message</td><td align="left">Boolean</td><td align="left">可选。返回True如果该机器人禁用了隐私模式，只在<code>getMe</code>方法返回</td></tr><tr><td align="left">supports_inline_queries</td><td align="left">Boolean</td><td align="left">可选。返回True，如果这个自持内联查询，只在<code>getMe</code>方法返回</td></tr></tbody></table><h3 id="Chat"><a href="#Chat" class="headerlink" title="Chat"></a>Chat</h3><p>该对象表示一个聊天信息</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">Integer</td><td align="left">该聊天的唯一标识符。 这个数字可能会大于32位但是一定小于52位所以编程时因指定<code>int64</code>类型</td></tr><tr><td align="left">type</td><td align="left">String</td><td align="left">聊天的类型，可以是 “private”, “group”, “supergroup” 或者 “channel”</td></tr><tr><td align="left">title</td><td align="left">String</td><td align="left">可选。 标题, 针对 supergroups, channels 和 group 类型的聊天</td></tr><tr><td align="left">username</td><td align="left">String</td><td align="left">可选。 Username, 针对 私有的聊天，如果可以的话也针对 supergroups 和 channels</td></tr><tr><td align="left">first_name</td><td align="left">String</td><td align="left">可选。 私人聊天中对方的first_name</td></tr><tr><td align="left">last_name</td><td align="left">String</td><td align="left">可选。私人聊天中对方的last_name</td></tr><tr><td align="left">photo</td><td align="left"><a href="https://core.telegram.org/bots/api#chatphoto">ChatPhoto</a></td><td align="left">可选。 聊天照片，只在<code>getChat</code>方法返回</td></tr><tr><td align="left">description</td><td align="left">String</td><td align="left">可选。 描述, 针对 groups, supergroups 和 channel 的聊天。只在<code>getChat</code>方法返回</td></tr><tr><td align="left">invite_link</td><td align="left">String</td><td align="left">可选。聊天的邀请链接, 针对 groups, supergroups 和 channel 的聊天。聊天中的每个管理员都会生成自己的邀请链接，因此机器人必须首先使用<code>exportChatInviteLink</code>生成链接。仅在<code>getChat</code>中返回。</td></tr><tr><td align="left">pinned_message</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选。固定信息，针对 groups, supergroups 和 channels。只在<code>getChat</code>方法中返回</td></tr><tr><td align="left">permissions</td><td align="left"><a href="https://core.telegram.org/bots/api#chatpermissions">ChatPermissions</a></td><td align="left">可选。默认的聊天成员权限, 针对 groups 和 supergroups。只在<code>getChat</code>方法中返回</td></tr><tr><td align="left">slow_mode_delay</td><td align="left">Integer</td><td align="left">可选。针对 supergroups, 每个非特权用户发送的连续消息之间允许的最小延迟。仅在<code>getChat</code>中返回。</td></tr><tr><td align="left">sticker_set_name</td><td align="left">String</td><td align="left">可选。针对 supergroups, 组贴纸集的名称。仅在getChat中返回。</td></tr><tr><td align="left">can_set_sticker_set</td><td align="left">Boolean</td><td align="left">可选。 返回True如果机器人可以改变group的贴纸集，只在<code>getChat</code>方法中返回。</td></tr></tbody></table><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>该对象代表一个消息</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">message_id</td><td align="left">Integer</td><td align="left">此聊天中的唯一消息标识符</td></tr><tr><td align="left">from</td><td align="left"><a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。发件人，对于发送到channels的消息为空</td></tr><tr><td align="left">date</td><td align="left">Integer</td><td align="left">发送时间（Unix时间）</td></tr><tr><td align="left">chat</td><td align="left"><a href="https://core.telegram.org/bots/api#chat">Chat</a></td><td align="left">消息所属的会话</td></tr><tr><td align="left">forward_from</td><td align="left"><a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。对于转发的消息，原始消息的发件人</td></tr><tr><td align="left">forward_from_chat</td><td align="left"><a href="https://core.telegram.org/bots/api#chat">Chat</a></td><td align="left">可选的。对于从频道转发的消息，有关原始频道的信息</td></tr><tr><td align="left">forward_from_message_id</td><td align="left">Integer</td><td align="left">可选的。对于从频道转发的消息，是频道中原始消息的标识符</td></tr><tr><td align="left">forward_signature</td><td align="left">String</td><td align="left">可选的。对于从频道转发的消息，作者的签名（如果有）</td></tr><tr><td align="left">forward_sender_name</td><td align="left">String</td><td align="left">可选的。从用户转发的信息的发件人名称，这些用户不允许在转发的信息中添加指向其帐户的链接</td></tr><tr><td align="left">forward_date</td><td align="left">Integer</td><td align="left">可选的。对于转发的消息，原始消息的发送日期（Unix时间）</td></tr><tr><td align="left">reply_to_message</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。对于答复，原始消息。请注意，即使此字段本身是答复，该字段中的Message对象也不会包含其他的reply_to_message字段。</td></tr><tr><td align="left">via_bot</td><td align="left"><a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。发送消息的机器人</td></tr><tr><td align="left">edit_date</td><td align="left">Integer</td><td align="left">可选的。消息最后一次编辑的日期（Unix时间）</td></tr><tr><td align="left">media_group_id</td><td align="left">String</td><td align="left">可选的。该消息所属的媒体消息组的唯一标识符</td></tr><tr><td align="left">author_signature</td><td align="left">String</td><td align="left">可选的。在频道中信息的作者签名</td></tr><tr><td align="left">text</td><td align="left">String</td><td align="left">可选的。对于文本消息，消息的实际UTF-8文本，0-4096个字符</td></tr><tr><td align="left">entities</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#messageentity">MessageEntity</a></td><td align="left">可选的。对于文本消息，出现在文本中的特殊实体，例如用户名，URL，机器人命令等。</td></tr><tr><td align="left">animation</td><td align="left"><a href="https://core.telegram.org/bots/api#animation">Animation</a></td><td align="left">可选的。消息是动画，有关动画的信息。为了向后兼容，设置此字段时，还将设置文档字段</td></tr><tr><td align="left">audio</td><td align="left"><a href="https://core.telegram.org/bots/api#audio">Audio</a></td><td align="left">可选的。消息是音频文件，有关该文件的信息</td></tr><tr><td align="left">document</td><td align="left"><a href="https://core.telegram.org/bots/api#document">Document</a></td><td align="left">可选的。消息是常规文件，有关文件的信息</td></tr><tr><td align="left">photo</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#photosize">PhotoSize</a></td><td align="left">可选的。消息是照片，照片的可用尺寸</td></tr><tr><td align="left">sticker</td><td align="left"><a href="https://core.telegram.org/bots/api#sticker">Sticker</a></td><td align="left">可选的。消息是贴纸，有关贴纸的信息</td></tr><tr><td align="left">video</td><td align="left"><a href="https://core.telegram.org/bots/api#video">Video</a></td><td align="left">可选的。消息是视频，有关视频的信息</td></tr><tr><td align="left">video_note</td><td align="left"><a href="https://core.telegram.org/bots/api#videonote">VideoNote</a></td><td align="left">可选的。消息是视频注释，有关视频消息的信息</td></tr><tr><td align="left">voice</td><td align="left"><a href="https://core.telegram.org/bots/api#voice">Voice</a></td><td align="left">可选的。消息是语音消息，有关文件的信息</td></tr><tr><td align="left">caption</td><td align="left">String</td><td align="left">可选的。动画，音频，文档，照片，视频或语音的标题，0-1024个字符</td></tr><tr><td align="left">caption_entities</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#messageentity">MessageEntity</a></td><td align="left">可选的。对于带有标题的消息，出现在标题中的特殊实体，例如用户名，URL，漫机器人命令等</td></tr><tr><td align="left">contact</td><td align="left"><a href="https://core.telegram.org/bots/api#contact">Contact</a></td><td align="left">可选的。消息是共享的联系人，有关该联系人的信息</td></tr><tr><td align="left">dice</td><td align="left"><a href="https://core.telegram.org/bots/api#dice">Dice</a></td><td align="left">可选的。消息是一个骰子，具有从1到6的随机值</td></tr><tr><td align="left">game</td><td align="left"><a href="https://core.telegram.org/bots/api#game">Game</a></td><td align="left">可选的。消息是一个游戏，有关游戏的信息。</td></tr><tr><td align="left">poll</td><td align="left"><a href="https://core.telegram.org/bots/api#poll">Poll</a></td><td align="left">可选的。消息是原生投票，有关投票的信息</td></tr><tr><td align="left">venue</td><td align="left"><a href="https://core.telegram.org/bots/api#venue">Venue</a></td><td align="left">可选的。消息是一个场地，有关该场地的信息。为了向后兼容，设置此字段时，还将设置位置字段</td></tr><tr><td align="left">location</td><td align="left"><a href="https://core.telegram.org/bots/api#location">Location</a></td><td align="left">可选的。消息是共享位置，有关位置的信息</td></tr><tr><td align="left">new_chat_members</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。添加到组或超组中的新成员以及有关它们的信息（机器人本身可能是这些成员之一）</td></tr><tr><td align="left">left_chat_member</td><td align="left"><a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。成员已从群组中删除，有关他们的信息（该成员可能是机器人本身）</td></tr><tr><td align="left">new_chat_title</td><td align="left">String</td><td align="left">可选的。聊天标题已更改为此值</td></tr><tr><td align="left">new_chat_photo</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#photosize">PhotoSize</a></td><td align="left">可选的。聊天照片已更改为此值</td></tr><tr><td align="left">delete_chat_photo</td><td align="left">True</td><td align="left">可选的。服务消息：聊天照片已删除</td></tr><tr><td align="left">group_chat_created</td><td align="left">True</td><td align="left">可选的。服务信息：组已创建</td></tr><tr><td align="left">supergroup_chat_created</td><td align="left">True</td><td align="left">可选的。 服务消息：超组已创建。 在通过更新发送的消息中无法接收到该字段，因为bot在创建时不能成为超组的成员。 仅当有人回复直接创建的超组中的第一条消息时，才可以在reply_to_message中找到该消息。</td></tr><tr><td align="left">channel_chat_created</td><td align="left">True</td><td align="left">可选的。 服务信息：频道已创建。 在通过更新发送的消息中无法接收到该字段，因为bot在创建时不能成为频道的成员。 如果有人回复频道中的第一条消息，则只能在reply_to_message中找到它。</td></tr><tr><td align="left">migrate_to_chat_id</td><td align="left">Integer</td><td align="left">可选的。 该组已迁移到具有指定标识符的超组。 此数字可能大于32位，并且某些编程语言在解释它时可能会有困难/无声的缺陷。 但是它小于52位，因此带符号的64位整数或双精度浮点类型对于存储此标识符是安全的。</td></tr><tr><td align="left">migrate_from_chat_id</td><td align="left">Integer</td><td align="left">可选的。 超级组已从具有指定标识的组中迁移。 此数字可能大于32位，并且某些编程语言在解释它时可能会有困难/无声的缺陷。 但是它小于52位，因此带符号的64位整数或双精度浮点类型对于存储此标识符是安全的。</td></tr><tr><td align="left">pinned_message</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。 指定的消息已固定。 请注意，即使该字段本身是答复，该字段中的Message对象也不会包含其他的reply_to_message字段。</td></tr><tr><td align="left">invoice</td><td align="left"><a href="https://core.telegram.org/bots/api#invoice">Invoice</a></td><td align="left">可选的。 消息是付款的发票，有关发票的信息。</td></tr><tr><td align="left">successful_payment</td><td align="left"><a href="https://core.telegram.org/bots/api#successfulpayment">SuccessfulPayment</a></td><td align="left">可选的。 消息是有关成功付款的服务消息，有关付款的信息。</td></tr><tr><td align="left">connected_website</td><td align="left">String</td><td align="left">可选的。 用户登录的网站的域名。</td></tr><tr><td align="left">passport_data</td><td align="left"><a href="https://core.telegram.org/bots/api#passportdata">PassportData</a></td><td align="left">可选的。 电报护照数据</td></tr><tr><td align="left">reply_markup</td><td align="left"><a href="https://core.telegram.org/bots/api#inlinekeyboardmarkup">InlineKeyboardMarkup</a></td><td align="left">可选的。 消息附带的嵌入式键盘。 login_url按钮表示为普通url按钮。</td></tr></tbody></table><h3 id="MessageEntity"><a href="#MessageEntity" class="headerlink" title="MessageEntity"></a>MessageEntity</h3><p>该对象表示文本消息中的一个特殊实体。例如，标签，用户名，URL等。</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">type</td><td align="left">String</td><td align="left">实体的类型。 可以是“mention”（@username），“hashtag”（#hashtag），“cashtag”（$ USD），“ bot_command”（/ start @ jobs_bot），“ URL”（<a href="https://telegram.org),“/">https://telegram.org），“</a> email”（<a href="mailto:&#x64;&#111;&#45;&#x6e;&#x6f;&#116;&#x2d;&#114;&#101;&#x70;&#108;&#121;&#64;&#x74;&#101;&#x6c;&#101;&#103;&#114;&#97;&#x6d;&#x2e;&#x6f;&#114;&#x67;">&#x64;&#111;&#45;&#x6e;&#x6f;&#116;&#x2d;&#114;&#101;&#x70;&#108;&#121;&#64;&#x74;&#101;&#x6c;&#101;&#103;&#114;&#97;&#x6d;&#x2e;&#x6f;&#114;&#x67;</a>），“phone_number”（+ 1-212-555-0123），“bold”（粗体），“italic”（斜体），“underline”（带下划线的文本） ），“strikethrough”（删除线文本），“code”（等宽字符串），“ pre”（等宽块），“ text_link”（对于可点击的文本URL），“ text_mention”（对于没有用户名的用户）</td></tr><tr><td align="left">offset</td><td align="left">Integer</td><td align="left">以UTF-16代码单位向实体开始的偏移量</td></tr><tr><td align="left">length</td><td align="left">Integer</td><td align="left">实体的长度（以UTF-16代码单元为单位）</td></tr><tr><td align="left">url</td><td align="left">String</td><td align="left">可选的。仅对于“ text_link”，用户点击文本后将打开的URL</td></tr><tr><td align="left">user</td><td align="left"><a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。仅针对“ text_mention”，提到的用户</td></tr><tr><td align="left">language</td><td align="left">String</td><td align="left">可选的。仅对于“ pre”，实体文本的编程语言</td></tr></tbody></table><h3 id="BotCommand"><a href="#BotCommand" class="headerlink" title="BotCommand"></a>BotCommand</h3><p>这个对象代表值一条机器人指令</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">command</td><td align="left">String</td><td align="left">命令文本，1-32个字符。只能包含小写英文字母，数字和下划线。</td></tr><tr><td align="left">description</td><td align="left">String</td><td align="left">命令说明，3-256个字符。</td></tr></tbody></table><h3 id="WebhookInfo"><a href="#WebhookInfo" class="headerlink" title="WebhookInfo"></a>WebhookInfo</h3><p>这个对象表示当前webhook的状态</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">String</td><td align="left">Webhook URL，如果未设置webhook，则可能为空</td></tr><tr><td align="left">has_custom_certificate</td><td align="left">Boolean</td><td align="left">如果为webhook证书检查提供了自定义证书则为真</td></tr><tr><td align="left">pending_update_count</td><td align="left">Integer</td><td align="left">等待交付的更新数量</td></tr><tr><td align="left">last_error_date</td><td align="left">Integer</td><td align="left">可选的。尝试通过Webhook传递更新时发生的最新错误的Unix时间</td></tr><tr><td align="left">last_error_message</td><td align="left">String</td><td align="left">可选的。尝试通过Webhook传递更新时发生的最新错误的人类可读格式的错误消息</td></tr><tr><td align="left">max_connections</td><td align="left">Integer</td><td align="left">可选的。与Webhook进行更新交付的同时HTTPS连接的最大允许数量</td></tr><tr><td align="left">allowed_updates</td><td align="left">Array of String</td><td align="left">可选的。机器人已订阅的更新类型的列表。默认为所有更新类型</td></tr></tbody></table><h3 id="ReplyKeyboardMarkup"><a href="#ReplyKeyboardMarkup" class="headerlink" title="ReplyKeyboardMarkup"></a>ReplyKeyboardMarkup</h3><p>该对象表示带有回复选项的自定义键盘</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">keyboard</td><td align="left">Array of Array of <a href="https://core.telegram.org/bots/api/#keyboardbutton">KeyboardButton</a></td><td align="left">按钮行数组，每个行由一个KeyboardButton对象数组表示</td></tr><tr><td align="left">resize_keyboard</td><td align="left">Boolean</td><td align="left">可选的。请求客户垂直调整键盘大小以达到最佳适合度（例如，如果只有两行按钮，则使键盘变小）。默认为false，在这种情况下，自定义键盘的高度始终与应用程序的标准键盘相同。</td></tr><tr><td align="left">one_time_keyboard</td><td align="left">Boolean</td><td align="left">可选的。要求客户在使用键盘后立即隐藏它。键盘仍然可用，但是客户端将在聊天中自动显示常用的字母键盘-用户可以在输入字段中按特殊按钮以再次查看自定义键盘。默认为false。</td></tr><tr><td align="left">selective</td><td align="left">Boolean</td><td align="left">可选的。如果只想向特定用户显示键盘，请使用此参数。目标：1）在Message对象的文本中@提及的用户； 2）如果机器人的消息是回复（具有reply_to_message_id），则为原始消息的发送者。 <br />示例：用户请求更改机器人的语言，机器人用键盘答复选择新语言的请求。群组中的其他用户看不到键盘。</td></tr></tbody></table><h3 id="KeyboardButton"><a href="#KeyboardButton" class="headerlink" title="KeyboardButton"></a>KeyboardButton</h3><p>该对象表示回复键盘的一个按钮。对于简单的文本按钮，可以使用<code>String</code>代替此对象来指定按钮的文本。可选字段<code>request_contact</code>，<code>request_location</code>和<code>request_poll</code>是互斥的。</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">String</td><td align="left">按钮的文字。如果未使用任何可选字段，则在按下按钮时它将作为消息发送</td></tr><tr><td align="left">request_contact</td><td align="left">Boolean</td><td align="left">可选的。如果为True，则按下该按钮时，用户的电话号码将作为联系人发送。仅在私人聊天中可用</td></tr><tr><td align="left">request_location</td><td align="left">Boolean</td><td align="left">可选的。如果为True，则在按下按钮时将发送用户的当前位置。仅在私人聊天中可用</td></tr><tr><td align="left">request_poll</td><td align="left"><a href="https://core.telegram.org/bots/api/#keyboardbuttonpolltype">KeyboardButtonPollType</a></td><td align="left">可选的。如果指定，则将要求用户创建一个民意调查，并在按下按钮时将其发送给机器人。仅在私人聊天中可用</td></tr></tbody></table><p><strong>注意</strong>：<em>request_contact</em>和<em>request_location</em>选项仅适用于2016年4月9日之后发布的电报版本。较旧的客户端将显示不受支持的消息。 </p><p><strong>注意</strong>：<em>request_poll</em>选项仅在2020年1月23日之后发布的电报版本中有效。旧客户端将显示不支持的消息。</p><h3 id="KeyboardButtonPollType"><a href="#KeyboardButtonPollType" class="headerlink" title="KeyboardButtonPollType"></a>KeyboardButtonPollType</h3><p>该对象表示民意调查的类型，可以在按下相应按钮时创建并发送该民意调查</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">type</td><td align="left">String</td><td align="left">可选的。如果通过了测验，将仅允许用户以测验模式创建民意测验。如果通过常规，则仅允许常规民意调查。否则，将允许用户创建任何类型的民意测验。</td></tr></tbody></table><h3 id="ReplyKeyboardRemove"><a href="#ReplyKeyboardRemove" class="headerlink" title="ReplyKeyboardRemove"></a>ReplyKeyboardRemove</h3><p>收到带有此对象的消息后，Telegram客户端将删除当前的自定义键盘并显示默认的字母键盘。默认情况下，将显示自定义键盘，直到机器人发送新键盘为止。一次性键盘的例外情况是用户按下按钮后立即隐藏的一次性键盘</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">remove_keyboard</td><td align="left">True</td><td align="left">请求客户端删除自定义键盘（用户将无法召唤此键盘；如果要隐藏键盘，但保持其可访问性，请在ReplyKeyboardMarkup中使用one_time_keyboard）</td></tr><tr><td align="left">selective</td><td align="left">Boolean</td><td align="left">可选的。如果仅要为特定用户卸下键盘，请使用此参数。目标：1）在Message对象的文本中@提及的用户； 2）如果漫游器的消息是回复（具有reply_to_message_id），则为原始消息的发送者。 示例：用户在投票中投票，机器人返回确认消息以回应投票，并删除该用户的键盘，同时仍向尚未投票的用户显示带有投票选项的键盘。</td></tr></tbody></table><h3 id="InlineKeyboardMarkup"><a href="#InlineKeyboardMarkup" class="headerlink" title="InlineKeyboardMarkup"></a>InlineKeyboardMarkup</h3><p>该对象表示一个嵌入式键盘，出现在其所属消息的旁边。</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">inline_keyboard</td><td align="left">Array of Array of <a href="https://core.telegram.org/bots/api/#inlinekeyboardbutton">InlineKeyboardButton</a></td><td align="left">按钮行数组，每个行由一个InlineKeyboardButton对象数组表示</td></tr></tbody></table><p><strong>注意</strong>：这仅适用于2016年4月9日之后发布的电报版本。较旧的客户端将显示不受支持的消息。</p><h3 id="InlineKeyboardButton"><a href="#InlineKeyboardButton" class="headerlink" title="InlineKeyboardButton"></a>InlineKeyboardButton</h3><p>此对象表示嵌入式键盘的一个按钮。您必须完全使用可选字段之一。</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">String</td><td align="left">在按钮上标记文本</td></tr><tr><td align="left">url</td><td align="left">String</td><td align="left">可选的。按下按钮时将打开HTTP或tg:// URL</td></tr><tr><td align="left">login_url</td><td align="left"><a href="https://core.telegram.org/bots/api/#loginurl">LoginUrl</a></td><td align="left">可选的。用于自动授权用户的HTTP URL。可以替代电报登录小部件。</td></tr><tr><td align="left">callback_data</td><td align="left">String</td><td align="left">可选的。按下按钮时要在回调查询中发送到bot的数据，1-64个字节</td></tr><tr><td align="left">switch_inline_query</td><td align="left">String</td><td align="left">可选的。如果已设置，则按下按钮将提示用户选择其聊天之一，打开该聊天并将bot的用户名和指定的内联查询插入输入字段。可以为空，在这种情况下，只会插入机器人的用户名。<br /><strong>注意</strong>：这为用户提供了一种简便的方法，使他们在当前与它进行私聊时以内联模式开始使用您的机器人。与switch_pm…操作结合使用时特别有用–在这种情况下，用户将自动返回到其切换到的聊天中，而跳过聊天选择屏幕。</td></tr><tr><td align="left">switch_inline_query_current_chat</td><td align="left">String</td><td align="left">可选的。如果已设置，则按下按钮会将bot的用户名和指定的嵌入式查询插入当前聊天的输入字段中。可以为空，在这种情况下，只会插入机器人的用户名。</td></tr><tr><td align="left">callback_game</td><td align="left"><a href="https://core.telegram.org/bots/api/#callbackgame">CallbackGame</a></td><td align="left">可选的。用户按下按钮时将启动的游戏的描述。<br /><strong>注意</strong>：此类型的按钮必须始终是第一行中的第一个按钮。</td></tr><tr><td align="left">pay</td><td align="left">Boolean</td><td align="left">可选的。指定True，发送付款按钮。 <br /><strong>注意</strong>：此类型的按钮必须始终是第一行中的第一个按钮。</td></tr></tbody></table><h3 id="ForceReply"><a href="#ForceReply" class="headerlink" title="ForceReply"></a>ForceReply</h3><p>收到带有该对象的消息后，Telegram客户端将向用户显示一个答复界面（就像用户选择了机器人的消息并点按“答复”一样）。如果您要创建用户友好的逐步界面而不必牺牲隐私模式，这将非常有用。</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">force_reply</td><td align="left">True</td><td align="left">向用户显示回复界面，就像他们手动选择了机器人的消息并点按“回复”一样</td></tr><tr><td align="left">selective</td><td align="left">Boolean</td><td align="left">可选的。如果只想强制特定用户答复，请使用此参数。目标：1）在Message对象的文本中@提及的用户； 2）如果漫游器的消息是回复（具有reply_to_message_id），则为原始消息的发送者。</td></tr></tbody></table><h2 id="telegram方法"><a href="#telegram方法" class="headerlink" title="telegram方法"></a>telegram方法</h2><p>telegram方法就是拼接在api后面的那串字符串，不区分大小写。<a href="https://core.telegram.org/bots/api#available-methods">详见</a>，这里只列举一些常用的，下面我所指的返回是指返回json中的result部分，其他章节提到的所有方法均可以在这一章节查阅</p><h3 id="getUpdates"><a href="#getUpdates" class="headerlink" title="getUpdates"></a>getUpdates</h3><ul><li><p>描述</p><p>获取更新，还有另外一种获取更新的方法(webhook)，两种方式不能共存</p></li><li><p>参数</p><p>无参数</p></li><li><p>返回</p><p><code>update</code>对象列表</p></li></ul><h3 id="setWebhook"><a href="#setWebhook" class="headerlink" title="setWebhook"></a>setWebhook</h3><ul><li><p>描述</p><p>使用此方法可以指定URL并通过传出的Webhook接收传入的更新。只要机器人有更新，telegram就会向指定的URL发送HTTPS POST请求，请求数据为json序列化后的<code>update</code>对象</p></li><li><p>参数</p><table><thead><tr><th align="left">Parameter</th><th align="left">Type</th><th align="left">Required</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">String</td><td align="left">Yes</td><td align="left">发送更新的https url。使用空字符串删除webhook集成</td></tr><tr><td align="left">certificate</td><td align="left"><a href="https://core.telegram.org/bots/api#inputfile">InputFile</a></td><td align="left">Optional</td><td align="left">上传您的公共密钥证书，以便可以检查正在使用的根证书。有关详细信息，请参见我们的<a href="https://core.telegram.org/bots/self-signed">自签名指南</a>。</td></tr><tr><td align="left">max_connections</td><td align="left">Integer</td><td align="left">Optional</td><td align="left">与Webhook进行更新交付的同时HTTPS连接的最大允许数量为1-100。默认值为40。使用较低的值可以限制bot服务器的负载，使用较高的值可以增加bot的吞吐量。</td></tr><tr><td align="left">allowed_updates</td><td align="left">Array of String</td><td align="left">Optional</td><td align="left">您希望机器人接收的更新类型的JSON序列化列表。 例如，指定[“ message”，“ edited_channel_post”，“ callback_query”]仅接收这些类型的更新。 请参阅更新以获取可用更新类型的完整列表。 指定一个空列表以接收所有更新，无论类型如何（默认）。 如果未指定，将使用以前的设置。<br />请注意，此参数不会影响调用setWebhook之前创建的更新，因此可能会在短时间内收到不需要的更新。</td></tr></tbody></table></li></ul><ul><li><p>返回</p><p>成功返回<code>True</code></p></li></ul><h3 id="deleteWebhook"><a href="#deleteWebhook" class="headerlink" title="deleteWebhook"></a>deleteWebhook</h3><ul><li><p>描述</p><p>删除设置的webhook</p></li><li><p>参数</p><p>无参数</p></li><li><p>返回</p><p>成功返回True</p></li></ul><h3 id="getWebhookInfo"><a href="#getWebhookInfo" class="headerlink" title="getWebhookInfo"></a>getWebhookInfo</h3><ul><li><p>描述</p><p>获取当前webhook的状态</p></li><li><p>参数</p><p>无参数</p></li><li><p>返回</p><p><code>WebhookInfo</code>对象</p><p>（如果没有设置webhook，则返回的对象中url为空）</p></li></ul><h3 id="getMe"><a href="#getMe" class="headerlink" title="getMe"></a>getMe</h3><ul><li><p>描述</p><p>获取机器人自身信息</p></li><li><p>参数</p><p>无参数</p></li><li><p>返回</p><p><code>user</code>对象</p></li></ul><h3 id="getChat"><a href="#getChat" class="headerlink" title="getChat"></a>getChat</h3><ul><li><p>描述</p><p>使用此方法可获取有关聊天的最新信息（一对一对话的用户的当前名称，用户的当前用户名，组或频道等）</p></li><li><p>参数</p><table><thead><tr><th align="left">Parameter</th><th align="left">Type</th><th align="left">Required</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">chat_id</td><td align="left">Integer or String</td><td align="left">Yes</td><td align="left">目标聊天或目标超级组或频道的用户名的唯一标识符（格式为@channelusername）</td></tr></tbody></table></li><li><p>返回</p><p><code>chat</code>对象</p></li></ul><h3 id="sendMessage"><a href="#sendMessage" class="headerlink" title="sendMessage"></a>sendMessage</h3><ul><li><p>描述</p><p>发送消息</p></li><li><p>参数</p><table><thead><tr><th align="left">Parameter</th><th align="left">Type</th><th align="left">Required</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">chat_id</td><td align="left">Integer or String</td><td align="left">Yes</td><td align="left">目标聊天（chat_id）或目标频道的用户名的唯一标识符（格式为@channelusername）</td></tr><tr><td align="left">text</td><td align="left">String</td><td align="left">Yes</td><td align="left">待发送消息的文本，实体解析后为1-4096个字符</td></tr><tr><td align="left">parse_mode</td><td align="left">String</td><td align="left">Optional</td><td align="left">消息文本中的实体解析模式。有关更多详细信息，请参见格式化选项。</td></tr><tr><td align="left">disable_web_page_preview</td><td align="left">Boolean</td><td align="left">Optional</td><td align="left">禁用此消息中链接的链接预览</td></tr><tr><td align="left">disable_notification</td><td align="left">Boolean</td><td align="left">Optional</td><td align="left">静默发送消息。用户将收到没有声音的通知。</td></tr><tr><td align="left">reply_to_message_id</td><td align="left">Integer</td><td align="left">Optional</td><td align="left">如果消息是答复，则为原始消息的ID</td></tr><tr><td align="left">reply_markup</td><td align="left"><a href="https://core.telegram.org/bots/api#inlinekeyboardmarkup">InlineKeyboardMarkup</a> or <a href="https://core.telegram.org/bots/api#replykeyboardmarkup">ReplyKeyboardMarkup</a> or <a href="https://core.telegram.org/bots/api#replykeyboardremove">ReplyKeyboardRemove</a> or <a href="https://core.telegram.org/bots/api#forcereply">ForceReply</a></td><td align="left">Optional</td><td align="left">其他界面选项。内联键盘，自定义回复键盘，删除回复键盘或强制用户回复的说明的JSON序列化对象。</td></tr></tbody></table></li><li><p>返回</p><p>刚刚发送的<code>message</code>对象</p></li></ul><h3 id="setMyCommands"><a href="#setMyCommands" class="headerlink" title="setMyCommands"></a>setMyCommands</h3><ul><li><p>描述</p><p>使用此方法可以更改机器人的命令列表</p></li><li><p>参数</p><table><thead><tr><th align="left">Parameter</th><th align="left">Type</th><th align="left">Required</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">commands</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#botcommand">BotCommand</a></td><td align="left">Yes</td><td align="left">将bot命令的JSON序列化列表设置为bot命令列表。最多可以指定100个命令。</td></tr></tbody></table></li><li><p>返回</p><p>成功返回<code>True</code></p></li></ul><h3 id="getMyCommands"><a href="#getMyCommands" class="headerlink" title="getMyCommands"></a>getMyCommands</h3><ul><li><p>描述</p><p>使用此方法获取机器人命令的当前列表</p></li><li><p>参数</p><p>无参数</p></li><li><p>返回</p><p><code>BotCommand</code>对象列表</p></li><li></li></ul><h2 id="格式化选项"><a href="#格式化选项" class="headerlink" title="格式化选项"></a>格式化选项</h2><p>格式化选项就是让我们的机器人以某种格式发送消息（比如markdown，或者html）</p><p>  Bot API支持消息的基本格式。您可以在机器人的消息中使用粗体，斜体，下划线和删除线文本，以及内联链接和预格式化的代码。电报客户端将相应地呈现它们。您可以使用markdown样式或HTML样式格式。</p><p>请注意，Telegram客户端将在打开内联链接（“打开此链接？”以及完整的URL）之前向用户显示警报。</p><p>如果满足以下限制，则可以嵌套消息实体：</p><ul><li>如果两个实体具有公共字符，则其中一个完全包含在另一个内部。</li><li>粗体，斜体，下划线和删除线实体可以包含并且要包含在任何其他实体中，但pre和code除外。</li><li>所有其他实体不能互相包含。</li></ul><p>链接<code>tg://user?id=&lt;user_id&gt;</code>可以用于通过用户ID提及用户，而无需使用用户名。请注意：</p><ul><li>这些链接仅在内联链接中使用时才有效。例如，当用于嵌入式键盘按钮或消息文本中时，它们将不起作用。</li><li>仅当用户过去联系过该机器人，通过内联按钮向该机器人发送了回调查询或成为提及该用户的组的成员时，才能保证这些提及有效。</li></ul><h3 id="MarkdownV2-style"><a href="#MarkdownV2-style" class="headerlink" title="MarkdownV2 style"></a>MarkdownV2 style</h3><p>要使用此模式，请在parse_mode字段中传递MarkdownV2。在您的消息中使用以下语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*bold \*</span>text<span class="emphasis">*</span></span><br><span class="line"><span class="emphasis">_italic \*</span>text<span class="emphasis">_</span></span><br><span class="line"><span class="emphasis"><span class="strong">__underline__</span></span></span><br><span class="line"><span class="emphasis">~strikethrough~</span></span><br><span class="line"><span class="emphasis">*bold _</span>italic bold ~italic bold strikethrough~ <span class="strong">__underline italic bold__</span><span class="emphasis">_ bold*</span></span><br><span class="line"><span class="emphasis">[<span class="string">inline URL</span>](<span class="link">http://www.example.com/</span>)</span></span><br><span class="line"><span class="emphasis">[<span class="string">inline mention of a user</span>](<span class="link">tg://user?id=123456789</span>)</span></span><br><span class="line"><span class="emphasis">`inline fixed-width code`</span></span><br><span class="line"><span class="emphasis">​```</span></span><br><span class="line"><span class="emphasis">pre-formatted fixed-width code block</span></span><br><span class="line"><span class="emphasis">​```</span></span><br><span class="line"><span class="emphasis">​```python</span></span><br><span class="line"><span class="emphasis">pre-formatted fixed-width code block written in the Python programming language</span></span><br><span class="line"><span class="emphasis">​```</span></span><br></pre></td></tr></table></figure><p>请注意：</p><ul><li>任何代码在1到126之间（含1和126）的字符都可以在任何带有’&#39;字符的位置转义，在这种情况下，它将被视为普通字符，而不是标记的一部分。</li><li>在pre和code实体内部，所有’`’和’\‘字符必须以前面的’\‘字符转义。</li><li>内联链接定义的内部(…)部分，所有’)’和’\‘必须以前面的’\‘字符转义</li><li>在其他所有地方这些字符 ‘_’, ‘*’, ‘[‘, ‘]’, ‘(‘, ‘)’, ‘~’, ‘`’, ‘&gt;’, ‘#’, ‘+’, ‘-‘, ‘=’, ‘|’, ‘{‘, ‘}’, ‘.’, ‘!’ 必须用前置’\‘转义</li><li>如果<code>斜体</code>和<code>下划线</code>之间存在歧义，<code>__</code>始终从左到右被视为<code>下划线</code>实体的开始或结尾，所以使用<code>___italic underline_\r__</code>代替<code>___italic underline___</code></li></ul><h3 id="HTML-style"><a href="#HTML-style" class="headerlink" title="HTML style"></a>HTML style</h3><p>要使用此模式，请在parse_mode字段中传递HTML。当前支持以下标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>bold<span class="tag">&lt;/<span class="name">b</span>&gt;</span>, <span class="tag">&lt;<span class="name">strong</span>&gt;</span>bold<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>italic<span class="tag">&lt;/<span class="name">i</span>&gt;</span>, <span class="tag">&lt;<span class="name">em</span>&gt;</span>italic<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>underline<span class="tag">&lt;/<span class="name">u</span>&gt;</span>, <span class="tag">&lt;<span class="name">ins</span>&gt;</span>underline<span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">s</span>&gt;</span>strikethrough<span class="tag">&lt;/<span class="name">s</span>&gt;</span>, <span class="tag">&lt;<span class="name">strike</span>&gt;</span>strikethrough<span class="tag">&lt;/<span class="name">strike</span>&gt;</span>, <span class="tag">&lt;<span class="name">del</span>&gt;</span>strikethrough<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>bold <span class="tag">&lt;<span class="name">i</span>&gt;</span>italic bold <span class="tag">&lt;<span class="name">s</span>&gt;</span>italic bold strikethrough<span class="tag">&lt;/<span class="name">s</span>&gt;</span> <span class="tag">&lt;<span class="name">u</span>&gt;</span>underline italic bold<span class="tag">&lt;/<span class="name">u</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> bold<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.example.com/&quot;</span>&gt;</span>inline URL<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;tg://user?id=123456789&quot;</span>&gt;</span>inline mention of a user<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span>inline fixed-width code<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>pre-formatted fixed-width code block<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span> <span class="attr">class</span>=<span class="string">&quot;language-python&quot;</span>&gt;</span>pre-formatted fixed-width code block written in the Python programming language<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请注意：</p><ul><li>当前仅支持上述标签。</li><li>所有不属于标记或HTML实体的<code>&lt;</code>，<code>&gt;</code>和<code>&amp;</code>符号必须替换为相应的HTML实体(<code>&lt;</code> 用 <code>&amp;lt;</code>， <code>&gt;</code> 用 <code>&amp;gt;</code>， <code>&amp;</code> 用 <code>&amp;amp;</code>)。</li><li>支持所有数字HTML实体。</li><li>该API当前仅支持以下命名的HTML实体： <code>&amp;lt;</code>, <code>&amp;gt;</code>, <code>&amp;amp;</code> and <code>&amp;quot;</code>。</li><li>使用嵌套的pre和code标签，为pre实体定义编程语言。</li><li>不能为独立code标签指定编程语言。</li></ul><h3 id="Markdown-style"><a href="#Markdown-style" class="headerlink" title="Markdown style"></a>Markdown style</h3><p>这是旧版模式，保留下来是为了向后兼容。要使用此模式，请在parse_mode字段中传递Markdown。在您的消息中使用以下语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*bold text*</span></span><br><span class="line"><span class="emphasis">_italic text_</span></span><br><span class="line">[<span class="string">inline URL</span>](<span class="link">http://www.example.com/</span>)</span><br><span class="line">[<span class="string">inline mention of a user</span>](<span class="link">tg://user?id=123456789</span>)</span><br><span class="line"><span class="code">`inline fixed-width code`</span></span><br><span class="line">​<span class="code">```</span></span><br><span class="line"><span class="code">pre-formatted fixed-width code block</span></span><br><span class="line"><span class="code">​```</span></span><br><span class="line">​<span class="code">```python</span></span><br><span class="line"><span class="code">pre-formatted fixed-width code block written in the Python programming language</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure><p>请注意：</p><ul><li>实体不得嵌套，而应使用解析模式<code>MarkdownV2</code>。</li><li>无法指定下划线和删除线实体，请改用解析模式<code>MarkdownV2</code>。</li><li>要在实体外部转义字符<code>_</code>，<code>*</code>，`，<code>[</code>，请在字符之前加上<code>\</code>。</li><li>不允许在实体内部转义，因此必须先关闭实体再重新打开：对于斜体使用<code>_snake_\__case_</code>，对于粗体<code>2*2=4</code>使用 <code>snake_case</code> 和 <code>*2*\**2=4*</code>。</li></ul><h2 id="telegram更新"><a href="#telegram更新" class="headerlink" title="telegram更新"></a>telegram更新</h2><p>telegram中更新指的是机器人是否有收到新的消息，具体有哪些消息可以查看<code>telegram对象</code>部分中的<code>Update</code>，获取更新的方式有两种1. 轮询，2.webhook</p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>这是一种主动询问的方式，这种方式比较简单但是效率欠佳，具体操作是，开发者每个一段时间请求一次<code>getUpdates</code>方法，从获取结果中判断update有无更新，有关<code>update</code>对象的描述可看<code>telegram对象</code>章节</p><h3 id="webhook"><a href="#webhook" class="headerlink" title="webhook"></a>webhook</h3><p>webhook可以理解为客户端给服务端的api,只要服务端一有更新就会主动将内容发送到客户端设置的一个api中，然后客户端收到消息后可做相应处理。</p><p><strong>给我们的机器人设置webhook</strong></p><p>通过<code>setWebhook</code>方法设置（前面有介绍），需要注意的是，telegram只支持<code>https</code>协议，所以我们的api服务器必须要有TLS证书，必须注意一但我们设置了webhook那么通过<code>getUpdates</code>方法将不起作用！</p><h2 id="telegram中的命令"><a href="#telegram中的命令" class="headerlink" title="telegram中的命令"></a>telegram中的命令</h2><p>通过命令来和机器人交互是电报机器人的一大特色，在telegram中命令由实体<code>BotCommand</code>表示（telegram对象那节已经介绍过）。</p><p>其实任何以<code>/</code>开头的连续英文消息都被视作命令(可以理解为这是一种具有格式的普通消息)，私聊或者在群里@机器人时发送<code>/</code>开头的信息可以查看实体类型为<code>bot_command</code>。要想让机器人收到某条命令后执行响应动作只需要判断发送的消息是否匹配我们约定的内容即刻，（从某种意义上讲无论发送的消息是否是命令格式我们都可以将其视为命令只要我们愿意），开发具有命令响应的过程总结如下：</p><ol><li>起一个死循环监听<code>update</code>的<code>message</code>消息，可以是轮询或者webhook方式</li><li>拿到<code>update.id</code>检查其是否更新，如有更新则取<code>message.Text</code>匹配已经定义好的<code>路由</code>（这是我定义的叫法，也就是我们约定的命令，事实上他的确和路由很像）</li><li>如果匹配成功，执行我们定义的方法，如果匹配失败则当做普通信息无视，或者返回对应信息</li></ol><p>从上面过程可以看出命令是否是<code>/</code>开头其实已经不那么重要了，那么为什么官方要定义<code>BotCommand</code>类呢，理由（优点）如下</p><ol><li>用以和普通消息区分</li><li>在聊天消息中命令会高亮显示</li><li>已经注册的命令在对话框中只需要输入<code>/</code>就会有提示列表</li></ol><h3 id="给机器人注册指令"><a href="#给机器人注册指令" class="headerlink" title="给机器人注册指令"></a>给机器人注册指令</h3><p><strong>手动注册</strong></p><ol><li><p>和<code>botFather</code>对话，输入<code>/mybot</code></p></li><li><p>选择要注册指令的机器人</p></li><li><p>选择<code>Edit Bot</code>选项</p></li><li><p>选择<code>Edit Commands</code></p></li><li><p>输入你想定义的命令，格式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 - 描述</span><br><span class="line">command2 - Description</span><br></pre></td></tr></table></figure><p>注意：注册时命令开头没有斜杠，使用命令时需要带上斜杠，中间用 <code>-</code> 分割；每一次的命令编辑都会覆盖之前的命令而不是追加，所以必须一次发送全部命令（在对话框中按<code>shift + enter</code>换行），另外命令不能使用驼峰命名法</p></li></ol><p><strong>通过<code>setMyCommands</code>方法注册</strong></p><ul><li>详见（telegram方法 setMyCommands）</li></ul><h3 id="查看已注册的指令"><a href="#查看已注册的指令" class="headerlink" title="查看已注册的指令"></a>查看已注册的指令</h3><ul><li>详见（telegram方法 getMyCommands）</li></ul><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><p>telegram建议我们的机器人都带上三条基本指令分别是</p><ul><li><code>/start</code></li><li><code>/help</code></li><li><code>/settings</code></li></ul><p>当设置了上面三个命令，用户首次打开与你的机器人的对话时，将看到<code>Start</code>按钮。机器人的个人资料页面上的菜单中将提供<code>Help</code>和<code>Settings</code>链接。</p><h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><p>telegram中键盘也是机器人的一大特色，开发者可以自定义自己的键盘，一个键盘相当于机器人的菜单可以理解为一个答复界面，可以更加方便的和机器人交互。</p><p>telegram中的键盘有四种<code>ReplyKeyboardMarkup</code>，<code>InlineKeyboardMarkup</code>，<code>ReplyKeyboardRemove</code>和<code>ForceReply</code>，这四个对象可参考前面的介绍</p><h3 id="创建键盘"><a href="#创建键盘" class="headerlink" title="创建键盘"></a>创建键盘</h3><p>只需要在<code>sendMessage</code>时指定<code>reply_markup</code>即可，详见<code>sendMessage</code>方法</p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> telegram </tag>
            
            <tag> bot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go get 私有库</title>
      <link href="/2020/09/01/go-get-%E7%A7%81%E6%9C%89%E5%BA%93/"/>
      <url>/2020/09/01/go-get-%E7%A7%81%E6%9C%89%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="go-get-私有库的方式"><a href="#go-get-私有库的方式" class="headerlink" title="go get 私有库的方式"></a>go get 私有库的方式</h2><ol><li><p>将本地的ssh公钥添加进私有git服务器</p></li><li><p>使用git协议拉取代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --add url.<span class="string">&quot;git@git.balabala.xxx:&quot;</span>.insteadOf <span class="string">&quot;https://git.balabala.xxx/&quot;</span>  </span><br></pre></td></tr></table></figure></li><li><p>设置GOPRIVATE环境变量为私有服务器地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPRIVATE=git.balabala.xxx/*</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议概述</title>
      <link href="/2020/08/16/HTTP%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/08/16/HTTP%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议概述"><a href="#HTTP协议概述" class="headerlink" title="HTTP协议概述"></a>HTTP协议概述</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>HTTP协议并不是什么高深的协议，相反正式因为HTTP协议足够简单所以它才会被广泛的使用。</p><h2 id="2-什么是协议"><a href="#2-什么是协议" class="headerlink" title="2. 什么是协议"></a>2. 什么是协议</h2><p>很多人不理解http协议其实是因为不理解<code>协议</code>或者说是自己将协议复杂化。其实协议很简单，就是一个约定。</p><p><strong>举个例子</strong></p><p>在你的电脑上有许多文件<code>1.txt 2.txt 3.txt ...</code>, 现在我想通过互联网来从你的电脑上获取这些文件。为了完成这一目的我们需要以下几步</p><ol><li><p>首先我需要在互联网上和你的电脑建立连接，为了保证传输的稳定性我们选择使用TCP协议（不理解TCP协议的同学，先简单的理解为负责传输我们数据的一种方式）来建立我们的连接。</p></li><li><p>建立连接后我发消息告诉你我想要的文件，你接收到我的消息后将对应的文件发送给我。</p><ul><li><p>这时就有一些问题，你的程序处理我发送消息是死板的，比如我发送<code>给我1.txt</code>和<code>把 1.txt 给我</code>对我来说都是一样的目的，但是你的程序解读时是不一样的。</p></li><li><p>为了解决这个问题我们必须统一我发送请求的格式，这样你的程序解读时就比较方便，因为有了固定的格式</p><p>比如我们约定如果我想获取你电脑上的文件我发送的请求格式就必须为<code>GET 文件名 \r\n</code>, 其中<code>GET</code>代表你这次的请求目的是<code>获取</code>，然后空一格写上你想要的文件名，最后用<code>\r\n</code> 代表请求结束</p></li><li><p>有了这种统一的约定就会很方便的实现一些功能</p></li></ul></li></ol><p>我们上面举的例子中的<code>约定</code>就是所谓的<code>协议</code></p><h2 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h2><p>HTTP的全称是<code>HyperText Transfer Protocol</code>中文叫做超文本传输协议，所谓的超文本其实就是<code>HTML</code>文件，把上面例子中的<code>txt文件</code>换成<code>html</code>文件，那么那就是HTTP的第一个版本(HTTP/0.9)，http是c/s模式的，从上面的例子我们可以看出<code>我</code>扮演的就是客户端,<code>你</code>扮演的就是服务端。其实随着http协议的发展其可以传送的文件类型几乎可以是任何类型</p><p><strong>为什么要叫html文件为超文本</strong></p><p>因为html文件里可以包含超链接（就是URL，他只是字符串，不要理解为超链接有特殊功能，哪些跳转功能都是浏览器实现的），它指向了网络中另外一处的资源，这样html可以组织互联网中的资源，可能是这样比较高级吧所以发明者称之为<code>超文本</code>。</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p><code>http/1.1</code>是http版本的一种，是标准化的协议，发布于1997年，时至今日<code>http/1.1</code>仍然是使用最广泛的协议。</p><p>在<code>HTTP/1.0</code>的时候引入了请求头的概念，我们可以通过设置请求头可能很方便的对HTTP协议进行拓展。</p><h3 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h3><p>http协议定义的请求格式由4个部分组成，分别是<code>请求行</code>，<code>请求头</code>，<code>空行</code>，<code>请求体</code></p><ul><li><p>请求行</p><p>指定请求的方法，路径，协议版本</p></li><li><p>请求头</p><p>以键值对的方式设置一些需要告诉服务端的其他信息，比如<code>User-Agent: Firefox</code>代表你的用户代理是Firefox</p></li><li><p>空行</p><p>就是普通的空行，分割上面的头部和下面的请求体</p></li><li><p>请求体</p><p>像<code>POST</code>这类方法需要发送而外的请求信息就会把要发送的数据放在请求体中</p></li></ul><h3 id="响应例子"><a href="#响应例子" class="headerlink" title="响应例子"></a>响应例子</h3><p>http协议定义的响应格式同请求格式类似，也是由四个部分组成：<code>响应行</code>，<code>响应头</code>，<code>空行</code>，<code>响应体</code></p><ul><li><p>响应行</p><p>http的版本，响应状态码，响应信息</p></li><li><p>响应头</p><p>以键值对的方式设置一些需要告诉客户端的其他信息，比如：<code>Content-Type: text/html</code>代表传给你的文件类型是html</p></li><li><p>空行</p><p>就是普通的空行，分割上面的头部和下面的响应体</p></li><li><p>响应体</p><p>客户端请求的数据将会放在响应体中返回</p></li></ul><p><strong>举个例子</strong></p><p>为了更好的阅读，在下面我会将<code>\r\n</code>（回车换行符）用折行来显示，比如</p><p><code>aaaaa \r\n bbb</code></p><p>显示为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaaaa</span><br><span class="line">bbb</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;GET &#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;Simple_header HTTP&#x2F;1.1</span><br><span class="line">&gt;Host: developer.mozilla.org</span><br><span class="line">&gt;User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko&#x2F;20100101 Firefox&#x2F;50.0</span><br><span class="line">&gt;Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">&gt;Accept-Language: en-US,en;q&#x3D;0.5</span><br><span class="line">&gt;Accept-Encoding: gzip, deflate, br</span><br><span class="line">&gt;Referer: https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;Simple_header</span><br><span class="line"></span><br><span class="line">&gt;HTTP&#x2F;1.1 200 OK</span><br><span class="line">&gt;Connection: Keep-Alive</span><br><span class="line">&gt;Content-Encoding: gzip</span><br><span class="line">&gt;Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">&gt;Date: Wed, 20 Jul 2016 10:55:30 GMT</span><br><span class="line">&gt;Etag: &quot;547fa7e369ef56031dd3bff2ace9fc0832eb251a&quot;</span><br><span class="line">&gt;Keep-Alive: timeout&#x3D;5, max&#x3D;1000</span><br><span class="line">&gt;Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT</span><br><span class="line">&gt;Server: Apache</span><br><span class="line">&gt;Transfer-Encoding: chunked</span><br><span class="line">&gt;Vary: Cookie, Accept-Encoding</span><br><span class="line"></span><br><span class="line">&gt;(content)</span><br></pre></td></tr></table></figure></blockquote><p>  <strong>解读</strong></p><ul><li>请求部分</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;Simple_header HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><p>GET方法</p><p>请求地址：/en-US/docs/Glossary/Simple_header</p><p>HTTP版本：HTTP/1.1</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host: developer.mozilla.org</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko&#x2F;20100101 Firefox&#x2F;50.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Referer: https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;Simple_header</span><br></pre></td></tr></table></figure><p>请求头部分，数据以键值对的方式存放，请求头中的key种类繁多，每种请求按需取用，这里代表的意思是</p><p>请求主机: developer.mozilla.org</p><p>用户代理（你是谁）：Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0</p><p>接受的类型（这个类型展开又可以讲很多）：text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8</p><p>接受的自然语言：en-US,en;q=0.5</p><p>接受的编码方式：gzip, deflate, br</p><p>从哪里跳转过来：<a href="https://developer.mozilla.org/en-US/docs/Glossary/Simple_header">https://developer.mozilla.org/en-US/docs/Glossary/Simple_header</a></p></blockquote><blockquote><p>由于这里GET请求没有没有携带而外参数，所以就没有请求体</p></blockquote><ul><li>响应部分</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br></pre></td></tr></table></figure><p>HTTP协议：HTTP/1.1</p><p>响应状态码: 200</p><p>响应状态描述: OK</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">Date: Wed, 20 Jul 2016 10:55:30 GMT</span><br><span class="line">Etag: &quot;547fa7e369ef56031dd3bff2ace9fc0832eb251a&quot;</span><br><span class="line">Keep-Alive: timeout&#x3D;5, max&#x3D;1000</span><br><span class="line">Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Vary: Cookie, Accept-Encoding</span><br></pre></td></tr></table></figure><p>响应头</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>空行</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(content)</span><br></pre></td></tr></table></figure><p>响应体内容</p></blockquote><h2 id="HTTP的特点"><a href="#HTTP的特点" class="headerlink" title="HTTP的特点"></a>HTTP的特点</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><p>http是比较简单的应用层协议，通过一些列请求方法来区分不同功能的请求，通过URL来在互联网上定位资源，通过头部来携带一些其他数据，通过Body来携带数据，而且HTTP/1.1及其之前的数据报都是可以阅读的。</p><h3 id="可拓展"><a href="#可拓展" class="headerlink" title="可拓展"></a>可拓展</h3><p>由于HTTP/1.0开始引入了头部概念，所以我们可以通过添加自己的头部信息来实现自定义的功能。</p><h3 id="无状态，有会话的"><a href="#无状态，有会话的" class="headerlink" title="无状态，有会话的"></a>无状态，有会话的</h3><p>从上面的例子可以看出每一次请求之间都是孤立的没有联系的，也就是说HTTP请求是无状态的，这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。为了解决这个问题，我们可以在头部加一个字段本质上取名可以任意，但是为了统一我们将这个字段的名称取为<code>Cookie</code>，我们把商品信息加入到这个字段中，然后每次请求都带上<code>Cookie</code>这个字段就实现了有状态的会话。</p><h2 id="HTTP-1-x的缺点"><a href="#HTTP-1-x的缺点" class="headerlink" title="HTTP/1.x的缺点"></a>HTTP/1.x的缺点</h2><p>HTTP是传输层上的应用层协议，最常见的传输层协议有两种<code>UDP</code>，<code>TCP</code>为了稳定起见，HTTP选择了TCP协议。但是建立TCP比较耗时，而且通常一个网页会同时会发起多个HTTP请求，由于HTTP/1.x不能复用一个TCP连接所以每个HTTP请求都会单独开一个TCP连接，这将非常低效。为了减轻这些缺陷，HTTP/1.1引入了流水线（被证明难以实现）和持久连接的概念：底层的TCP连接可以通过Connection头部来被部分控制。HTTP/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang中使用gRPC</title>
      <link href="/2020/07/18/golang%E4%B8%AD%E4%BD%BF%E7%94%A8gRPC/"/>
      <url>/2020/07/18/golang%E4%B8%AD%E4%BD%BF%E7%94%A8gRPC/</url>
      
        <content type="html"><![CDATA[<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC(Remote Procedure Call: 远程过程调用)是一个计算机通信协议，该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。</p><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>gRPC 一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。（<a href="http://doc.oschina.net/grpc%EF%BC%89">http://doc.oschina.net/grpc）</a></p><p>在 gRPC 里<em>客户端</em>应用可以像调用本地对象一样直接调用另一台不同的机器上<em>服务端</em>应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个<em>服务</em>，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个<em>存根</em>能够像服务端一样的方法。</p><p>gRPC 默认使用 <em>protocol buffers</em>，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）。</p><p>使用gRPC分为三步</p><ul><li>编写.proto文件</li><li>利用工具将.proto文件生成对应语言的代码</li><li>根据生成的代码编写服务端和客户端的代码</li></ul><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>首先我们需要安装将.proto文件生成对应代码的工具，下载地址（<a href="https://github.com/protocolbuffers/protobuf/releases%EF%BC%89%EF%BC%8C%E4%B8%8B%E8%BD%BD%E4%BD%A0%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%8D%B3%E5%8F%AF%E3%80%82%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%E8%A7%A3%E5%8E%8B%E5%B0%86%E5%85%B6bin%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%94%BE%E5%85%A5%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8D%B3%E5%8F%AF%E3%80%82">https://github.com/protocolbuffers/protobuf/releases），下载你对应操作系统的压缩包即可。下载完成后解压将其bin目录下的可执行文件放入环境变量中的文件夹即可。</a></p><p>此外，我们还需要安装对应语言的插件，比如</p><p>go语言插件安装方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go</span><br></pre></td></tr></table></figure><p>python插件安装方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install grpcio</span><br><span class="line">pip install protobuf</span><br><span class="line">pip install grpcio_tools</span><br></pre></td></tr></table></figure><p>接下来我将以一个例子来做演示介绍如何在go中使用gRPC,注意我将采用go module的方式来编写这个demo,</p><p>首先我们在一个你喜欢的文件夹下面新建一个文件夹命名为<code>hello_grpc</code>，然后在<code>hello_grpc</code>文件夹下新建一个go.mod文件并写入一下内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module <span class="string">&quot;hello_grpc&quot;</span></span><br></pre></td></tr></table></figure><p>然后用你喜欢的IDE打开这个文件夹，进行之后的操作</p><h2 id="1-编写-proto文件"><a href="#1-编写-proto文件" class="headerlink" title="1. 编写.proto文件"></a>1. 编写.proto文件</h2><p>我们在项目的根目录下新建名为<code>pb</code>的文件夹,然后新建名为<code>hello_grpc.proto</code>的文件，写入如下内容,这是一个官方的例子</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">service</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">option</span> go_package = &quot;.;hello_grpc&quot;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">service Greeter </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>其中第一行指定了我们使用 protocol buffers的版本</p><p>下面我们定义了包的名称，这将成为后面我们生成的go语言的代码的包名</p><p>然后我们定义了一个服务名为Greeter，其中定义了一个函数SayHello它的参数定义在HelloRequest，返回值定义在HelloReply</p><p>关于proto的服务，一共有4种类型，此例子中是最简单的一种</p><ul><li><p><em>简单 RPC</em> </p><p>客户端使用存根发送请求到服务器并等待响应返回，就像平常的函数调用一样。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> GetFeature(Point) <span class="keyword">returns</span> (Feature) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>服务器端流式 RPC</em> </p><p>客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。从例子中可以看出，通过在 <em>响应</em> 类型前插入 <code>stream</code> 关键字，可以指定一个服务器端的流方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>客户端流式 RPC</em> </p><p>客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦客户端完成写入消息，它等待服务器完成读取返回它的响应。通过在 <em>请求</em> 类型前指定 <code>stream</code> 关键字来指定一个客户端的流方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>双向流式 RPC</em></p><p>是双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器可以以任意喜欢的顺序读写：比如， 服务器可以在写入响应前等待接收所有的客户端消息，或者可以交替的读取和写入消息，或者其他读写的组合。 每个流中的消息顺序被预留。你可以通过在请求和响应前加 <code>stream</code> 关键字去制定方法的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-生成对应语言的代码"><a href="#2-生成对应语言的代码" class="headerlink" title="2. 生成对应语言的代码"></a>2. 生成对应语言的代码</h2><p>在我们项目的根目录下新建<code>service</code>目录（这将用来存放我们生成的golang代码），然后打开终端，输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I pb&#x2F; pb&#x2F;hello_grpc.proto --go_out&#x3D;plugins&#x3D;grpc:service</span><br></pre></td></tr></table></figure><p><code>-I</code> 后面指定proto文件存放目录，和proto文件 </p><p><code>--go_out=plugins=grpc:</code>后面指定生成go代码存放的目录</p><p>检查在service目录下是否成功生成一个名为<code>hello_grpc.pb.go</code>的文件</p><p>打开这个文件发现抱错，原因是我们的项目中还没有安装相应的包，输入以下命令安装</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> mod tidy</span><br></pre></td></tr></table></figure><h2 id="3-编写服务端和客户端的代码"><a href="#3-编写服务端和客户端的代码" class="headerlink" title="3.编写服务端和客户端的代码"></a>3.编写服务端和客户端的代码</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>在根目录下新建文件夹<code>server</code>然在这个文件夹下新建<code>server.go</code>，写入以下内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;hello_grpc/service&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc/reflection&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *service.HelloRequest)</span> <span class="params">(*service.HelloReply, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;service.HelloReply&#123;Message: <span class="string">&quot;hello &quot;</span> + in.Name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 监听本地端口</span></span><br><span class="line">lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;监听端口失败: %s&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建gRPC服务器</span></span><br><span class="line">s := grpc.NewServer()</span><br><span class="line"><span class="comment">// 注册服务</span></span><br><span class="line">service.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line"></span><br><span class="line">reflection.Register(s)</span><br><span class="line"></span><br><span class="line">err = s.Serve(lis)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;开启服务失败: %s&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里先定义了一个结构体，该结构体需要实现<code>GreeterServer</code>这个接口(见生成的代码，如下)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GreeterServer <span class="keyword">interface</span> &#123;</span><br><span class="line">SayHello(context.Context, *HelloRequest) (*HelloReply, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p>同理在项目根目录下新建<code>client/client.go</code>写入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;hello_grpc/service&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line">conn, err := grpc.Dial(<span class="string">&quot;:8080&quot;</span>, grpc.WithInsecure())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;连接服务端失败: %s&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个客户端</span></span><br><span class="line">c := service.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用服务端函数</span></span><br><span class="line">r, err := c.SayHello(context.Background(), &amp;service.HelloRequest&#123;Name: <span class="string">&quot;horika&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;调用服务端代码失败: %s&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;调用成功: %s&quot;</span>, r.Message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-运行"><a href="#4-运行" class="headerlink" title="4. 运行"></a>4. 运行</h2><ul><li><p>先运行服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run server&#x2F;server.go</span><br></pre></td></tr></table></figure></li><li><p>开新的终端运行客户端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run client/client.<span class="keyword">go</span></span><br></pre></td></tr></table></figure></li><li><p>观察客户端输出</p></li></ul><h2 id="5-番外篇：编写跨语言调用"><a href="#5-番外篇：编写跨语言调用" class="headerlink" title="5. 番外篇：编写跨语言调用"></a>5. 番外篇：编写跨语言调用</h2><p>以python为例，这里就不编写python的服务端了，直接编写python的客户端调用go的服务端</p><p>注意：你是否安装python的插件？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install grpcio</span><br><span class="line">pip install protobuf</span><br><span class="line">pip install grpcio_tools</span><br></pre></td></tr></table></figure><h3 id="生成python代码"><a href="#生成python代码" class="headerlink" title="生成python代码"></a>生成python代码</h3><p>在项目跟目录下新建文件夹<code>python</code>然后在根目录下打开终端输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I pb&#x2F; --python_out&#x3D;python&#x2F; --grpc_python_out&#x3D;python&#x2F; pb&#x2F;hello_grpc.proto</span><br></pre></td></tr></table></figure><p>在刚刚新建的文件夹下查看是否多出来了两个文件<code>hello_grpc_pb2.py</code>和<code>hello_grpc_pb2_grpc.py</code></p><h3 id="编写python客户端代码"><a href="#编写python客户端代码" class="headerlink" title="编写python客户端代码"></a>编写python客户端代码</h3><p>在python文件夹中新建client.py写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hello_grpc_pb2</span><br><span class="line"><span class="keyword">import</span> hello_grpc_pb2_grpc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">with</span> grpc.insecure_channel(<span class="string">&#x27;localhost:8080&#x27;</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = hello_grpc_pb2_grpc.GreeterStub(channel)</span><br><span class="line">        response = stub.SayHello(hello_grpc_pb2.HelloRequest(name=<span class="string">&#x27;horika&#x27;</span>))</span><br><span class="line">    print(<span class="string">&quot;调用成功: &#123;&#125;!&quot;</span>.format(response.message))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>运行go的服务端，然后运行python客户端查看输出</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
