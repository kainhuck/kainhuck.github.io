<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python-快速排序</title>
      <link href="/2020/09/01/python-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/09/01/python-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序算法流程"><a href="#快速排序算法流程" class="headerlink" title="快速排序算法流程"></a>快速排序算法流程</h2><ol><li>选定一个基准值(任意选,以第一个为例)</li><li>定义左右指针指向左右两端</li><li>左指针往右移动,如果遇到大于基准值的数就把它和右指针的值调换位置,然后左指针不动,右指针开始向左移动,如果遇到小于基准值的数就把他和左指针的值调换位置,然后开始移动左指针,以此类推,知道左右指针相遇</li><li>递归上述过程知道排序结束</li></ol><h2 id="用python实现"><a href="#用python实现" class="headerlink" title="用python实现"></a>用python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">intList: list</span>) -&gt; list:</span></span><br><span class="line">    <span class="comment"># 如果长度小于等于1就结束</span></span><br><span class="line">    <span class="keyword">if</span> len(intList) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> intList</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 将第一个值选为基准值</span></span><br><span class="line">    flag = intList[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 定义左右指针</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(intList) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> intList[i] &gt; flag:</span><br><span class="line">            intList[i], intList[right] = intList[right], intList[i]</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            intList[i], intList[left] = intList[left], intList[i]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 传列表的切片不会改变本身变量所以需要返回</span></span><br><span class="line">    leftList = quickSort(intList[:left])</span><br><span class="line">    rightList = quickSort(intList[left+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> leftList + [flag] + rightList</span><br></pre></td></tr></table></figure><h2 id="一行代码实现快排"><a href="#一行代码实现快排" class="headerlink" title="一行代码实现快排"></a>一行代码实现快排</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quick_sort = <span class="keyword">lambda</span> array: array <span class="keyword">if</span> len(array) &lt;= <span class="number">1</span> <span class="keyword">else</span> quick_sort([item <span class="keyword">for</span> item <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> item &lt;= array[<span class="number">0</span>]]) + [array[<span class="number">0</span>]] + quick_sort([item <span class="keyword">for</span> item <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> item &gt; array[<span class="number">0</span>]])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Telegram Bot使用文档</title>
      <link href="/2020/09/01/Telegram-Bot%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
      <url>/2020/09/01/Telegram-Bot%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Telegram-Bot-使用文档"><a href="#Telegram-Bot-使用文档" class="headerlink" title="Telegram Bot 使用文档"></a>Telegram Bot 使用文档</h1><p><a href="https://core.telegram.org/bots/api">官方文档</a></p><h2 id="创建机器人"><a href="#创建机器人" class="headerlink" title="创建机器人"></a>创建机器人</h2><p>在telegram中我们可以通过和一个名为<code>BotFather</code>的机器人交互来申请我们自己的机器人，具体步骤如下</p><ol><li><p>添加BotFather为好友</p><p><a href="https://telegram.me/botfather">点击这里</a>添加botfather</p></li><li><p>打开和botfather的对话框发送 <code>/newbot</code></p><p>这一步过后botfather会提示你输入你要创建的机器人的名字，这个名字可以随意，是我们称呼它的名字</p></li><li><p>设置自定义机器人的名字（这个名字不同于上一步的名字，这个名字是唯一的）结尾必须是<code>_bot</code>或者<code>Bot</code>，不能包含中文, 标点符号</p></li><li><p>如果上一步执行成功那么botfather会返回该机器人的token，大概长这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123456789:ABCDEfghiJK4314daDSadSa7</span><br></pre></td></tr></table></figure><p>记住这个token,到这里机器人就创建好了</p></li></ol><h2 id="将机器人添加到群组里"><a href="#将机器人添加到群组里" class="headerlink" title="将机器人添加到群组里"></a>将机器人添加到群组里</h2><p>进入机器人信息页面，点击<code>更多</code>，点击<code>添加到群组</code>，选择一个群组即可</p><h2 id="获取群组chat-id"><a href="#获取群组chat-id" class="headerlink" title="获取群组chat_id"></a>获取群组chat_id</h2><p>通常来说我们都需要让机器人在一个群组里工作，所以首先我们需要将机器人添加到我们指定的群组，在群组里发送随意消息并@这个机器人，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello @your_bot</span><br></pre></td></tr></table></figure><p>然后浏览器打开这个链接，注意替换为你的token</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.telegram.org&#x2F;bot&lt;token&gt;&#x2F;getUpdates</span><br></pre></td></tr></table></figure><p>你看到的是一个json，格式如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ok&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;update_id&quot;</span>: <span class="number">414941268</span>,</span><br><span class="line">      <span class="attr">&quot;message&quot;</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;chat&quot;: &#123;</span><br><span class="line">          &quot;id&quot;: -465512321,</span><br><span class="line">          ...</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中找到chat.id这就是当前群组的id,以后发消息都是发到这个id.</p><h2 id="机器人发送请求"><a href="#机器人发送请求" class="headerlink" title="机器人发送请求"></a>机器人发送请求</h2><h3 id="请求接口"><a href="#请求接口" class="headerlink" title="请求接口"></a>请求接口</h3><p>telegram发送消息的方式类似与钉钉机器人，都是向一个api发送http请求，而且对于同一个API<code>telegram</code>支持<code>GET</code>和<code>POST</code>两种请求方式.请求的api格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.telegram.org&#x2F;bot&lt;token&gt;&#x2F;&lt;method&gt;</span><br></pre></td></tr></table></figure><p>其中token为你的机器人token，method为telegram给定的方法，在获取群组chat_id那一步就使用了telegram的其中一个方法(getUpdates),其他方法后面会介绍</p><h3 id="携带参数"><a href="#携带参数" class="headerlink" title="携带参数"></a>携带参数</h3><p>请求api时有些方法需要携带参数，telegram支持的传参方式/类型如下</p><ul><li>URL查询参数</li><li>application/x-www-form-urlencoded</li><li>application/json</li><li>multipart/form-data(上传文件使用这个content-type)</li></ul><h3 id="获取响应"><a href="#获取响应" class="headerlink" title="获取响应"></a>获取响应</h3><p>对于每次请求telegram都会有一个响应，响应的内容是一个json，格式如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ok&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中返回的result可以是telegram定义的对象或者是对象的列表</p><h2 id="telegram对象"><a href="#telegram对象" class="headerlink" title="telegram对象"></a>telegram对象</h2><p>telegram机器人的几乎所有操作都是一个一个对象的操作。</p><p>telegram定义了许多场景下的对象，<a href="https://core.telegram.org/bots/api#available-types">详见</a>，这里举例一些常见的</p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>该对象表示传入的更新，比如接收到用户发来的新消息，就会获得新的更新</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">update_id</td><td align="left">Integer</td><td align="left">更新的唯一标识符。 更新标识符从某个正数开始，并依次增加。 如果您使用的是Webhooks，则此ID变得尤为方便，因为它使您可以忽略重复的更新或在错误的情况下恢复正确的更新顺序。 如果至少有一个星期没有新更新，则将随机选择下一个更新的标识符，而不是顺序选择。</td></tr><tr><td align="left">message</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。任何形式的新传入消息-文本，照片，贴纸等。</td></tr><tr><td align="left">edited_message</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。机器人已知并已编辑的消息的新版本</td></tr><tr><td align="left">channel_post</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。任何形式的新传入频道帖子-文字，照片，贴纸等。</td></tr><tr><td align="left">edited_channel_post</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。机器人已知并已编辑的频道发布的新版本</td></tr><tr><td align="left">inline_query</td><td align="left"><a href="https://core.telegram.org/bots/api#inlinequery">InlineQuery</a></td><td align="left">可选的。新的传入内联查询</td></tr><tr><td align="left">chosen_inline_result</td><td align="left"><a href="https://core.telegram.org/bots/api#choseninlineresult">ChosenInlineResult</a></td><td align="left">可选的。用户选择并发送给其聊天伙伴的内联查询的结果。请参阅收集反馈的文档，以获取有关如何为您的机器人启用这些更新的详细信息。</td></tr><tr><td align="left">callback_query</td><td align="left"><a href="https://core.telegram.org/bots/api#callbackquery">CallbackQuery</a></td><td align="left">可选的。新传入的回调查询</td></tr><tr><td align="left">shipping_query</td><td align="left"><a href="https://core.telegram.org/bots/api#shippingquery">ShippingQuery</a></td><td align="left">可选的。新的收货查询。仅适用于价格灵活的发票</td></tr><tr><td align="left">pre_checkout_query</td><td align="left"><a href="https://core.telegram.org/bots/api#precheckoutquery">PreCheckoutQuery</a></td><td align="left">可选的。新的传入预结帐查询。包含有关结帐的完整信息</td></tr><tr><td align="left">poll</td><td align="left"><a href="https://core.telegram.org/bots/api#poll">Poll</a></td><td align="left">可选的。新的投票状态。机器人仅接收有关僵尸程序发送的有关已停止的投票和投票的更新</td></tr><tr><td align="left">poll_answer</td><td align="left"><a href="https://core.telegram.org/bots/api#poll_answer">PollAnswer</a></td><td align="left">可选的。用户在非匿名调查中更改了答案。僵尸程序仅在由僵尸程序本身发送的民意调查中才能获得新的选票。</td></tr></tbody></table><p>任何给定的更新中最多只能存在一个可选参数。</p><h3 id="User"><a href="#User" class="headerlink" title="User"></a>User</h3><p>该对象表示telegram的一个用户或者机器人</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">Integer</td><td align="left">该用户或机器人的唯一标识</td></tr><tr><td align="left">is_bot</td><td align="left">Boolean</td><td align="left">标识该用户是否是机器人，True如果是机器人</td></tr><tr><td align="left">first_name</td><td align="left">String</td><td align="left">用户或者机器人的first_name</td></tr><tr><td align="left">last_name</td><td align="left">String</td><td align="left">可选。用户或者机器人的last_name</td></tr><tr><td align="left">username</td><td align="left">String</td><td align="left">可选。用户或者机器人的username</td></tr><tr><td align="left">language_code</td><td align="left">String</td><td align="left">可选。用户语言的IETF语言标签</td></tr><tr><td align="left">can_join_groups</td><td align="left">Boolean</td><td align="left">可选。返回True如果该机器人可以被邀请加入群组，只在<code>getMe</code>方法返回</td></tr><tr><td align="left">can_read_all_group_message</td><td align="left">Boolean</td><td align="left">可选。返回True如果该机器人禁用了隐私模式，只在<code>getMe</code>方法返回</td></tr><tr><td align="left">supports_inline_queries</td><td align="left">Boolean</td><td align="left">可选。返回True，如果这个自持内联查询，只在<code>getMe</code>方法返回</td></tr></tbody></table><h3 id="Chat"><a href="#Chat" class="headerlink" title="Chat"></a>Chat</h3><p>该对象表示一个聊天信息</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">Integer</td><td align="left">该聊天的唯一标识符。 这个数字可能会大于32位但是一定小于52位所以编程时因指定<code>int64</code>类型</td></tr><tr><td align="left">type</td><td align="left">String</td><td align="left">聊天的类型，可以是 “private”, “group”, “supergroup” 或者 “channel”</td></tr><tr><td align="left">title</td><td align="left">String</td><td align="left">可选。 标题, 针对 supergroups, channels 和 group 类型的聊天</td></tr><tr><td align="left">username</td><td align="left">String</td><td align="left">可选。 Username, 针对 私有的聊天，如果可以的话也针对 supergroups 和 channels</td></tr><tr><td align="left">first_name</td><td align="left">String</td><td align="left">可选。 私人聊天中对方的first_name</td></tr><tr><td align="left">last_name</td><td align="left">String</td><td align="left">可选。私人聊天中对方的last_name</td></tr><tr><td align="left">photo</td><td align="left"><a href="https://core.telegram.org/bots/api#chatphoto">ChatPhoto</a></td><td align="left">可选。 聊天照片，只在<code>getChat</code>方法返回</td></tr><tr><td align="left">description</td><td align="left">String</td><td align="left">可选。 描述, 针对 groups, supergroups 和 channel 的聊天。只在<code>getChat</code>方法返回</td></tr><tr><td align="left">invite_link</td><td align="left">String</td><td align="left">可选。聊天的邀请链接, 针对 groups, supergroups 和 channel 的聊天。聊天中的每个管理员都会生成自己的邀请链接，因此机器人必须首先使用<code>exportChatInviteLink</code>生成链接。仅在<code>getChat</code>中返回。</td></tr><tr><td align="left">pinned_message</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选。固定信息，针对 groups, supergroups 和 channels。只在<code>getChat</code>方法中返回</td></tr><tr><td align="left">permissions</td><td align="left"><a href="https://core.telegram.org/bots/api#chatpermissions">ChatPermissions</a></td><td align="left">可选。默认的聊天成员权限, 针对 groups 和 supergroups。只在<code>getChat</code>方法中返回</td></tr><tr><td align="left">slow_mode_delay</td><td align="left">Integer</td><td align="left">可选。针对 supergroups, 每个非特权用户发送的连续消息之间允许的最小延迟。仅在<code>getChat</code>中返回。</td></tr><tr><td align="left">sticker_set_name</td><td align="left">String</td><td align="left">可选。针对 supergroups, 组贴纸集的名称。仅在getChat中返回。</td></tr><tr><td align="left">can_set_sticker_set</td><td align="left">Boolean</td><td align="left">可选。 返回True如果机器人可以改变group的贴纸集，只在<code>getChat</code>方法中返回。</td></tr></tbody></table><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>该对象代表一个消息</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">message_id</td><td align="left">Integer</td><td align="left">此聊天中的唯一消息标识符</td></tr><tr><td align="left">from</td><td align="left"><a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。发件人，对于发送到channels的消息为空</td></tr><tr><td align="left">date</td><td align="left">Integer</td><td align="left">发送时间（Unix时间）</td></tr><tr><td align="left">chat</td><td align="left"><a href="https://core.telegram.org/bots/api#chat">Chat</a></td><td align="left">消息所属的会话</td></tr><tr><td align="left">forward_from</td><td align="left"><a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。对于转发的消息，原始消息的发件人</td></tr><tr><td align="left">forward_from_chat</td><td align="left"><a href="https://core.telegram.org/bots/api#chat">Chat</a></td><td align="left">可选的。对于从频道转发的消息，有关原始频道的信息</td></tr><tr><td align="left">forward_from_message_id</td><td align="left">Integer</td><td align="left">可选的。对于从频道转发的消息，是频道中原始消息的标识符</td></tr><tr><td align="left">forward_signature</td><td align="left">String</td><td align="left">可选的。对于从频道转发的消息，作者的签名（如果有）</td></tr><tr><td align="left">forward_sender_name</td><td align="left">String</td><td align="left">可选的。从用户转发的信息的发件人名称，这些用户不允许在转发的信息中添加指向其帐户的链接</td></tr><tr><td align="left">forward_date</td><td align="left">Integer</td><td align="left">可选的。对于转发的消息，原始消息的发送日期（Unix时间）</td></tr><tr><td align="left">reply_to_message</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。对于答复，原始消息。请注意，即使此字段本身是答复，该字段中的Message对象也不会包含其他的reply_to_message字段。</td></tr><tr><td align="left">via_bot</td><td align="left"><a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。发送消息的机器人</td></tr><tr><td align="left">edit_date</td><td align="left">Integer</td><td align="left">可选的。消息最后一次编辑的日期（Unix时间）</td></tr><tr><td align="left">media_group_id</td><td align="left">String</td><td align="left">可选的。该消息所属的媒体消息组的唯一标识符</td></tr><tr><td align="left">author_signature</td><td align="left">String</td><td align="left">可选的。在频道中信息的作者签名</td></tr><tr><td align="left">text</td><td align="left">String</td><td align="left">可选的。对于文本消息，消息的实际UTF-8文本，0-4096个字符</td></tr><tr><td align="left">entities</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#messageentity">MessageEntity</a></td><td align="left">可选的。对于文本消息，出现在文本中的特殊实体，例如用户名，URL，机器人命令等。</td></tr><tr><td align="left">animation</td><td align="left"><a href="https://core.telegram.org/bots/api#animation">Animation</a></td><td align="left">可选的。消息是动画，有关动画的信息。为了向后兼容，设置此字段时，还将设置文档字段</td></tr><tr><td align="left">audio</td><td align="left"><a href="https://core.telegram.org/bots/api#audio">Audio</a></td><td align="left">可选的。消息是音频文件，有关该文件的信息</td></tr><tr><td align="left">document</td><td align="left"><a href="https://core.telegram.org/bots/api#document">Document</a></td><td align="left">可选的。消息是常规文件，有关文件的信息</td></tr><tr><td align="left">photo</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#photosize">PhotoSize</a></td><td align="left">可选的。消息是照片，照片的可用尺寸</td></tr><tr><td align="left">sticker</td><td align="left"><a href="https://core.telegram.org/bots/api#sticker">Sticker</a></td><td align="left">可选的。消息是贴纸，有关贴纸的信息</td></tr><tr><td align="left">video</td><td align="left"><a href="https://core.telegram.org/bots/api#video">Video</a></td><td align="left">可选的。消息是视频，有关视频的信息</td></tr><tr><td align="left">video_note</td><td align="left"><a href="https://core.telegram.org/bots/api#videonote">VideoNote</a></td><td align="left">可选的。消息是视频注释，有关视频消息的信息</td></tr><tr><td align="left">voice</td><td align="left"><a href="https://core.telegram.org/bots/api#voice">Voice</a></td><td align="left">可选的。消息是语音消息，有关文件的信息</td></tr><tr><td align="left">caption</td><td align="left">String</td><td align="left">可选的。动画，音频，文档，照片，视频或语音的标题，0-1024个字符</td></tr><tr><td align="left">caption_entities</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#messageentity">MessageEntity</a></td><td align="left">可选的。对于带有标题的消息，出现在标题中的特殊实体，例如用户名，URL，漫机器人命令等</td></tr><tr><td align="left">contact</td><td align="left"><a href="https://core.telegram.org/bots/api#contact">Contact</a></td><td align="left">可选的。消息是共享的联系人，有关该联系人的信息</td></tr><tr><td align="left">dice</td><td align="left"><a href="https://core.telegram.org/bots/api#dice">Dice</a></td><td align="left">可选的。消息是一个骰子，具有从1到6的随机值</td></tr><tr><td align="left">game</td><td align="left"><a href="https://core.telegram.org/bots/api#game">Game</a></td><td align="left">可选的。消息是一个游戏，有关游戏的信息。</td></tr><tr><td align="left">poll</td><td align="left"><a href="https://core.telegram.org/bots/api#poll">Poll</a></td><td align="left">可选的。消息是原生投票，有关投票的信息</td></tr><tr><td align="left">venue</td><td align="left"><a href="https://core.telegram.org/bots/api#venue">Venue</a></td><td align="left">可选的。消息是一个场地，有关该场地的信息。为了向后兼容，设置此字段时，还将设置位置字段</td></tr><tr><td align="left">location</td><td align="left"><a href="https://core.telegram.org/bots/api#location">Location</a></td><td align="left">可选的。消息是共享位置，有关位置的信息</td></tr><tr><td align="left">new_chat_members</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。添加到组或超组中的新成员以及有关它们的信息（机器人本身可能是这些成员之一）</td></tr><tr><td align="left">left_chat_member</td><td align="left"><a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。成员已从群组中删除，有关他们的信息（该成员可能是机器人本身）</td></tr><tr><td align="left">new_chat_title</td><td align="left">String</td><td align="left">可选的。聊天标题已更改为此值</td></tr><tr><td align="left">new_chat_photo</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#photosize">PhotoSize</a></td><td align="left">可选的。聊天照片已更改为此值</td></tr><tr><td align="left">delete_chat_photo</td><td align="left">True</td><td align="left">可选的。服务消息：聊天照片已删除</td></tr><tr><td align="left">group_chat_created</td><td align="left">True</td><td align="left">可选的。服务信息：组已创建</td></tr><tr><td align="left">supergroup_chat_created</td><td align="left">True</td><td align="left">可选的。 服务消息：超组已创建。 在通过更新发送的消息中无法接收到该字段，因为bot在创建时不能成为超组的成员。 仅当有人回复直接创建的超组中的第一条消息时，才可以在reply_to_message中找到该消息。</td></tr><tr><td align="left">channel_chat_created</td><td align="left">True</td><td align="left">可选的。 服务信息：频道已创建。 在通过更新发送的消息中无法接收到该字段，因为bot在创建时不能成为频道的成员。 如果有人回复频道中的第一条消息，则只能在reply_to_message中找到它。</td></tr><tr><td align="left">migrate_to_chat_id</td><td align="left">Integer</td><td align="left">可选的。 该组已迁移到具有指定标识符的超组。 此数字可能大于32位，并且某些编程语言在解释它时可能会有困难/无声的缺陷。 但是它小于52位，因此带符号的64位整数或双精度浮点类型对于存储此标识符是安全的。</td></tr><tr><td align="left">migrate_from_chat_id</td><td align="left">Integer</td><td align="left">可选的。 超级组已从具有指定标识的组中迁移。 此数字可能大于32位，并且某些编程语言在解释它时可能会有困难/无声的缺陷。 但是它小于52位，因此带符号的64位整数或双精度浮点类型对于存储此标识符是安全的。</td></tr><tr><td align="left">pinned_message</td><td align="left"><a href="https://core.telegram.org/bots/api#message">Message</a></td><td align="left">可选的。 指定的消息已固定。 请注意，即使该字段本身是答复，该字段中的Message对象也不会包含其他的reply_to_message字段。</td></tr><tr><td align="left">invoice</td><td align="left"><a href="https://core.telegram.org/bots/api#invoice">Invoice</a></td><td align="left">可选的。 消息是付款的发票，有关发票的信息。</td></tr><tr><td align="left">successful_payment</td><td align="left"><a href="https://core.telegram.org/bots/api#successfulpayment">SuccessfulPayment</a></td><td align="left">可选的。 消息是有关成功付款的服务消息，有关付款的信息。</td></tr><tr><td align="left">connected_website</td><td align="left">String</td><td align="left">可选的。 用户登录的网站的域名。</td></tr><tr><td align="left">passport_data</td><td align="left"><a href="https://core.telegram.org/bots/api#passportdata">PassportData</a></td><td align="left">可选的。 电报护照数据</td></tr><tr><td align="left">reply_markup</td><td align="left"><a href="https://core.telegram.org/bots/api#inlinekeyboardmarkup">InlineKeyboardMarkup</a></td><td align="left">可选的。 消息附带的嵌入式键盘。 login_url按钮表示为普通url按钮。</td></tr></tbody></table><h3 id="MessageEntity"><a href="#MessageEntity" class="headerlink" title="MessageEntity"></a>MessageEntity</h3><p>该对象表示文本消息中的一个特殊实体。例如，标签，用户名，URL等。</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">type</td><td align="left">String</td><td align="left">实体的类型。 可以是“mention”（@username），“hashtag”（#hashtag），“cashtag”（$ USD），“ bot_command”（/ start @ jobs_bot），“ URL”（<a href="https://telegram.org),“/">https://telegram.org），“</a> email”（<a href="mailto:&#100;&#x6f;&#45;&#x6e;&#111;&#116;&#x2d;&#114;&#101;&#112;&#108;&#121;&#x40;&#x74;&#101;&#108;&#x65;&#103;&#x72;&#97;&#x6d;&#46;&#x6f;&#x72;&#103;">&#100;&#x6f;&#45;&#x6e;&#111;&#116;&#x2d;&#114;&#101;&#112;&#108;&#121;&#x40;&#x74;&#101;&#108;&#x65;&#103;&#x72;&#97;&#x6d;&#46;&#x6f;&#x72;&#103;</a>），“phone_number”（+ 1-212-555-0123），“bold”（粗体），“italic”（斜体），“underline”（带下划线的文本） ），“strikethrough”（删除线文本），“code”（等宽字符串），“ pre”（等宽块），“ text_link”（对于可点击的文本URL），“ text_mention”（对于没有用户名的用户）</td></tr><tr><td align="left">offset</td><td align="left">Integer</td><td align="left">以UTF-16代码单位向实体开始的偏移量</td></tr><tr><td align="left">length</td><td align="left">Integer</td><td align="left">实体的长度（以UTF-16代码单元为单位）</td></tr><tr><td align="left">url</td><td align="left">String</td><td align="left">可选的。仅对于“ text_link”，用户点击文本后将打开的URL</td></tr><tr><td align="left">user</td><td align="left"><a href="https://core.telegram.org/bots/api#user">User</a></td><td align="left">可选的。仅针对“ text_mention”，提到的用户</td></tr><tr><td align="left">language</td><td align="left">String</td><td align="left">可选的。仅对于“ pre”，实体文本的编程语言</td></tr></tbody></table><h3 id="BotCommand"><a href="#BotCommand" class="headerlink" title="BotCommand"></a>BotCommand</h3><p>这个对象代表值一条机器人指令</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">command</td><td align="left">String</td><td align="left">命令文本，1-32个字符。只能包含小写英文字母，数字和下划线。</td></tr><tr><td align="left">description</td><td align="left">String</td><td align="left">命令说明，3-256个字符。</td></tr></tbody></table><h3 id="WebhookInfo"><a href="#WebhookInfo" class="headerlink" title="WebhookInfo"></a>WebhookInfo</h3><p>这个对象表示当前webhook的状态</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">String</td><td align="left">Webhook URL，如果未设置webhook，则可能为空</td></tr><tr><td align="left">has_custom_certificate</td><td align="left">Boolean</td><td align="left">如果为webhook证书检查提供了自定义证书则为真</td></tr><tr><td align="left">pending_update_count</td><td align="left">Integer</td><td align="left">等待交付的更新数量</td></tr><tr><td align="left">last_error_date</td><td align="left">Integer</td><td align="left">可选的。尝试通过Webhook传递更新时发生的最新错误的Unix时间</td></tr><tr><td align="left">last_error_message</td><td align="left">String</td><td align="left">可选的。尝试通过Webhook传递更新时发生的最新错误的人类可读格式的错误消息</td></tr><tr><td align="left">max_connections</td><td align="left">Integer</td><td align="left">可选的。与Webhook进行更新交付的同时HTTPS连接的最大允许数量</td></tr><tr><td align="left">allowed_updates</td><td align="left">Array of String</td><td align="left">可选的。机器人已订阅的更新类型的列表。默认为所有更新类型</td></tr></tbody></table><h3 id="ReplyKeyboardMarkup"><a href="#ReplyKeyboardMarkup" class="headerlink" title="ReplyKeyboardMarkup"></a>ReplyKeyboardMarkup</h3><p>该对象表示带有回复选项的自定义键盘</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">keyboard</td><td align="left">Array of Array of <a href="https://core.telegram.org/bots/api/#keyboardbutton">KeyboardButton</a></td><td align="left">按钮行数组，每个行由一个KeyboardButton对象数组表示</td></tr><tr><td align="left">resize_keyboard</td><td align="left">Boolean</td><td align="left">可选的。请求客户垂直调整键盘大小以达到最佳适合度（例如，如果只有两行按钮，则使键盘变小）。默认为false，在这种情况下，自定义键盘的高度始终与应用程序的标准键盘相同。</td></tr><tr><td align="left">one_time_keyboard</td><td align="left">Boolean</td><td align="left">可选的。要求客户在使用键盘后立即隐藏它。键盘仍然可用，但是客户端将在聊天中自动显示常用的字母键盘-用户可以在输入字段中按特殊按钮以再次查看自定义键盘。默认为false。</td></tr><tr><td align="left">selective</td><td align="left">Boolean</td><td align="left">可选的。如果只想向特定用户显示键盘，请使用此参数。目标：1）在Message对象的文本中@提及的用户； 2）如果机器人的消息是回复（具有reply_to_message_id），则为原始消息的发送者。 <br />示例：用户请求更改机器人的语言，机器人用键盘答复选择新语言的请求。群组中的其他用户看不到键盘。</td></tr></tbody></table><h3 id="KeyboardButton"><a href="#KeyboardButton" class="headerlink" title="KeyboardButton"></a>KeyboardButton</h3><p>该对象表示回复键盘的一个按钮。对于简单的文本按钮，可以使用<code>String</code>代替此对象来指定按钮的文本。可选字段<code>request_contact</code>，<code>request_location</code>和<code>request_poll</code>是互斥的。</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">String</td><td align="left">按钮的文字。如果未使用任何可选字段，则在按下按钮时它将作为消息发送</td></tr><tr><td align="left">request_contact</td><td align="left">Boolean</td><td align="left">可选的。如果为True，则按下该按钮时，用户的电话号码将作为联系人发送。仅在私人聊天中可用</td></tr><tr><td align="left">request_location</td><td align="left">Boolean</td><td align="left">可选的。如果为True，则在按下按钮时将发送用户的当前位置。仅在私人聊天中可用</td></tr><tr><td align="left">request_poll</td><td align="left"><a href="https://core.telegram.org/bots/api/#keyboardbuttonpolltype">KeyboardButtonPollType</a></td><td align="left">可选的。如果指定，则将要求用户创建一个民意调查，并在按下按钮时将其发送给机器人。仅在私人聊天中可用</td></tr></tbody></table><p><strong>注意</strong>：<em>request_contact</em>和<em>request_location</em>选项仅适用于2016年4月9日之后发布的电报版本。较旧的客户端将显示不受支持的消息。 </p><p><strong>注意</strong>：<em>request_poll</em>选项仅在2020年1月23日之后发布的电报版本中有效。旧客户端将显示不支持的消息。</p><h3 id="KeyboardButtonPollType"><a href="#KeyboardButtonPollType" class="headerlink" title="KeyboardButtonPollType"></a>KeyboardButtonPollType</h3><p>该对象表示民意调查的类型，可以在按下相应按钮时创建并发送该民意调查</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">type</td><td align="left">String</td><td align="left">可选的。如果通过了测验，将仅允许用户以测验模式创建民意测验。如果通过常规，则仅允许常规民意调查。否则，将允许用户创建任何类型的民意测验。</td></tr></tbody></table><h3 id="ReplyKeyboardRemove"><a href="#ReplyKeyboardRemove" class="headerlink" title="ReplyKeyboardRemove"></a>ReplyKeyboardRemove</h3><p>收到带有此对象的消息后，Telegram客户端将删除当前的自定义键盘并显示默认的字母键盘。默认情况下，将显示自定义键盘，直到机器人发送新键盘为止。一次性键盘的例外情况是用户按下按钮后立即隐藏的一次性键盘</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">remove_keyboard</td><td align="left">True</td><td align="left">请求客户端删除自定义键盘（用户将无法召唤此键盘；如果要隐藏键盘，但保持其可访问性，请在ReplyKeyboardMarkup中使用one_time_keyboard）</td></tr><tr><td align="left">selective</td><td align="left">Boolean</td><td align="left">可选的。如果仅要为特定用户卸下键盘，请使用此参数。目标：1）在Message对象的文本中@提及的用户； 2）如果漫游器的消息是回复（具有reply_to_message_id），则为原始消息的发送者。 示例：用户在投票中投票，机器人返回确认消息以回应投票，并删除该用户的键盘，同时仍向尚未投票的用户显示带有投票选项的键盘。</td></tr></tbody></table><h3 id="InlineKeyboardMarkup"><a href="#InlineKeyboardMarkup" class="headerlink" title="InlineKeyboardMarkup"></a>InlineKeyboardMarkup</h3><p>该对象表示一个嵌入式键盘，出现在其所属消息的旁边。</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">inline_keyboard</td><td align="left">Array of Array of <a href="https://core.telegram.org/bots/api/#inlinekeyboardbutton">InlineKeyboardButton</a></td><td align="left">按钮行数组，每个行由一个InlineKeyboardButton对象数组表示</td></tr></tbody></table><p><strong>注意</strong>：这仅适用于2016年4月9日之后发布的电报版本。较旧的客户端将显示不受支持的消息。</p><h3 id="InlineKeyboardButton"><a href="#InlineKeyboardButton" class="headerlink" title="InlineKeyboardButton"></a>InlineKeyboardButton</h3><p>此对象表示嵌入式键盘的一个按钮。您必须完全使用可选字段之一。</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">String</td><td align="left">在按钮上标记文本</td></tr><tr><td align="left">url</td><td align="left">String</td><td align="left">可选的。按下按钮时将打开HTTP或tg:// URL</td></tr><tr><td align="left">login_url</td><td align="left"><a href="https://core.telegram.org/bots/api/#loginurl">LoginUrl</a></td><td align="left">可选的。用于自动授权用户的HTTP URL。可以替代电报登录小部件。</td></tr><tr><td align="left">callback_data</td><td align="left">String</td><td align="left">可选的。按下按钮时要在回调查询中发送到bot的数据，1-64个字节</td></tr><tr><td align="left">switch_inline_query</td><td align="left">String</td><td align="left">可选的。如果已设置，则按下按钮将提示用户选择其聊天之一，打开该聊天并将bot的用户名和指定的内联查询插入输入字段。可以为空，在这种情况下，只会插入机器人的用户名。<br /><strong>注意</strong>：这为用户提供了一种简便的方法，使他们在当前与它进行私聊时以内联模式开始使用您的机器人。与switch_pm…操作结合使用时特别有用–在这种情况下，用户将自动返回到其切换到的聊天中，而跳过聊天选择屏幕。</td></tr><tr><td align="left">switch_inline_query_current_chat</td><td align="left">String</td><td align="left">可选的。如果已设置，则按下按钮会将bot的用户名和指定的嵌入式查询插入当前聊天的输入字段中。可以为空，在这种情况下，只会插入机器人的用户名。</td></tr><tr><td align="left">callback_game</td><td align="left"><a href="https://core.telegram.org/bots/api/#callbackgame">CallbackGame</a></td><td align="left">可选的。用户按下按钮时将启动的游戏的描述。<br /><strong>注意</strong>：此类型的按钮必须始终是第一行中的第一个按钮。</td></tr><tr><td align="left">pay</td><td align="left">Boolean</td><td align="left">可选的。指定True，发送付款按钮。 <br /><strong>注意</strong>：此类型的按钮必须始终是第一行中的第一个按钮。</td></tr></tbody></table><h3 id="ForceReply"><a href="#ForceReply" class="headerlink" title="ForceReply"></a>ForceReply</h3><p>收到带有该对象的消息后，Telegram客户端将向用户显示一个答复界面（就像用户选择了机器人的消息并点按“答复”一样）。如果您要创建用户友好的逐步界面而不必牺牲隐私模式，这将非常有用。</p><table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">force_reply</td><td align="left">True</td><td align="left">向用户显示回复界面，就像他们手动选择了机器人的消息并点按“回复”一样</td></tr><tr><td align="left">selective</td><td align="left">Boolean</td><td align="left">可选的。如果只想强制特定用户答复，请使用此参数。目标：1）在Message对象的文本中@提及的用户； 2）如果漫游器的消息是回复（具有reply_to_message_id），则为原始消息的发送者。</td></tr></tbody></table><h2 id="telegram方法"><a href="#telegram方法" class="headerlink" title="telegram方法"></a>telegram方法</h2><p>telegram方法就是拼接在api后面的那串字符串，不区分大小写。<a href="https://core.telegram.org/bots/api#available-methods">详见</a>，这里只列举一些常用的，下面我所指的返回是指返回json中的result部分，其他章节提到的所有方法均可以在这一章节查阅</p><h3 id="getUpdates"><a href="#getUpdates" class="headerlink" title="getUpdates"></a>getUpdates</h3><ul><li><p>描述</p><p>获取更新，还有另外一种获取更新的方法(webhook)，两种方式不能共存</p></li><li><p>参数</p><p>无参数</p></li><li><p>返回</p><p><code>update</code>对象列表</p></li></ul><h3 id="setWebhook"><a href="#setWebhook" class="headerlink" title="setWebhook"></a>setWebhook</h3><ul><li><p>描述</p><p>使用此方法可以指定URL并通过传出的Webhook接收传入的更新。只要机器人有更新，telegram就会向指定的URL发送HTTPS POST请求，请求数据为json序列化后的<code>update</code>对象</p></li><li><p>参数</p><table><thead><tr><th align="left">Parameter</th><th align="left">Type</th><th align="left">Required</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">String</td><td align="left">Yes</td><td align="left">发送更新的https url。使用空字符串删除webhook集成</td></tr><tr><td align="left">certificate</td><td align="left"><a href="https://core.telegram.org/bots/api#inputfile">InputFile</a></td><td align="left">Optional</td><td align="left">上传您的公共密钥证书，以便可以检查正在使用的根证书。有关详细信息，请参见我们的<a href="https://core.telegram.org/bots/self-signed">自签名指南</a>。</td></tr><tr><td align="left">max_connections</td><td align="left">Integer</td><td align="left">Optional</td><td align="left">与Webhook进行更新交付的同时HTTPS连接的最大允许数量为1-100。默认值为40。使用较低的值可以限制bot服务器的负载，使用较高的值可以增加bot的吞吐量。</td></tr><tr><td align="left">allowed_updates</td><td align="left">Array of String</td><td align="left">Optional</td><td align="left">您希望机器人接收的更新类型的JSON序列化列表。 例如，指定[“ message”，“ edited_channel_post”，“ callback_query”]仅接收这些类型的更新。 请参阅更新以获取可用更新类型的完整列表。 指定一个空列表以接收所有更新，无论类型如何（默认）。 如果未指定，将使用以前的设置。<br />请注意，此参数不会影响调用setWebhook之前创建的更新，因此可能会在短时间内收到不需要的更新。</td></tr></tbody></table></li></ul><ul><li><p>返回</p><p>成功返回<code>True</code></p></li></ul><h3 id="deleteWebhook"><a href="#deleteWebhook" class="headerlink" title="deleteWebhook"></a>deleteWebhook</h3><ul><li><p>描述</p><p>删除设置的webhook</p></li><li><p>参数</p><p>无参数</p></li><li><p>返回</p><p>成功返回True</p></li></ul><h3 id="getWebhookInfo"><a href="#getWebhookInfo" class="headerlink" title="getWebhookInfo"></a>getWebhookInfo</h3><ul><li><p>描述</p><p>获取当前webhook的状态</p></li><li><p>参数</p><p>无参数</p></li><li><p>返回</p><p><code>WebhookInfo</code>对象</p><p>（如果没有设置webhook，则返回的对象中url为空）</p></li></ul><h3 id="getMe"><a href="#getMe" class="headerlink" title="getMe"></a>getMe</h3><ul><li><p>描述</p><p>获取机器人自身信息</p></li><li><p>参数</p><p>无参数</p></li><li><p>返回</p><p><code>user</code>对象</p></li></ul><h3 id="getChat"><a href="#getChat" class="headerlink" title="getChat"></a>getChat</h3><ul><li><p>描述</p><p>使用此方法可获取有关聊天的最新信息（一对一对话的用户的当前名称，用户的当前用户名，组或频道等）</p></li><li><p>参数</p><table><thead><tr><th align="left">Parameter</th><th align="left">Type</th><th align="left">Required</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">chat_id</td><td align="left">Integer or String</td><td align="left">Yes</td><td align="left">目标聊天或目标超级组或频道的用户名的唯一标识符（格式为@channelusername）</td></tr></tbody></table></li><li><p>返回</p><p><code>chat</code>对象</p></li></ul><h3 id="sendMessage"><a href="#sendMessage" class="headerlink" title="sendMessage"></a>sendMessage</h3><ul><li><p>描述</p><p>发送消息</p></li><li><p>参数</p><table><thead><tr><th align="left">Parameter</th><th align="left">Type</th><th align="left">Required</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">chat_id</td><td align="left">Integer or String</td><td align="left">Yes</td><td align="left">目标聊天（chat_id）或目标频道的用户名的唯一标识符（格式为@channelusername）</td></tr><tr><td align="left">text</td><td align="left">String</td><td align="left">Yes</td><td align="left">待发送消息的文本，实体解析后为1-4096个字符</td></tr><tr><td align="left">parse_mode</td><td align="left">String</td><td align="left">Optional</td><td align="left">消息文本中的实体解析模式。有关更多详细信息，请参见格式化选项。</td></tr><tr><td align="left">disable_web_page_preview</td><td align="left">Boolean</td><td align="left">Optional</td><td align="left">禁用此消息中链接的链接预览</td></tr><tr><td align="left">disable_notification</td><td align="left">Boolean</td><td align="left">Optional</td><td align="left">静默发送消息。用户将收到没有声音的通知。</td></tr><tr><td align="left">reply_to_message_id</td><td align="left">Integer</td><td align="left">Optional</td><td align="left">如果消息是答复，则为原始消息的ID</td></tr><tr><td align="left">reply_markup</td><td align="left"><a href="https://core.telegram.org/bots/api#inlinekeyboardmarkup">InlineKeyboardMarkup</a> or <a href="https://core.telegram.org/bots/api#replykeyboardmarkup">ReplyKeyboardMarkup</a> or <a href="https://core.telegram.org/bots/api#replykeyboardremove">ReplyKeyboardRemove</a> or <a href="https://core.telegram.org/bots/api#forcereply">ForceReply</a></td><td align="left">Optional</td><td align="left">其他界面选项。内联键盘，自定义回复键盘，删除回复键盘或强制用户回复的说明的JSON序列化对象。</td></tr></tbody></table></li><li><p>返回</p><p>刚刚发送的<code>message</code>对象</p></li></ul><h3 id="setMyCommands"><a href="#setMyCommands" class="headerlink" title="setMyCommands"></a>setMyCommands</h3><ul><li><p>描述</p><p>使用此方法可以更改机器人的命令列表</p></li><li><p>参数</p><table><thead><tr><th align="left">Parameter</th><th align="left">Type</th><th align="left">Required</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">commands</td><td align="left">Array of <a href="https://core.telegram.org/bots/api#botcommand">BotCommand</a></td><td align="left">Yes</td><td align="left">将bot命令的JSON序列化列表设置为bot命令列表。最多可以指定100个命令。</td></tr></tbody></table></li><li><p>返回</p><p>成功返回<code>True</code></p></li></ul><h3 id="getMyCommands"><a href="#getMyCommands" class="headerlink" title="getMyCommands"></a>getMyCommands</h3><ul><li><p>描述</p><p>使用此方法获取机器人命令的当前列表</p></li><li><p>参数</p><p>无参数</p></li><li><p>返回</p><p><code>BotCommand</code>对象列表</p></li><li></li></ul><h2 id="格式化选项"><a href="#格式化选项" class="headerlink" title="格式化选项"></a>格式化选项</h2><p>格式化选项就是让我们的机器人以某种格式发送消息（比如markdown，或者html）</p><p>  Bot API支持消息的基本格式。您可以在机器人的消息中使用粗体，斜体，下划线和删除线文本，以及内联链接和预格式化的代码。电报客户端将相应地呈现它们。您可以使用markdown样式或HTML样式格式。</p><p>请注意，Telegram客户端将在打开内联链接（“打开此链接？”以及完整的URL）之前向用户显示警报。</p><p>如果满足以下限制，则可以嵌套消息实体：</p><ul><li>如果两个实体具有公共字符，则其中一个完全包含在另一个内部。</li><li>粗体，斜体，下划线和删除线实体可以包含并且要包含在任何其他实体中，但pre和code除外。</li><li>所有其他实体不能互相包含。</li></ul><p>链接<code>tg://user?id=&lt;user_id&gt;</code>可以用于通过用户ID提及用户，而无需使用用户名。请注意：</p><ul><li>这些链接仅在内联链接中使用时才有效。例如，当用于嵌入式键盘按钮或消息文本中时，它们将不起作用。</li><li>仅当用户过去联系过该机器人，通过内联按钮向该机器人发送了回调查询或成为提及该用户的组的成员时，才能保证这些提及有效。</li></ul><h3 id="MarkdownV2-style"><a href="#MarkdownV2-style" class="headerlink" title="MarkdownV2 style"></a>MarkdownV2 style</h3><p>要使用此模式，请在parse_mode字段中传递MarkdownV2。在您的消息中使用以下语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*bold \*</span>text<span class="emphasis">*</span></span><br><span class="line"><span class="emphasis">_italic \*</span>text<span class="emphasis">_</span></span><br><span class="line"><span class="emphasis"><span class="strong">__underline__</span></span></span><br><span class="line"><span class="emphasis">~strikethrough~</span></span><br><span class="line"><span class="emphasis">*bold _</span>italic bold ~italic bold strikethrough~ <span class="strong">__underline italic bold__</span><span class="emphasis">_ bold*</span></span><br><span class="line"><span class="emphasis">[<span class="string">inline URL</span>](<span class="link">http://www.example.com/</span>)</span></span><br><span class="line"><span class="emphasis">[<span class="string">inline mention of a user</span>](<span class="link">tg://user?id=123456789</span>)</span></span><br><span class="line"><span class="emphasis">`inline fixed-width code`</span></span><br><span class="line"><span class="emphasis">​```</span></span><br><span class="line"><span class="emphasis">pre-formatted fixed-width code block</span></span><br><span class="line"><span class="emphasis">​```</span></span><br><span class="line"><span class="emphasis">​```python</span></span><br><span class="line"><span class="emphasis">pre-formatted fixed-width code block written in the Python programming language</span></span><br><span class="line"><span class="emphasis">​```</span></span><br></pre></td></tr></table></figure><p>请注意：</p><ul><li>任何代码在1到126之间（含1和126）的字符都可以在任何带有’&#39;字符的位置转义，在这种情况下，它将被视为普通字符，而不是标记的一部分。</li><li>在pre和code实体内部，所有’`’和’\‘字符必须以前面的’\‘字符转义。</li><li>内联链接定义的内部(…)部分，所有’)’和’\‘必须以前面的’\‘字符转义</li><li>在其他所有地方这些字符 ‘_’, ‘*’, ‘[‘, ‘]’, ‘(‘, ‘)’, ‘~’, ‘`’, ‘&gt;’, ‘#’, ‘+’, ‘-‘, ‘=’, ‘|’, ‘{‘, ‘}’, ‘.’, ‘!’ 必须用前置’\‘转义</li><li>如果<code>斜体</code>和<code>下划线</code>之间存在歧义，<code>__</code>始终从左到右被视为<code>下划线</code>实体的开始或结尾，所以使用<code>___italic underline_\r__</code>代替<code>___italic underline___</code></li></ul><h3 id="HTML-style"><a href="#HTML-style" class="headerlink" title="HTML style"></a>HTML style</h3><p>要使用此模式，请在parse_mode字段中传递HTML。当前支持以下标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>bold<span class="tag">&lt;/<span class="name">b</span>&gt;</span>, <span class="tag">&lt;<span class="name">strong</span>&gt;</span>bold<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>italic<span class="tag">&lt;/<span class="name">i</span>&gt;</span>, <span class="tag">&lt;<span class="name">em</span>&gt;</span>italic<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>underline<span class="tag">&lt;/<span class="name">u</span>&gt;</span>, <span class="tag">&lt;<span class="name">ins</span>&gt;</span>underline<span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">s</span>&gt;</span>strikethrough<span class="tag">&lt;/<span class="name">s</span>&gt;</span>, <span class="tag">&lt;<span class="name">strike</span>&gt;</span>strikethrough<span class="tag">&lt;/<span class="name">strike</span>&gt;</span>, <span class="tag">&lt;<span class="name">del</span>&gt;</span>strikethrough<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>bold <span class="tag">&lt;<span class="name">i</span>&gt;</span>italic bold <span class="tag">&lt;<span class="name">s</span>&gt;</span>italic bold strikethrough<span class="tag">&lt;/<span class="name">s</span>&gt;</span> <span class="tag">&lt;<span class="name">u</span>&gt;</span>underline italic bold<span class="tag">&lt;/<span class="name">u</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> bold<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.example.com/&quot;</span>&gt;</span>inline URL<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;tg://user?id=123456789&quot;</span>&gt;</span>inline mention of a user<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span>inline fixed-width code<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>pre-formatted fixed-width code block<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span> <span class="attr">class</span>=<span class="string">&quot;language-python&quot;</span>&gt;</span>pre-formatted fixed-width code block written in the Python programming language<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请注意：</p><ul><li>当前仅支持上述标签。</li><li>所有不属于标记或HTML实体的<code>&lt;</code>，<code>&gt;</code>和<code>&amp;</code>符号必须替换为相应的HTML实体(<code>&lt;</code> 用 <code>&amp;lt;</code>， <code>&gt;</code> 用 <code>&amp;gt;</code>， <code>&amp;</code> 用 <code>&amp;amp;</code>)。</li><li>支持所有数字HTML实体。</li><li>该API当前仅支持以下命名的HTML实体： <code>&amp;lt;</code>, <code>&amp;gt;</code>, <code>&amp;amp;</code> and <code>&amp;quot;</code>。</li><li>使用嵌套的pre和code标签，为pre实体定义编程语言。</li><li>不能为独立code标签指定编程语言。</li></ul><h3 id="Markdown-style"><a href="#Markdown-style" class="headerlink" title="Markdown style"></a>Markdown style</h3><p>这是旧版模式，保留下来是为了向后兼容。要使用此模式，请在parse_mode字段中传递Markdown。在您的消息中使用以下语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*bold text*</span></span><br><span class="line"><span class="emphasis">_italic text_</span></span><br><span class="line">[<span class="string">inline URL</span>](<span class="link">http://www.example.com/</span>)</span><br><span class="line">[<span class="string">inline mention of a user</span>](<span class="link">tg://user?id=123456789</span>)</span><br><span class="line"><span class="code">`inline fixed-width code`</span></span><br><span class="line">​<span class="code">```</span></span><br><span class="line"><span class="code">pre-formatted fixed-width code block</span></span><br><span class="line"><span class="code">​```</span></span><br><span class="line">​<span class="code">```python</span></span><br><span class="line"><span class="code">pre-formatted fixed-width code block written in the Python programming language</span></span><br><span class="line"><span class="code">​```</span></span><br></pre></td></tr></table></figure><p>请注意：</p><ul><li>实体不得嵌套，而应使用解析模式<code>MarkdownV2</code>。</li><li>无法指定下划线和删除线实体，请改用解析模式<code>MarkdownV2</code>。</li><li>要在实体外部转义字符<code>_</code>，<code>*</code>，`，<code>[</code>，请在字符之前加上<code>\</code>。</li><li>不允许在实体内部转义，因此必须先关闭实体再重新打开：对于斜体使用<code>_snake_\__case_</code>，对于粗体<code>2*2=4</code>使用 <code>snake_case</code> 和 <code>*2*\**2=4*</code>。</li></ul><h2 id="telegram更新"><a href="#telegram更新" class="headerlink" title="telegram更新"></a>telegram更新</h2><p>telegram中更新指的是机器人是否有收到新的消息，具体有哪些消息可以查看<code>telegram对象</code>部分中的<code>Update</code>，获取更新的方式有两种1. 轮询，2.webhook</p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>这是一种主动询问的方式，这种方式比较简单但是效率欠佳，具体操作是，开发者每个一段时间请求一次<code>getUpdates</code>方法，从获取结果中判断update有无更新，有关<code>update</code>对象的描述可看<code>telegram对象</code>章节</p><h3 id="webhook"><a href="#webhook" class="headerlink" title="webhook"></a>webhook</h3><p>webhook可以理解为客户端给服务端的api,只要服务端一有更新就会主动将内容发送到客户端设置的一个api中，然后客户端收到消息后可做相应处理。</p><p><strong>给我们的机器人设置webhook</strong></p><p>通过<code>setWebhook</code>方法设置（前面有介绍），需要注意的是，telegram只支持<code>https</code>协议，所以我们的api服务器必须要有TLS证书，必须注意一但我们设置了webhook那么通过<code>getUpdates</code>方法将不起作用！</p><h2 id="telegram中的命令"><a href="#telegram中的命令" class="headerlink" title="telegram中的命令"></a>telegram中的命令</h2><p>通过命令来和机器人交互是电报机器人的一大特色，在telegram中命令由实体<code>BotCommand</code>表示（telegram对象那节已经介绍过）。</p><p>其实任何以<code>/</code>开头的连续英文消息都被视作命令(可以理解为这是一种具有格式的普通消息)，私聊或者在群里@机器人时发送<code>/</code>开头的信息可以查看实体类型为<code>bot_command</code>。要想让机器人收到某条命令后执行响应动作只需要判断发送的消息是否匹配我们约定的内容即刻，（从某种意义上讲无论发送的消息是否是命令格式我们都可以将其视为命令只要我们愿意），开发具有命令响应的过程总结如下：</p><ol><li>起一个死循环监听<code>update</code>的<code>message</code>消息，可以是轮询或者webhook方式</li><li>拿到<code>update.id</code>检查其是否更新，如有更新则取<code>message.Text</code>匹配已经定义好的<code>路由</code>（这是我定义的叫法，也就是我们约定的命令，事实上他的确和路由很像）</li><li>如果匹配成功，执行我们定义的方法，如果匹配失败则当做普通信息无视，或者返回对应信息</li></ol><p>从上面过程可以看出命令是否是<code>/</code>开头其实已经不那么重要了，那么为什么官方要定义<code>BotCommand</code>类呢，理由（优点）如下</p><ol><li>用以和普通消息区分</li><li>在聊天消息中命令会高亮显示</li><li>已经注册的命令在对话框中只需要输入<code>/</code>就会有提示列表</li></ol><h3 id="给机器人注册指令"><a href="#给机器人注册指令" class="headerlink" title="给机器人注册指令"></a>给机器人注册指令</h3><p><strong>手动注册</strong></p><ol><li><p>和<code>botFather</code>对话，输入<code>/mybot</code></p></li><li><p>选择要注册指令的机器人</p></li><li><p>选择<code>Edit Bot</code>选项</p></li><li><p>选择<code>Edit Commands</code></p></li><li><p>输入你想定义的命令，格式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 - 描述</span><br><span class="line">command2 - Description</span><br></pre></td></tr></table></figure><p>注意：注册时命令开头没有斜杠，使用命令时需要带上斜杠，中间用 <code>-</code> 分割；每一次的命令编辑都会覆盖之前的命令而不是追加，所以必须一次发送全部命令（在对话框中按<code>shift + enter</code>换行），另外命令不能使用驼峰命名法</p></li></ol><p><strong>通过<code>setMyCommands</code>方法注册</strong></p><ul><li>详见（telegram方法 setMyCommands）</li></ul><h3 id="查看已注册的指令"><a href="#查看已注册的指令" class="headerlink" title="查看已注册的指令"></a>查看已注册的指令</h3><ul><li>详见（telegram方法 getMyCommands）</li></ul><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><p>telegram建议我们的机器人都带上三条基本指令分别是</p><ul><li><code>/start</code></li><li><code>/help</code></li><li><code>/settings</code></li></ul><p>当设置了上面三个命令，用户首次打开与你的机器人的对话时，将看到<code>Start</code>按钮。机器人的个人资料页面上的菜单中将提供<code>Help</code>和<code>Settings</code>链接。</p><h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><p>telegram中键盘也是机器人的一大特色，开发者可以自定义自己的键盘，一个键盘相当于机器人的菜单可以理解为一个答复界面，可以更加方便的和机器人交互。</p><p>telegram中的键盘有四种<code>ReplyKeyboardMarkup</code>，<code>InlineKeyboardMarkup</code>，<code>ReplyKeyboardRemove</code>和<code>ForceReply</code>，这四个对象可参考前面的介绍</p><h3 id="创建键盘"><a href="#创建键盘" class="headerlink" title="创建键盘"></a>创建键盘</h3><p>只需要在<code>sendMessage</code>时指定<code>reply_markup</code>即可，详见<code>sendMessage</code>方法</p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> telegram </tag>
            
            <tag> bot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go get 私有库</title>
      <link href="/2020/09/01/go-get-%E7%A7%81%E6%9C%89%E5%BA%93/"/>
      <url>/2020/09/01/go-get-%E7%A7%81%E6%9C%89%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="go-get-私有库的方式"><a href="#go-get-私有库的方式" class="headerlink" title="go get 私有库的方式"></a>go get 私有库的方式</h2><ol><li><p>将本地的ssh公钥添加进私有git服务器</p></li><li><p>使用git协议拉取代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --add url.<span class="string">&quot;git@git.balabala.xxx:&quot;</span>.insteadOf <span class="string">&quot;https://git.balabala.xxx/&quot;</span>  </span><br></pre></td></tr></table></figure></li><li><p>设置GOPRIVATE环境变量为私有服务器地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPRIVATE=git.balabala.xxx/*</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议概述</title>
      <link href="/2020/08/16/HTTP%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/08/16/HTTP%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议概述"><a href="#HTTP协议概述" class="headerlink" title="HTTP协议概述"></a>HTTP协议概述</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>HTTP协议并不是什么高深的协议，相反正式因为HTTP协议足够简单所以它才会被广泛的使用。</p><h2 id="2-什么是协议"><a href="#2-什么是协议" class="headerlink" title="2. 什么是协议"></a>2. 什么是协议</h2><p>很多人不理解http协议其实是因为不理解<code>协议</code>或者说是自己将协议复杂化。其实协议很简单，就是一个约定。</p><p><strong>举个例子</strong></p><p>在你的电脑上有许多文件<code>1.txt 2.txt 3.txt ...</code>, 现在我想通过互联网来从你的电脑上获取这些文件。为了完成这一目的我们需要以下几步</p><ol><li><p>首先我需要在互联网上和你的电脑建立连接，为了保证传输的稳定性我们选择使用TCP协议（不理解TCP协议的同学，先简单的理解为负责传输我们数据的一种方式）来建立我们的连接。</p></li><li><p>建立连接后我发消息告诉你我想要的文件，你接收到我的消息后将对应的文件发送给我。</p><ul><li><p>这时就有一些问题，你的程序处理我发送消息是死板的，比如我发送<code>给我1.txt</code>和<code>把 1.txt 给我</code>对我来说都是一样的目的，但是你的程序解读时是不一样的。</p></li><li><p>为了解决这个问题我们必须统一我发送请求的格式，这样你的程序解读时就比较方便，因为有了固定的格式</p><p>比如我们约定如果我想获取你电脑上的文件我发送的请求格式就必须为<code>GET 文件名 \r\n</code>, 其中<code>GET</code>代表你这次的请求目的是<code>获取</code>，然后空一格写上你想要的文件名，最后用<code>\r\n</code> 代表请求结束</p></li><li><p>有了这种统一的约定就会很方便的实现一些功能</p></li></ul></li></ol><p>我们上面举的例子中的<code>约定</code>就是所谓的<code>协议</code></p><h2 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h2><p>HTTP的全称是<code>HyperText Transfer Protocol</code>中文叫做超文本传输协议，所谓的超文本其实就是<code>HTML</code>文件，把上面例子中的<code>txt文件</code>换成<code>html</code>文件，那么那就是HTTP的第一个版本(HTTP/0.9)，http是c/s模式的，从上面的例子我们可以看出<code>我</code>扮演的就是客户端,<code>你</code>扮演的就是服务端。其实随着http协议的发展其可以传送的文件类型几乎可以是任何类型</p><p><strong>为什么要叫html文件为超文本</strong></p><p>因为html文件里可以包含超链接（就是URL，他只是字符串，不要理解为超链接有特殊功能，哪些跳转功能都是浏览器实现的），它指向了网络中另外一处的资源，这样html可以组织互联网中的资源，可能是这样比较高级吧所以发明者称之为<code>超文本</code>。</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p><code>http/1.1</code>是http版本的一种，是标准化的协议，发布于1997年，时至今日<code>http/1.1</code>仍然是使用最广泛的协议。</p><p>在<code>HTTP/1.0</code>的时候引入了请求头的概念，我们可以通过设置请求头可能很方便的对HTTP协议进行拓展。</p><h3 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h3><p>http协议定义的请求格式由4个部分组成，分别是<code>请求行</code>，<code>请求头</code>，<code>空行</code>，<code>请求体</code></p><ul><li><p>请求行</p><p>指定请求的方法，路径，协议版本</p></li><li><p>请求头</p><p>以键值对的方式设置一些需要告诉服务端的其他信息，比如<code>User-Agent: Firefox</code>代表你的用户代理是Firefox</p></li><li><p>空行</p><p>就是普通的空行，分割上面的头部和下面的请求体</p></li><li><p>请求体</p><p>像<code>POST</code>这类方法需要发送而外的请求信息就会把要发送的数据放在请求体中</p></li></ul><h3 id="响应例子"><a href="#响应例子" class="headerlink" title="响应例子"></a>响应例子</h3><p>http协议定义的响应格式同请求格式类似，也是由四个部分组成：<code>响应行</code>，<code>响应头</code>，<code>空行</code>，<code>响应体</code></p><ul><li><p>响应行</p><p>http的版本，响应状态码，响应信息</p></li><li><p>响应头</p><p>以键值对的方式设置一些需要告诉客户端的其他信息，比如：<code>Content-Type: text/html</code>代表传给你的文件类型是html</p></li><li><p>空行</p><p>就是普通的空行，分割上面的头部和下面的响应体</p></li><li><p>响应体</p><p>客户端请求的数据将会放在响应体中返回</p></li></ul><p><strong>举个例子</strong></p><p>为了更好的阅读，在下面我会将<code>\r\n</code>（回车换行符）用折行来显示，比如</p><p><code>aaaaa \r\n bbb</code></p><p>显示为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaaaa</span><br><span class="line">bbb</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;GET &#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;Simple_header HTTP&#x2F;1.1</span><br><span class="line">&gt;Host: developer.mozilla.org</span><br><span class="line">&gt;User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko&#x2F;20100101 Firefox&#x2F;50.0</span><br><span class="line">&gt;Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">&gt;Accept-Language: en-US,en;q&#x3D;0.5</span><br><span class="line">&gt;Accept-Encoding: gzip, deflate, br</span><br><span class="line">&gt;Referer: https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;Simple_header</span><br><span class="line"></span><br><span class="line">&gt;HTTP&#x2F;1.1 200 OK</span><br><span class="line">&gt;Connection: Keep-Alive</span><br><span class="line">&gt;Content-Encoding: gzip</span><br><span class="line">&gt;Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">&gt;Date: Wed, 20 Jul 2016 10:55:30 GMT</span><br><span class="line">&gt;Etag: &quot;547fa7e369ef56031dd3bff2ace9fc0832eb251a&quot;</span><br><span class="line">&gt;Keep-Alive: timeout&#x3D;5, max&#x3D;1000</span><br><span class="line">&gt;Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT</span><br><span class="line">&gt;Server: Apache</span><br><span class="line">&gt;Transfer-Encoding: chunked</span><br><span class="line">&gt;Vary: Cookie, Accept-Encoding</span><br><span class="line"></span><br><span class="line">&gt;(content)</span><br></pre></td></tr></table></figure></blockquote><p>  <strong>解读</strong></p><ul><li>请求部分</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;Simple_header HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><p>GET方法</p><p>请求地址：/en-US/docs/Glossary/Simple_header</p><p>HTTP版本：HTTP/1.1</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host: developer.mozilla.org</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko&#x2F;20100101 Firefox&#x2F;50.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: en-US,en;q&#x3D;0.5</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Referer: https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Glossary&#x2F;Simple_header</span><br></pre></td></tr></table></figure><p>请求头部分，数据以键值对的方式存放，请求头中的key种类繁多，每种请求按需取用，这里代表的意思是</p><p>请求主机: developer.mozilla.org</p><p>用户代理（你是谁）：Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0</p><p>接受的类型（这个类型展开又可以讲很多）：text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8</p><p>接受的自然语言：en-US,en;q=0.5</p><p>接受的编码方式：gzip, deflate, br</p><p>从哪里跳转过来：<a href="https://developer.mozilla.org/en-US/docs/Glossary/Simple_header">https://developer.mozilla.org/en-US/docs/Glossary/Simple_header</a></p></blockquote><blockquote><p>由于这里GET请求没有没有携带而外参数，所以就没有请求体</p></blockquote><ul><li>响应部分</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br></pre></td></tr></table></figure><p>HTTP协议：HTTP/1.1</p><p>响应状态码: 200</p><p>响应状态描述: OK</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">Date: Wed, 20 Jul 2016 10:55:30 GMT</span><br><span class="line">Etag: &quot;547fa7e369ef56031dd3bff2ace9fc0832eb251a&quot;</span><br><span class="line">Keep-Alive: timeout&#x3D;5, max&#x3D;1000</span><br><span class="line">Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Vary: Cookie, Accept-Encoding</span><br></pre></td></tr></table></figure><p>响应头</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>空行</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(content)</span><br></pre></td></tr></table></figure><p>响应体内容</p></blockquote><h2 id="HTTP的特点"><a href="#HTTP的特点" class="headerlink" title="HTTP的特点"></a>HTTP的特点</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><p>http是比较简单的应用层协议，通过一些列请求方法来区分不同功能的请求，通过URL来在互联网上定位资源，通过头部来携带一些其他数据，通过Body来携带数据，而且HTTP/1.1及其之前的数据报都是可以阅读的。</p><h3 id="可拓展"><a href="#可拓展" class="headerlink" title="可拓展"></a>可拓展</h3><p>由于HTTP/1.0开始引入了头部概念，所以我们可以通过添加自己的头部信息来实现自定义的功能。</p><h3 id="无状态，有会话的"><a href="#无状态，有会话的" class="headerlink" title="无状态，有会话的"></a>无状态，有会话的</h3><p>从上面的例子可以看出每一次请求之间都是孤立的没有联系的，也就是说HTTP请求是无状态的，这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。为了解决这个问题，我们可以在头部加一个字段本质上取名可以任意，但是为了统一我们将这个字段的名称取为<code>Cookie</code>，我们把商品信息加入到这个字段中，然后每次请求都带上<code>Cookie</code>这个字段就实现了有状态的会话。</p><h2 id="HTTP-1-x的缺点"><a href="#HTTP-1-x的缺点" class="headerlink" title="HTTP/1.x的缺点"></a>HTTP/1.x的缺点</h2><p>HTTP是传输层上的应用层协议，最常见的传输层协议有两种<code>UDP</code>，<code>TCP</code>为了稳定起见，HTTP选择了TCP协议。但是建立TCP比较耗时，而且通常一个网页会同时会发起多个HTTP请求，由于HTTP/1.x不能复用一个TCP连接所以每个HTTP请求都会单独开一个TCP连接，这将非常低效。为了减轻这些缺陷，HTTP/1.1引入了流水线（被证明难以实现）和持久连接的概念：底层的TCP连接可以通过Connection头部来被部分控制。HTTP/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang中使用gRPC</title>
      <link href="/2020/07/18/golang%E4%B8%AD%E4%BD%BF%E7%94%A8gRPC/"/>
      <url>/2020/07/18/golang%E4%B8%AD%E4%BD%BF%E7%94%A8gRPC/</url>
      
        <content type="html"><![CDATA[<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC(Remote Procedure Call: 远程过程调用)是一个计算机通信协议，该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。</p><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>gRPC 一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。（<a href="http://doc.oschina.net/grpc%EF%BC%89">http://doc.oschina.net/grpc）</a></p><p>在 gRPC 里<em>客户端</em>应用可以像调用本地对象一样直接调用另一台不同的机器上<em>服务端</em>应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个<em>服务</em>，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个<em>存根</em>能够像服务端一样的方法。</p><p>gRPC 默认使用 <em>protocol buffers</em>，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）。</p><p>使用gRPC分为三步</p><ul><li>编写.proto文件</li><li>利用工具将.proto文件生成对应语言的代码</li><li>根据生成的代码编写服务端和客户端的代码</li></ul><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>首先我们需要安装将.proto文件生成对应代码的工具，下载地址（<a href="https://github.com/protocolbuffers/protobuf/releases%EF%BC%89%EF%BC%8C%E4%B8%8B%E8%BD%BD%E4%BD%A0%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%8D%B3%E5%8F%AF%E3%80%82%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%E8%A7%A3%E5%8E%8B%E5%B0%86%E5%85%B6bin%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%94%BE%E5%85%A5%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8D%B3%E5%8F%AF%E3%80%82">https://github.com/protocolbuffers/protobuf/releases），下载你对应操作系统的压缩包即可。下载完成后解压将其bin目录下的可执行文件放入环境变量中的文件夹即可。</a></p><p>此外，我们还需要安装对应语言的插件，比如</p><p>go语言插件安装方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go</span><br></pre></td></tr></table></figure><p>python插件安装方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install grpcio</span><br><span class="line">pip install protobuf</span><br><span class="line">pip install grpcio_tools</span><br></pre></td></tr></table></figure><p>接下来我将以一个例子来做演示介绍如何在go中使用gRPC,注意我将采用go module的方式来编写这个demo,</p><p>首先我们在一个你喜欢的文件夹下面新建一个文件夹命名为<code>hello_grpc</code>，然后在<code>hello_grpc</code>文件夹下新建一个go.mod文件并写入一下内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module <span class="string">&quot;hello_grpc&quot;</span></span><br></pre></td></tr></table></figure><p>然后用你喜欢的IDE打开这个文件夹，进行之后的操作</p><h2 id="1-编写-proto文件"><a href="#1-编写-proto文件" class="headerlink" title="1. 编写.proto文件"></a>1. 编写.proto文件</h2><p>我们在项目的根目录下新建名为<code>pb</code>的文件夹,然后新建名为<code>hello_grpc.proto</code>的文件，写入如下内容,这是一个官方的例子</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">service</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">option</span> go_package = &quot;.;hello_grpc&quot;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">service Greeter </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>其中第一行指定了我们使用 protocol buffers的版本</p><p>下面我们定义了包的名称，这将成为后面我们生成的go语言的代码的包名</p><p>然后我们定义了一个服务名为Greeter，其中定义了一个函数SayHello它的参数定义在HelloRequest，返回值定义在HelloReply</p><p>关于proto的服务，一共有4种类型，此例子中是最简单的一种</p><ul><li><p><em>简单 RPC</em> </p><p>客户端使用存根发送请求到服务器并等待响应返回，就像平常的函数调用一样。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> GetFeature(Point) <span class="keyword">returns</span> (Feature) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>服务器端流式 RPC</em> </p><p>客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。从例子中可以看出，通过在 <em>响应</em> 类型前插入 <code>stream</code> 关键字，可以指定一个服务器端的流方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>客户端流式 RPC</em> </p><p>客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦客户端完成写入消息，它等待服务器完成读取返回它的响应。通过在 <em>请求</em> 类型前指定 <code>stream</code> 关键字来指定一个客户端的流方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>双向流式 RPC</em></p><p>是双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器可以以任意喜欢的顺序读写：比如， 服务器可以在写入响应前等待接收所有的客户端消息，或者可以交替的读取和写入消息，或者其他读写的组合。 每个流中的消息顺序被预留。你可以通过在请求和响应前加 <code>stream</code> 关键字去制定方法的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-生成对应语言的代码"><a href="#2-生成对应语言的代码" class="headerlink" title="2. 生成对应语言的代码"></a>2. 生成对应语言的代码</h2><p>在我们项目的根目录下新建<code>service</code>目录（这将用来存放我们生成的golang代码），然后打开终端，输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I pb&#x2F; pb&#x2F;hello_grpc.proto --go_out&#x3D;plugins&#x3D;grpc:service</span><br></pre></td></tr></table></figure><p><code>-I</code> 后面指定proto文件存放目录，和proto文件 </p><p><code>--go_out=plugins=grpc:</code>后面指定生成go代码存放的目录</p><p>检查在service目录下是否成功生成一个名为<code>hello_grpc.pb.go</code>的文件</p><p>打开这个文件发现抱错，原因是我们的项目中还没有安装相应的包，输入以下命令安装</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> mod tidy</span><br></pre></td></tr></table></figure><h2 id="3-编写服务端和客户端的代码"><a href="#3-编写服务端和客户端的代码" class="headerlink" title="3.编写服务端和客户端的代码"></a>3.编写服务端和客户端的代码</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>在根目录下新建文件夹<code>server</code>然在这个文件夹下新建<code>server.go</code>，写入以下内容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;hello_grpc/service&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc/reflection&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *service.HelloRequest)</span> <span class="params">(*service.HelloReply, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;service.HelloReply&#123;Message: <span class="string">&quot;hello &quot;</span> + in.Name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 监听本地端口</span></span><br><span class="line">lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;监听端口失败: %s&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建gRPC服务器</span></span><br><span class="line">s := grpc.NewServer()</span><br><span class="line"><span class="comment">// 注册服务</span></span><br><span class="line">service.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line"></span><br><span class="line">reflection.Register(s)</span><br><span class="line"></span><br><span class="line">err = s.Serve(lis)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;开启服务失败: %s&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里先定义了一个结构体，该结构体需要实现<code>GreeterServer</code>这个接口(见生成的代码，如下)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GreeterServer <span class="keyword">interface</span> &#123;</span><br><span class="line">SayHello(context.Context, *HelloRequest) (*HelloReply, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p>同理在项目根目录下新建<code>client/client.go</code>写入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;hello_grpc/service&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 连接服务器</span></span><br><span class="line">conn, err := grpc.Dial(<span class="string">&quot;:8080&quot;</span>, grpc.WithInsecure())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;连接服务端失败: %s&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个客户端</span></span><br><span class="line">c := service.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用服务端函数</span></span><br><span class="line">r, err := c.SayHello(context.Background(), &amp;service.HelloRequest&#123;Name: <span class="string">&quot;horika&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;调用服务端代码失败: %s&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;调用成功: %s&quot;</span>, r.Message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-运行"><a href="#4-运行" class="headerlink" title="4. 运行"></a>4. 运行</h2><ul><li><p>先运行服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run server&#x2F;server.go</span><br></pre></td></tr></table></figure></li><li><p>开新的终端运行客户端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run client/client.<span class="keyword">go</span></span><br></pre></td></tr></table></figure></li><li><p>观察客户端输出</p></li></ul><h2 id="5-番外篇：编写跨语言调用"><a href="#5-番外篇：编写跨语言调用" class="headerlink" title="5. 番外篇：编写跨语言调用"></a>5. 番外篇：编写跨语言调用</h2><p>以python为例，这里就不编写python的服务端了，直接编写python的客户端调用go的服务端</p><p>注意：你是否安装python的插件？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install grpcio</span><br><span class="line">pip install protobuf</span><br><span class="line">pip install grpcio_tools</span><br></pre></td></tr></table></figure><h3 id="生成python代码"><a href="#生成python代码" class="headerlink" title="生成python代码"></a>生成python代码</h3><p>在项目跟目录下新建文件夹<code>python</code>然后在根目录下打开终端输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I pb&#x2F; --python_out&#x3D;python&#x2F; --grpc_python_out&#x3D;python&#x2F; pb&#x2F;hello_grpc.proto</span><br></pre></td></tr></table></figure><p>在刚刚新建的文件夹下查看是否多出来了两个文件<code>hello_grpc_pb2.py</code>和<code>hello_grpc_pb2_grpc.py</code></p><h3 id="编写python客户端代码"><a href="#编写python客户端代码" class="headerlink" title="编写python客户端代码"></a>编写python客户端代码</h3><p>在python文件夹中新建client.py写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hello_grpc_pb2</span><br><span class="line"><span class="keyword">import</span> hello_grpc_pb2_grpc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">with</span> grpc.insecure_channel(<span class="string">&#x27;localhost:8080&#x27;</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = hello_grpc_pb2_grpc.GreeterStub(channel)</span><br><span class="line">        response = stub.SayHello(hello_grpc_pb2.HelloRequest(name=<span class="string">&#x27;horika&#x27;</span>))</span><br><span class="line">    print(<span class="string">&quot;调用成功: &#123;&#125;!&quot;</span>.format(response.message))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>运行go的服务端，然后运行python客户端查看输出</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang实现定时任务</title>
      <link href="/2020/07/18/golang%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2020/07/18/golang%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装cron"><a href="#1-安装cron" class="headerlink" title="1. 安装cron"></a>1. 安装cron</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com&#x2F;robfig&#x2F;cron</span><br></pre></td></tr></table></figure><h2 id="2-先看一个例子"><a href="#2-先看一个例子" class="headerlink" title="2. 先看一个例子"></a>2. 先看一个例子</h2><p>这个例子将会每秒钟打印 一次<code>hello world</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/robfig/cron&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">c := cron.New()</span><br><span class="line">_ = c.AddFunc(<span class="string">&quot;* * * * * *&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">c.Start()</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做几点说明：</p><ul><li>cron.New() 创建一个cron对象</li><li>cron对象通过AddFunc方法将一个函数按指定的时间计划执行</li><li><code>* * * * * *</code>就是我们的时间计划，这是指每秒执行一次，后面在详细讲</li><li>Start() 方法开始执行</li><li>time.Sleep(10 * time.Second) 防止主goroutine退出否则这个程序就会结束，任务将会无法执行</li></ul><h2 id="3-解决你的疑惑"><a href="#3-解决你的疑惑" class="headerlink" title="3. 解决你的疑惑"></a>3. 解决你的疑惑</h2><h3 id="time-Sleep-真的好吗？"><a href="#time-Sleep-真的好吗？" class="headerlink" title="time.Sleep() 真的好吗？"></a>time.Sleep() 真的好吗？</h3><p>我们知道这一个语句的作用是让主goroutine等待，对于一个定时任务来说主goroutine应该一直等待，time.Sleep()肯定不是最好的解决方法，那我们该怎么做呢</p><ul><li><p>勇敢的尝试 <code>死循环</code></p><p>注意一些IDE会提示死循环的错误，但其实是可以编译运行的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/robfig/cron&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">c := cron.New()</span><br><span class="line">_ = c.AddFunc(<span class="string">&quot;* * * * * *&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">c.Start()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这视乎达到了我们的效果，但是大家都明白这样做的后果，看下你的电脑cpu利用率，我的电脑cpu占用率是30%左右</p></li><li><p>利用select改进我们的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/robfig/cron&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">c := cron.New()</span><br><span class="line">_ = c.AddFunc(<span class="string">&quot;* * * * * *&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">c.Start()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我的电脑cpu占用率是10%左右</p><p>但这是真的是最好的版本吗？</p></li><li><p>for 和 select 结合</p><p>设置一个定时器</p><p>利用for加select等待</p><p>每当计时器可以取值时，重置计时器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t := time.NewTimer(time.Second * <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">t.Reset(time.Second * <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="* * * * * * 是什么？"></a>* * * * * * 是什么？</h3><p>这上面的例子中我们用<code>* * * * * *</code>来表示我们的定时计划，我已经告诉你们了，这表示每秒中执行一次，下面让我们详细的了解一下它的语法吧。</p><ul><li><p>这个字符串一共由6位组成，每一位之间用一个空格隔开，每一位的意思如下</p><p>第一位：秒</p><p>第二位：分</p><p>第三位：时</p><p>第四位：一月中的某天(日)</p><p>第五位：月</p><p>第六位：星期几</p></li><li><p>我们明白了位置的含义，那么这些符号又是什么意思呢</p><table><thead><tr><th>符号</th><th>表示的含义</th></tr></thead><tbody><tr><td>*</td><td>表示<code>每</code>的意思，比如在第一位就表示每秒</td></tr><tr><td>/</td><td>后跟数字表示<code>每隔</code>的意思，比如在第一位<code>*/10</code>，表示每隔10秒执行一次；<code>1-30/10</code>，表示从第一秒到第30秒每个10秒执行一次</td></tr><tr><td>,</td><td>枚举，比如第6个字段值是 MON,WED,FRI，表示 星期一、三、五 执行</td></tr><tr><td>-</td><td>表示范围，比如第一位<code>1-30</code>表示第一秒到第30秒每秒执行一次</td></tr><tr><td>?</td><td>只用于 第四位 和 第六位，表示不指定值，可以用于代替 *</td></tr><tr><td>具体的数字</td><td>表示具体的时刻，比如第一位是<code>5</code>表示第5秒执行</td></tr></tbody></table></li></ul><h2 id="4-一些常用表达式举例"><a href="#4-一些常用表达式举例" class="headerlink" title="4. 一些常用表达式举例"></a>4. 一些常用表达式举例</h2><table><thead><tr><th>含义</th><th>表达式</th></tr></thead><tbody><tr><td>每隔10秒执行一次</td><td>*/10 * * * * *</td></tr><tr><td>每个10分钟执行一次</td><td>0 */10 * * * *</td></tr><tr><td>每天0点0时0分执行一次</td><td>0 0 0 * * *</td></tr><tr><td>每天9点18点执行一次</td><td>0 0 9,18 * * *</td></tr></tbody></table><p>其实cron也给了一些预定义的表达式</p><table><thead><tr><th>预置表达式</th><th>描述</th><th>表达式</th></tr></thead><tbody><tr><td>@yearly (or @annually)</td><td>1 月 1 日午夜运行一次</td><td>0 0 0 1 1 *</td></tr><tr><td>@monthly</td><td>每个月的午夜，每个月的第一个月运行一次</td><td>0 0 0 1 * *</td></tr><tr><td>@weekly</td><td>每周一次，周日午夜运行一次</td><td>0 0 0 * * 0</td></tr><tr><td>@daily (or @midnight)</td><td>每天午夜运行一次</td><td>0 0 0 * * *</td></tr><tr><td>@hourly</td><td>每小时运行一次</td><td>0 0 * * * *</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang使用zap日志库</title>
      <link href="/2020/07/17/golang%E4%BD%BF%E7%94%A8zap%E6%97%A5%E5%BF%97%E5%BA%93/"/>
      <url>/2020/07/17/golang%E4%BD%BF%E7%94%A8zap%E6%97%A5%E5%BF%97%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-为什么使用zap"><a href="#1-为什么使用zap" class="headerlink" title="1. 为什么使用zap"></a>1. 为什么使用zap</h2><p>因为它很快，而且我写不出比他更快的日志库😭</p><p>当然他还有其他优点，比如：它同时提供了结构化日志记录和printf风格的日志记录</p><h2 id="2-安装zap"><a href="#2-安装zap" class="headerlink" title="2. 安装zap"></a>2. 安装zap</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u go.uber.org/zap</span><br></pre></td></tr></table></figure><h2 id="3-配置zap"><a href="#3-配置zap" class="headerlink" title="3. 配置zap"></a>3. 配置zap</h2><p>zap提供两种日志记录器，如下表</p><table><thead><tr><th>名称</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Sugared Logger</td><td>支持结构化和printf风格的日志记录</td><td>较Logger慢</td></tr><tr><td>Logger</td><td>较Sugared Logger快</td><td>只支持强类型的结构化日志记录</td></tr></tbody></table><h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><ul><li>创建Logger<ul><li>zap.NewProduction()</li><li>zap.NewDevelopment()</li><li>zap.Example()</li></ul></li><li>上述函数均可创建Logger只是输出信息不同</li><li>默认情况下日志会打印到控制台</li></ul><p>举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logger *zap.Logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProductionLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">logger,_ = zap.NewProduction()</span><br><span class="line">logger.Info(<span class="string">&quot;log info&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DevelopmentLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">logger,_ = zap.NewDevelopment()</span><br><span class="line">logger.Info(<span class="string">&quot;log info&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">logger = zap.NewExample()</span><br><span class="line">logger.Info(<span class="string">&quot;log info&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ProductionLogger()</span><br><span class="line">DevelopmentLogger()</span><br><span class="line">ExampleLogger()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;ts&quot;:1594976812.8990078,&quot;caller&quot;:&quot;go_zap&#x2F;main.go:9&quot;,&quot;msg&quot;:&quot;log info&quot;&#125;</span><br><span class="line">2020-07-17T17:06:52.899+0800INFOgo_zap&#x2F;main.go:14log info</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;log info&quot;&#125;</span><br></pre></td></tr></table></figure><p>除DevelopmentLogger之外其余都是json格式输出</p><h3 id="Sugared-Logger"><a href="#Sugared-Logger" class="headerlink" title="Sugared Logger"></a>Sugared Logger</h3><ul><li>创建Sugared Logger<ul><li>由Logger调用Sugar()方法获得</li></ul></li><li>支持printf风格输出日志</li></ul><p>举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sugarLogger *zap.SugaredLogger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProductionLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">logger,_ := zap.NewProduction()</span><br><span class="line">sugarLogger = logger.Sugar()</span><br><span class="line">sugarLogger.Infof(<span class="string">&quot;sugar loger %s&quot;</span>, <span class="string">&quot;yes!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DevelopmentLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">logger,_ := zap.NewDevelopment()</span><br><span class="line">sugarLogger = logger.Sugar()</span><br><span class="line">sugarLogger.Infof(<span class="string">&quot;sugar loger %s&quot;</span>, <span class="string">&quot;yes!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleLogger</span><span class="params">()</span></span>&#123;</span><br><span class="line">logger := zap.NewExample()</span><br><span class="line">sugarLogger = logger.Sugar()</span><br><span class="line">sugarLogger.Infof(<span class="string">&quot;sugar loger %s&quot;</span>, <span class="string">&quot;yes!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ProductionLogger()</span><br><span class="line">DevelopmentLogger()</span><br><span class="line">ExampleLogger()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;ts&quot;:1594977351.4368348,&quot;caller&quot;:&quot;go_zap&#x2F;main.go:10&quot;,&quot;msg&quot;:&quot;sugar loger yes!&quot;&#125;</span><br><span class="line">2020-07-17T17:15:51.436+0800INFOgo_zap&#x2F;main.go:16sugar loger yes!</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;sugar loger yes!&quot;&#125;</span><br></pre></td></tr></table></figure><p>输出结果和Logger类似，但是sugarLogger支持printf</p><h2 id="4-定制Logger"><a href="#4-定制Logger" class="headerlink" title="4. 定制Logger"></a>4. 定制Logger</h2><p>上面所介绍到的三个创建Logger的方法包含了一些预置的配置，如果我们想要完全自定义，那我们就需要自己写好自己需要的配置。</p><p>这些配置将被赋值给<code>zap.Config</code>结构体，然后这个结构体对象调用<code>Build</code>方法构造Logger，大概就像这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config := zap.Config&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log, err := config.Build()</span><br></pre></td></tr></table></figure><h3 id="zap-Config"><a href="#zap-Config" class="headerlink" title="zap.Config"></a>zap.Config</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Level is the minimum enabled logging level. Note that this is a dynamic</span></span><br><span class="line"><span class="comment">// level, so calling Config.Level.SetLevel will atomically change the log</span></span><br><span class="line"><span class="comment">// level of all loggers descended from this config.</span></span><br><span class="line">Level AtomicLevel <span class="string">`json:&quot;level&quot; yaml:&quot;level&quot;`</span></span><br><span class="line"><span class="comment">// Development puts the logger in development mode, which changes the</span></span><br><span class="line"><span class="comment">// behavior of DPanicLevel and takes stacktraces more liberally.</span></span><br><span class="line">Development <span class="keyword">bool</span> <span class="string">`json:&quot;development&quot; yaml:&quot;development&quot;`</span></span><br><span class="line"><span class="comment">// DisableCaller stops annotating logs with the calling function&#x27;s file</span></span><br><span class="line"><span class="comment">// name and line number. By default, all logs are annotated.</span></span><br><span class="line">DisableCaller <span class="keyword">bool</span> <span class="string">`json:&quot;disableCaller&quot; yaml:&quot;disableCaller&quot;`</span></span><br><span class="line"><span class="comment">// DisableStacktrace completely disables automatic stacktrace capturing. By</span></span><br><span class="line"><span class="comment">// default, stacktraces are captured for WarnLevel and above logs in</span></span><br><span class="line"><span class="comment">// development and ErrorLevel and above in production.</span></span><br><span class="line">DisableStacktrace <span class="keyword">bool</span> <span class="string">`json:&quot;disableStacktrace&quot; yaml:&quot;disableStacktrace&quot;`</span></span><br><span class="line"><span class="comment">// Sampling sets a sampling policy. A nil SamplingConfig disables sampling.</span></span><br><span class="line">Sampling *SamplingConfig <span class="string">`json:&quot;sampling&quot; yaml:&quot;sampling&quot;`</span></span><br><span class="line"><span class="comment">// Encoding sets the logger&#x27;s encoding. Valid values are &quot;json&quot; and</span></span><br><span class="line"><span class="comment">// &quot;console&quot;, as well as any third-party encodings registered via</span></span><br><span class="line"><span class="comment">// RegisterEncoder.</span></span><br><span class="line">Encoding <span class="keyword">string</span> <span class="string">`json:&quot;encoding&quot; yaml:&quot;encoding&quot;`</span></span><br><span class="line"><span class="comment">// EncoderConfig sets options for the chosen encoder. See</span></span><br><span class="line"><span class="comment">// zapcore.EncoderConfig for details.</span></span><br><span class="line">EncoderConfig zapcore.EncoderConfig <span class="string">`json:&quot;encoderConfig&quot; yaml:&quot;encoderConfig&quot;`</span></span><br><span class="line"><span class="comment">// OutputPaths is a list of URLs or file paths to write logging output to.</span></span><br><span class="line"><span class="comment">// See Open for details.</span></span><br><span class="line">OutputPaths []<span class="keyword">string</span> <span class="string">`json:&quot;outputPaths&quot; yaml:&quot;outputPaths&quot;`</span></span><br><span class="line"><span class="comment">// ErrorOutputPaths is a list of URLs to write internal logger errors to.</span></span><br><span class="line"><span class="comment">// The default is standard error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that this setting only affects internal errors; for sample code that</span></span><br><span class="line"><span class="comment">// sends error-level logs to a different location from info- and debug-level</span></span><br><span class="line"><span class="comment">// logs, see the package-level AdvancedConfiguration example.</span></span><br><span class="line">ErrorOutputPaths []<span class="keyword">string</span> <span class="string">`json:&quot;errorOutputPaths&quot; yaml:&quot;errorOutputPaths&quot;`</span></span><br><span class="line"><span class="comment">// InitialFields is a collection of fields to add to the root logger.</span></span><br><span class="line">InitialFields <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;initialFields&quot; yaml:&quot;initialFields&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要特别注意的是<code>EncoderConfig</code>这个字段，它定义了我们输出的格式，根据他的提示我们来看看<code>zapcore.EncoderConfig</code>结构体</p><h3 id="zapcore-EncoderConfig"><a href="#zapcore-EncoderConfig" class="headerlink" title="zapcore.EncoderConfig"></a>zapcore.EncoderConfig</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An EncoderConfig allows users to configure the concrete encoders supplied by</span></span><br><span class="line"><span class="comment">// zapcore.</span></span><br><span class="line"><span class="keyword">type</span> EncoderConfig <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Set the keys used for each log entry. If any key is empty, that portion</span></span><br><span class="line"><span class="comment">// of the entry is omitted.</span></span><br><span class="line">MessageKey    <span class="keyword">string</span> <span class="string">`json:&quot;messageKey&quot; yaml:&quot;messageKey&quot;`</span></span><br><span class="line">LevelKey      <span class="keyword">string</span> <span class="string">`json:&quot;levelKey&quot; yaml:&quot;levelKey&quot;`</span></span><br><span class="line">TimeKey       <span class="keyword">string</span> <span class="string">`json:&quot;timeKey&quot; yaml:&quot;timeKey&quot;`</span></span><br><span class="line">NameKey       <span class="keyword">string</span> <span class="string">`json:&quot;nameKey&quot; yaml:&quot;nameKey&quot;`</span></span><br><span class="line">CallerKey     <span class="keyword">string</span> <span class="string">`json:&quot;callerKey&quot; yaml:&quot;callerKey&quot;`</span></span><br><span class="line">StacktraceKey <span class="keyword">string</span> <span class="string">`json:&quot;stacktraceKey&quot; yaml:&quot;stacktraceKey&quot;`</span></span><br><span class="line">LineEnding    <span class="keyword">string</span> <span class="string">`json:&quot;lineEnding&quot; yaml:&quot;lineEnding&quot;`</span></span><br><span class="line"><span class="comment">// Configure the primitive representations of common complex types. For</span></span><br><span class="line"><span class="comment">// example, some users may want all time.Times serialized as floating-point</span></span><br><span class="line"><span class="comment">// seconds since epoch, while others may prefer ISO8601 strings.</span></span><br><span class="line">EncodeLevel    LevelEncoder    <span class="string">`json:&quot;levelEncoder&quot; yaml:&quot;levelEncoder&quot;`</span></span><br><span class="line">EncodeTime     TimeEncoder     <span class="string">`json:&quot;timeEncoder&quot; yaml:&quot;timeEncoder&quot;`</span></span><br><span class="line">EncodeDuration DurationEncoder <span class="string">`json:&quot;durationEncoder&quot; yaml:&quot;durationEncoder&quot;`</span></span><br><span class="line">EncodeCaller   CallerEncoder   <span class="string">`json:&quot;callerEncoder&quot; yaml:&quot;callerEncoder&quot;`</span></span><br><span class="line"><span class="comment">// Unlike the other primitive type encoders, EncodeName is optional. The</span></span><br><span class="line"><span class="comment">// zero value falls back to FullNameEncoder.</span></span><br><span class="line">EncodeName NameEncoder <span class="string">`json:&quot;nameEncoder&quot; yaml:&quot;nameEncoder&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些字段都不难理解，让我们来写一个例子吧</p><h3 id="一个简单的样例"><a href="#一个简单的样例" class="headerlink" title="一个简单的样例"></a>一个简单的样例</h3><p>一般情况下我们都是用SugaredLogger因为它的速度足够快，而其功能更加强大，如果呢不知道该怎么选择不如就把两个都选上吧，就像这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line"><span class="string">&quot;go.uber.org/zap/zapcore&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Logger *zap.Logger</span><br><span class="line"><span class="keyword">var</span> SugarLogger *zap.SugaredLogger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span> <span class="title">error</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="comment">// 构造EncoderConfig</span></span><br><span class="line">encoderConfig := zapcore.EncoderConfig&#123;</span><br><span class="line">TimeKey: <span class="string">&quot;timestamp&quot;</span>,</span><br><span class="line">LevelKey: <span class="string">&quot;severity&quot;</span>,</span><br><span class="line">NameKey: <span class="string">&quot;logger&quot;</span>,</span><br><span class="line">CallerKey: <span class="string">&quot;caller&quot;</span>,</span><br><span class="line">MessageKey: <span class="string">&quot;message&quot;</span>,</span><br><span class="line">StacktraceKey: <span class="string">&quot;stacktrace&quot;</span>,</span><br><span class="line">LineEnding: <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">EncodeLevel: zapcore.LowercaseLevelEncoder,</span><br><span class="line">EncodeTime: zapcore.ISO8601TimeEncoder,</span><br><span class="line">EncodeDuration: zapcore.SecondsDurationEncoder,</span><br><span class="line">EncodeCaller:   zapcore.FullCallerEncoder,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 Config</span></span><br><span class="line">config := zap.Config&#123;</span><br><span class="line">Level: zap.NewAtomicLevelAt(zapcore.DebugLevel),</span><br><span class="line">Development: <span class="literal">true</span>,</span><br><span class="line">Encoding: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">EncoderConfig: encoderConfig,</span><br><span class="line">InitialFields: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;MyName&quot;</span>: <span class="string">&quot;kainhuck&quot;</span>&#125;,</span><br><span class="line">OutputPaths: []<span class="keyword">string</span>&#123;<span class="string">&quot;stdout&quot;</span>&#125;,</span><br><span class="line">ErrorOutputPaths: []<span class="keyword">string</span>&#123;<span class="string">&quot;stdout&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以构造Logger了</span></span><br><span class="line">Logger, err = config.Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后是SugarLogger</span></span><br><span class="line">SugarLogger = Logger.Sugar()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">err := Init()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SugarLogger.Debugf(<span class="string">&quot;ohhhhhhh err:%s&quot;</span>, <span class="string">&quot;horika&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;severity&quot;</span>:<span class="string">&quot;debug&quot;</span>,<span class="attr">&quot;timestamp&quot;</span>:<span class="string">&quot;2020-07-17T17:58:56.626+0800&quot;</span>,<span class="attr">&quot;caller&quot;</span>:<span class="string">&quot;D:/Coding/go_module/go_zap/main.go:56&quot;</span>,<span class="attr">&quot;message&quot;</span>:<span class="string">&quot;ohhhhhhh err:horika&quot;</span>,<span class="attr">&quot;MyName&quot;</span>:<span class="string">&quot;kainhuck&quot;</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang使用viper解析配置文件</title>
      <link href="/2020/07/12/golang%E4%BD%BF%E7%94%A8viper%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2020/07/12/golang%E4%BD%BF%E7%94%A8viper%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/spf13/viper">https://github.com/spf13/viper</a></p><p>安装方式：go get github.com/spf13/viper</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>viper是一个十分强大的配置文件解析工具，具有以下特点</p><ul><li>设置默认值</li><li>支持的文件包括JSON, TOML, YAML, HCL, envfile 和 Java properties 配置文件</li><li>实时监听和重新读取配置文件</li><li>从环境变量中读取</li><li>从远程配置系统（etcd或Consul）中读取，并监听更改</li><li>从命令行读取</li><li>从缓冲读取</li><li>设置显示值</li></ul><p><em>另外需要注意的是，viper对配置中的<code>key</code>是大小写不敏感的</em></p><p>下面我以YAML格式的配置文件为例，介绍viper的用法，其他跟多的用法请见<a href="https://github.com/spf13/viper">官网</a></p><h2 id="示例配置文件"><a href="#示例配置文件" class="headerlink" title="示例配置文件"></a>示例配置文件</h2><p>一个好的项目应该把配置文件分成两份，一份存放不敏感信息（比如项目运行端口），一份存放敏感信息（比如数据库密码），下面两个配置文件用作举例</p><p>public config <code>config/config/config.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">TimeStamp:</span> <span class="string">&quot;2018-07-16 10:23:19&quot;</span></span><br><span class="line"><span class="attr">Username:</span> <span class="string">&quot;horika&quot;</span></span><br><span class="line"><span class="attr">BasicInfo:</span></span><br><span class="line">   <span class="attr">RealName:</span> <span class="string">&quot;Harry&quot;</span></span><br><span class="line">   <span class="attr">Age:</span> <span class="string">&quot;18&quot;</span></span><br><span class="line">   <span class="attr">Language:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&quot;Golang&quot;</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&quot;Python&quot;</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&quot;C++&quot;</span></span><br><span class="line">   <span class="attr">Married:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Hobby:</span></span><br><span class="line">  <span class="attr">Sport:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;Lure&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;pingpong&quot;</span></span><br><span class="line">  <span class="attr">Music:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;Bohemian Rhapsody&quot;</span></span><br><span class="line">  <span class="attr">LuckyNumber:</span> <span class="number">22</span></span><br></pre></td></tr></table></figure><p>secret config <code>config/secret/secret.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span></span><br><span class="line">  <span class="attr">admin:</span></span><br><span class="line">    <span class="attr">addr:</span> <span class="string">&quot;127.0.0.1:6379&quot;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">db:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">&quot;mysql&quot;</span></span><br><span class="line">  <span class="attr">uri:</span></span><br><span class="line">    <span class="string">&quot;root:123456@tcp(localhost:3306)/user?charset=utf8&amp;parseTime=True&amp;loc=Local&amp;multiStatements=true&quot;</span></span><br><span class="line"><span class="attr">jwt:</span></span><br><span class="line">  <span class="attr">secret:</span> <span class="string">&quot;horika@^-^@kainhuck&quot;</span></span><br></pre></td></tr></table></figure><h2 id="告诉viper你要解析的配置文件是什么"><a href="#告诉viper你要解析的配置文件是什么" class="headerlink" title="告诉viper你要解析的配置文件是什么"></a>告诉viper你要解析的配置文件是什么</h2><p>示例代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config *viper.Viper</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init 初始化配置文件解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">config = viper.New()</span><br><span class="line"><span class="comment">// 设置 public 配置文件名</span></span><br><span class="line">config.SetConfigName(<span class="string">&quot;config&quot;</span>)</span><br><span class="line"><span class="comment">// 设置 public 配置文件类型</span></span><br><span class="line">config.SetConfigType(<span class="string">&quot;yaml&quot;</span>)</span><br><span class="line"><span class="comment">// 设置配置文件存放的目录</span></span><br><span class="line">config.AddConfigPath(<span class="string">&quot;./config/config&quot;</span>)</span><br><span class="line"><span class="comment">// 读取该配置文件</span></span><br><span class="line">config.ReadInConfig()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 secret config</span></span><br><span class="line">config.SetConfigName(<span class="string">&quot;secret&quot;</span>)</span><br><span class="line">config.SetConfigType(<span class="string">&quot;yaml&quot;</span>)</span><br><span class="line">config.AddConfigPath(<span class="string">&quot;./config/secret&quot;</span>)</span><br><span class="line">config.MergeInConfig()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明</p><ul><li>SetConfigName 指定配置文件名，不需要加后缀</li><li>SetConfigType 指定配置文件类型，可以省略，viper会自动识别</li><li>AddConfigPath 添加配置文件所在目录，可以多个，告诉viper区哪里寻找配置文件</li><li>ReadInConfig 从前面告知的配置中加载配置文件</li><li>MergeInConfig 从前面告知的配置中加载配置文件并合并到之前</li></ul><p>上面演示的只是一种读取方式，viper还有其他的读取方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config *viper.Viper</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init 初始化配置文件解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">config = viper.New()</span><br><span class="line"><span class="comment">// 设置 public 配置文件名</span></span><br><span class="line">config.SetConfigFile(<span class="string">&quot;./config/config/config.yaml&quot;</span>)</span><br><span class="line"><span class="comment">// 读取该配置文件</span></span><br><span class="line">config.ReadInConfig()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 secret config</span></span><br><span class="line">config.SetConfigFile(<span class="string">&quot;./config/secret/secret.yaml&quot;</span>)</span><br><span class="line">config.MergeInConfig()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明</p><ul><li>SetConfigFile 指定配置文件的全路径</li></ul><p>从IO流中读取配置文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config *viper.Viper</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init 初始化配置文件解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">config = viper.New()</span><br><span class="line">f, _ := os.Open(<span class="string">&quot;./config/config/config.yaml&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">config.SetConfigType(<span class="string">&quot;yaml&quot;</span>)</span><br><span class="line">config.ReadConfig(f)</span><br><span class="line"></span><br><span class="line">s, _ := os.Open(<span class="string">&quot;./config/secret/secret.yaml&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> s.Close()</span><br><span class="line">config.SetConfigType(<span class="string">&quot;yaml&quot;</span>)</span><br><span class="line">config.MergeConfig(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明</p><ul><li>ReadConfig 读取io流，注意和ReadInConfig区分</li><li>SetConfigType 从流中读取需要指定文件类型</li></ul><h2 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h2><p>viper读取配置文件就是各种<code>Get</code></p><ul><li>Get 自动判断类型</li><li>GetTime 获取时间类型</li><li>GetString 获取字符串类型</li><li>GetBool 获取bool类型</li><li>GetInt 获取int类型</li><li>GetStringMap 获取map类型</li><li>…</li></ul><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(config.Get(<span class="string">&quot;username&quot;</span>))</span><br><span class="line">fmt.Println(config.Get(<span class="string">&quot;mysql&quot;</span>))</span><br><span class="line">fmt.Println(config.GetTime(<span class="string">&quot;timestamp&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>viper作为一个优秀的配置文件解析工具，他支持将配置信息序列化为结构体对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> config *viper.Viper</span><br><span class="line"><span class="keyword">var</span> AllConfig TotalConfig</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init 初始化配置文件解析</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">config = viper.New()</span><br><span class="line">config.SetConfigFile(<span class="string">&quot;./config/config/config.yaml&quot;</span>)</span><br><span class="line">config.ReadInConfig()</span><br><span class="line">config.SetConfigFile(<span class="string">&quot;./config/secret/secret.yaml&quot;</span>)</span><br><span class="line">config.MergeInConfig()</span><br><span class="line">config.Unmarshal(&amp;AllConfig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> basicinfo <span class="keyword">struct</span> &#123;</span><br><span class="line">RealName <span class="keyword">string</span></span><br><span class="line">Age      <span class="keyword">int</span></span><br><span class="line">Language []<span class="keyword">string</span></span><br><span class="line">Married  <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> hobby <span class="keyword">struct</span> &#123;</span><br><span class="line">Sport       []<span class="keyword">string</span></span><br><span class="line">Music       []<span class="keyword">string</span></span><br><span class="line">LuckyNumber <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</span><br><span class="line">Addr      <span class="keyword">string</span></span><br><span class="line">paswsword <span class="keyword">string</span></span><br><span class="line">db        <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> redis <span class="keyword">struct</span> &#123;</span><br><span class="line">Admin admin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mysql <span class="keyword">struct</span> &#123;</span><br><span class="line">Driver <span class="keyword">string</span></span><br><span class="line">Uri    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> jwt <span class="keyword">struct</span> &#123;</span><br><span class="line">Secret <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TotalConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">TimeStamp <span class="keyword">string</span></span><br><span class="line">Username  <span class="keyword">string</span></span><br><span class="line">BasicInfo basicinfo</span><br><span class="line">Hobby     hobby</span><br><span class="line">Redis     redis</span><br><span class="line">Mysql     mysql</span><br><span class="line">Jwt       jwt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Init()</span><br><span class="line">fmt.Println(AllConfig.BasicInfo.Married)</span><br><span class="line">fmt.Println(AllConfig.Jwt.Secret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang异常处理机制</title>
      <link href="/2020/06/18/golang%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/06/18/golang%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="对比其他语言"><a href="#对比其他语言" class="headerlink" title="对比其他语言"></a>对比其他语言</h1><p>其他语言比如Python用的是<code>try Except finally</code>的方式来进行异常处理,执行逻辑是:尝试执行一段代码,如果发生异常则执行…无论是否发生异常都执行…;相比起来go语言的异常处理就简单许多,因为程序中的异常基本上都是可预期的,所以GO语言处理异常的方式是返回这个异常,如果没有发生异常则该值为nil,只要判断这个预期的返回值是否是<code>nil</code>便知道有没有异常发生.go语言中还有一种<code>panic</code>机制,<code>panic</code>可以理解为致命的异常会中断程序的运行,但是通过<code>recover</code>函数可捕获这个<code>panic</code>让程序继续运行.</p><h1 id="error"><a href="#error" class="headerlink" title="error"></a>error</h1><p>GO语言中一个普通的错误被称为error,它本质是一个接口类型,可以在<code>builtin.go</code>中看到其定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The error built-in interface type is the conventional interface for</span></span><br><span class="line"><span class="comment">// representing an error condition, with the nil value representing no error.</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>error可以出现在很多地方,比如打开一个不存在的文件,还有数学运算错误等等.</p><p>例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> people <span class="keyword">interface</span> &#123;</span><br><span class="line">name() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, err := os.Open(<span class="string">&quot;不存在.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)<span class="comment">// open 不存在.go: no such file or directory</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建error"><a href="#创建error" class="headerlink" title="创建error"></a>创建error</h1><p>前面我们获得error的方法是接受别人写好函数的返回值,现在我们尝试自己创建一个error,</p><p>在errors包中有多个创建error的方法,其中最常用的是errors.New()方法,该方法接收一个字符串用于描述这个错误.</p><p>其实现如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="comment">// Each call to New returns a distinct error value even if the text is identical.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>New方法返回了一个errorString结构体并将参数text穿进这个结构体中,这个结构体因为实现了Error方法所以他是一个error类型.</p><p>利用errors.New方法创建新error的例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := errors.New(<span class="string">&quot;我自己创建的一个错误&quot;</span>)</span><br><span class="line">fmt.Println(err) <span class="comment">// 我自己创建的一个错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了errors.New()方法创建error外,还可以用fmt.Errorf函数创建新的error,让我们看看fmt.Errorf函数内部的实现:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">p := newPrinter()</span><br><span class="line">p.wrapErrs = <span class="literal">true</span></span><br><span class="line">p.doPrintf(format, a)</span><br><span class="line">s := <span class="keyword">string</span>(p.buf)</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> p.wrappedErr == <span class="literal">nil</span> &#123;</span><br><span class="line">err = errors.New(s)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">err = &amp;wrapError&#123;s, p.wrappedErr&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.free()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>var err error</code>之前的语句看不懂没关系, 我简单的说一下:创建了一个pp结构体指针,然后设置了wrapErrs为true,并调用doPrintf方法将我们的格式化输入转化成对应字符串,此时还存在p的缓冲区中,然后通过string进行类型转化将得到的字符串村进变量s.关键看那个判断语句,这说明,Errorf函数生成错误有两种方式,要么调用errors.New要么返回一个wrapError类型实例.errors.New已经介绍过,下面看看wrapError结构体:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> wrapError <span class="keyword">struct</span> &#123;</span><br><span class="line">msg <span class="keyword">string</span></span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *wrapError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.msg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信大家都能明白了吧</p><p>举个fmt.Errorf的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := fmt.Errorf(<span class="string">&quot;error error error&quot;</span>)</span><br><span class="line">fmt.Println(err) <span class="comment">// error error error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="番外篇-String-和-Error"><a href="#番外篇-String-和-Error" class="headerlink" title="番外篇 String() 和 Error()"></a>番外篇 String() 和 Error()</h1><p>在golang中如果直接打印一个普通对象,得到的结果就会向下面一样,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">p := &amp;People&#123;</span><br><span class="line">name: <span class="string">&quot;horika&quot;</span>,</span><br><span class="line">age:  <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(p) <span class="comment">// &amp;&#123;horika 10&#125;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, p) <span class="comment">// &amp;&#123;horika %!s(int=10)&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许有时候我们需要在打印或者转换成字符串时想要让他输出自定义的一句话,这时我们可以给这个结构体增加一个<code>String</code>方法,如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;我叫%s, 我今年%d岁&quot;</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">p := &amp;People&#123;</span><br><span class="line">name: <span class="string">&quot;horika&quot;</span>,</span><br><span class="line">age:  <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(p)<span class="comment">// 我叫horika, 我今年10岁</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, p) <span class="comment">// 我叫horika, 我今年10岁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>!!!</strong> 注意如果我们定义的String方法是指针调用的那么我们必须打印指针对象才有效果,也就是你定义什么类型,就打印什么类型,同学们可以自己去尝试.</p><p>如果我们的结构体定义了一个<code>Error</code>方法,那么打印的时候会优先调用<code>Error</code>方法,如下</p><p><code>只定义Error方法的例子</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;[Error] 我叫%s, 我今年%d岁&quot;</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">p := &amp;People&#123;</span><br><span class="line">name: <span class="string">&quot;horika&quot;</span>,</span><br><span class="line">age:  <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(p)<span class="comment">// [Error] 我叫horika, 我今年10岁</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, p) <span class="comment">// [Error] 我叫horika, 我今年10岁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>即有String方法也有Error方法</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;[String] 我叫%s, 我今年%d岁&quot;</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;[Error] 我叫%s, 我今年%d岁&quot;</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">p := &amp;People&#123;</span><br><span class="line">name: <span class="string">&quot;horika&quot;</span>,</span><br><span class="line">age:  <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(p)<span class="comment">// [Error] 我叫horika, 我今年10岁</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, p) <span class="comment">// [Error] 我叫horika, 我今年10岁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果Error和String方法同时存在,Error方法会覆盖String方法,</p><p>看到这里我想你们就应该明白为什么我们之前打印一个error时只需要打印它本身而不用打印err.Error()了吧</p><h1 id="定义自己的错误"><a href="#定义自己的错误" class="headerlink" title="定义自己的错误"></a>定义自己的错误</h1><p>看了前面的介绍我相信大家都能自己写一个错误类型,无非分两步,1. 定义一个结构体,2. 该结构体实现 <code>Error() string</code>方法.然而事实真的就是这么简单.其实在前面的番外篇里已经有了自定义错误的影子</p><p>举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyIntNegativeError <span class="keyword">struct</span> &#123;</span><br><span class="line">msg <span class="keyword">string</span></span><br><span class="line">val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyIntNegativeError)</span><span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;[ERROR] reason %s; val: %d&quot;</span>, m.msg, m.val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyIntNegativeError</span><span class="params">(msg <span class="keyword">string</span>, val <span class="keyword">int</span>)</span> *<span class="title">MyIntNegativeError</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyIntNegativeError&#123;</span><br><span class="line">msg: msg,</span><br><span class="line">val: val,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sub10</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span>&#123;</span><br><span class="line">ret := a - <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ret &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, NewMyIntNegativeError(<span class="string">&quot;a必须大于10&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">a := <span class="number">9</span></span><br><span class="line"></span><br><span class="line">ret, err := Sub10(a)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;出错啦&quot;</span>, err)<span class="comment">// 出错啦 [ERROR] reason a必须大于10; val: 9</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了必须实现<code>Error</code>方法外,我一般习惯给自定义的错误实现一个构造函数.</p><h1 id="panic和recover"><a href="#panic和recover" class="headerlink" title="panic和recover"></a>panic和recover</h1><h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><p>panic是一个内建函数,他会产生一个严重的错误使程序中断执行,举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">0</span>&#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;出现数字3的倍数,我不想继续了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">panic: 出现数字3的倍数,我不想继续了</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">        &#x2F;home&#x2F;kain&#x2F;Documents&#x2F;code&#x2F;go_module&#x2F;file_io&#x2F;main.go:9 +0xf5</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2><p>recover可以捕获一个panic使程序恢复运行,当然你也可以再次抛出异常,通常我们都是在defer语句中执行recover,这很容易理解,因为我们必须等所有程序都执行完才能保证整个过程不会发生panic,举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">f1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">pan := <span class="built_in">recover</span>()</span><br><span class="line"><span class="keyword">if</span> pan != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;我已经捕获了错误,错误是:&quot;</span>, pan)</span><br><span class="line">fmt.Printf(<span class="string">&quot;错误类型是%T\n&quot;</span>, pan)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;没有错误&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">0</span>&#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;出现数字3的倍数,我不想继续了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">我已经捕获了错误,错误是: 出现数字3的倍数,我不想继续了</span><br><span class="line">错误类型是string</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从源码解读golang文件操作</title>
      <link href="/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/06/16/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BBgolang%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h1><h2 id="FileInfo接口"><a href="#FileInfo接口" class="headerlink" title="FileInfo接口"></a>FileInfo接口</h2><p>在<code>os</code>包中有一个<code>FileInfo</code>接口它包含了一个文件的基本信息,如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A FileInfo describes a file and is returned by Stat and Lstat.</span></span><br><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line">Name() <span class="keyword">string</span>       <span class="comment">// base name of the file</span></span><br><span class="line">Size() <span class="keyword">int64</span>        <span class="comment">// length in bytes for regular files; system-dependent for others</span></span><br><span class="line">Mode() FileMode     <span class="comment">// file mode bits</span></span><br><span class="line">ModTime() time.Time <span class="comment">// modification time</span></span><br><span class="line">IsDir() <span class="keyword">bool</span>        <span class="comment">// abbreviation for Mode().IsDir()</span></span><br><span class="line">Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// underlying data source (can return nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面描述可以看到FileInfo描述一个文件并且被Stat和Lstat方法返回</p><p>从<code>os</code>包中可以看到这两个函数的定义,记住里面的两个函数<code>statNolog</code>和<code>lstatNolog</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stat returns a FileInfo describing the named file.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(FileInfo, error)</span></span> &#123;</span><br><span class="line">testlog.Stat(name)</span><br><span class="line"><span class="keyword">return</span> statNolog(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lstat returns a FileInfo describing the named file.</span></span><br><span class="line"><span class="comment">// If the file is a symbolic link, the returned FileInfo</span></span><br><span class="line"><span class="comment">// describes the symbolic link. Lstat makes no attempt to follow the link.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lstat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(FileInfo, error)</span></span> &#123;</span><br><span class="line">testlog.Stat(name)</span><br><span class="line"><span class="keyword">return</span> lstatNolog(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fileStat结构体"><a href="#fileStat结构体" class="headerlink" title="fileStat结构体"></a>fileStat结构体</h2><p>同样在os包中定义了<code>fileState</code>结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A fileStat is the implementation of FileInfo returned by Stat and Lstat.</span></span><br><span class="line"><span class="keyword">type</span> fileStat <span class="keyword">struct</span> &#123;</span><br><span class="line">name    <span class="keyword">string</span></span><br><span class="line">size    <span class="keyword">int64</span></span><br><span class="line">mode    FileMode</span><br><span class="line">modTime time.Time</span><br><span class="line">sys     syscall.Stat_t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>types_unix.go</code>文件中定义了如下方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int64</span></span>        &#123; <span class="keyword">return</span> fs.size &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">Mode</span><span class="params">()</span> <span class="title">FileMode</span></span>     &#123; <span class="keyword">return</span> fs.mode &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">ModTime</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123; <span class="keyword">return</span> fs.modTime &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">Sys</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;   &#123; <span class="keyword">return</span> &amp;fs.sys &#125;</span><br></pre></td></tr></table></figure><p>在<code>types.go</code>中还定义以下两个方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> fs.name &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fs *fileStat)</span> <span class="title">IsDir</span><span class="params">()</span> <span class="title">bool</span></span>  &#123; <span class="keyword">return</span> fs.Mode().IsDir() &#125;</span><br></pre></td></tr></table></figure><p>可以看到这个结构体刚好实现了<code>FileInfo</code>接口</p><p>实际上,进入<code>statNolog</code>和<code>lstatNolog</code>可知,<code>Stat</code>和<code>Lsate</code>函数就是返回了指向<code>fileStat</code>的指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// statNolog stats a file with no test logging.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">statNolog</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(FileInfo, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> fs fileStat</span><br><span class="line">err := syscall.Stat(name, &amp;fs.sys)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;PathError&#123;<span class="string">&quot;stat&quot;</span>, name, err&#125;</span><br><span class="line">&#125;</span><br><span class="line">fillFileStatFromSys(&amp;fs, name)</span><br><span class="line"><span class="keyword">return</span> &amp;fs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lstatNolog lstats a file with no test logging.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lstatNolog</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(FileInfo, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> fs fileStat</span><br><span class="line">err := syscall.Lstat(name, &amp;fs.sys)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;PathError&#123;<span class="string">&quot;lstat&quot;</span>, name, err&#125;</span><br><span class="line">&#125;</span><br><span class="line">fillFileStatFromSys(&amp;fs, name)</span><br><span class="line"><span class="keyword">return</span> &amp;fs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以本质上就是利用<code>fileStat</code>结构体存放文件相关信息,并做操作</p><h2 id="查看文件信息"><a href="#查看文件信息" class="headerlink" title="查看文件信息"></a>查看文件信息</h2><p>介绍了这么多,写一个golang读取文件信息的例子,(当前目录下的go.mod文件)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fileInfo, err := os.Stat(<span class="string">&quot;go.mod&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;读取文件出错&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;文件名:&quot;</span>, fileInfo.Name())</span><br><span class="line">fmt.Println(<span class="string">&quot;文件大小:&quot;</span>, fileInfo.Size())</span><br><span class="line">fmt.Println(<span class="string">&quot;文件权限:&quot;</span>, fileInfo.Mode())</span><br><span class="line">fmt.Println(<span class="string">&quot;文件修改时间:&quot;</span>, fileInfo.ModTime())</span><br><span class="line">fmt.Println(<span class="string">&quot;文件是否是目录:&quot;</span>, fileInfo.IsDir())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文件名: go.mod</span><br><span class="line">文件大小: 24</span><br><span class="line">文件权限: -rw-r--r--</span><br><span class="line">文件修改时间: 2020-06-16 09:04:23.418186928 +0800 CST</span><br><span class="line">文件是否是目录: false</span><br></pre></td></tr></table></figure><p>其实上面方法就是对应<code>FileInfo</code>接口中的方法，但是少了一个<code>Sys</code>方法，通过这个方法你可以获得更加详细的信息，这个比较特殊，如果你直接打印会得到类似如下的输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(fileInfo.Sys())</span><br><span class="line"><span class="comment">// &amp;&#123;2064 23337987 1 33188 1000 1000 0 0 24 4096 8 &#123;1592269464 801520234&#125; &#123;1592269463 418186928&#125; &#123;1592269463 418186928&#125; [0 0 0]&#125;</span></span><br></pre></td></tr></table></figure><p>其实<code>Sys</code>方法就是返回了<code>fileStat</code>的<code>sys</code>属性,上面我们已经看过<code>fileStat</code>的定义,可以发现<code>sys</code>属性就是一个<code>syscall.Stat_t</code>类型</p><p>这是<code>Stat_t</code>的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stat_t <span class="keyword">struct</span> &#123;</span><br><span class="line">Dev       <span class="keyword">uint64</span></span><br><span class="line">Ino       <span class="keyword">uint64</span></span><br><span class="line">Nlink     <span class="keyword">uint64</span></span><br><span class="line">Mode      <span class="keyword">uint32</span></span><br><span class="line">Uid       <span class="keyword">uint32</span></span><br><span class="line">Gid       <span class="keyword">uint32</span></span><br><span class="line">X__pad0   <span class="keyword">int32</span></span><br><span class="line">Rdev      <span class="keyword">uint64</span></span><br><span class="line">Size      <span class="keyword">int64</span></span><br><span class="line">Blksize   <span class="keyword">int64</span></span><br><span class="line">Blocks    <span class="keyword">int64</span></span><br><span class="line">Atim      Timespec</span><br><span class="line">Mtim      Timespec</span><br><span class="line">Ctim      Timespec</span><br><span class="line">X__unused [<span class="number">3</span>]<span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过反射来获取上述属性的信息,以获取 Ctim 为例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fileInfo, err := os.Stat(<span class="string">&quot;go.mod&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;读取文件出错&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ctim := reflect.ValueOf(fileInfo.Sys()).Elem().FieldByName(<span class="string">&quot;Ctim&quot;</span>).Field(<span class="number">0</span>)</span><br><span class="line">fmt.Println(Ctim) <span class="comment">// 1592269463</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>也许有人会奇怪,为什么<code>fileStat</code>结构体里没有文件路径相关信息,其实者不难理解,我们既然能够打开一个文件,前提就是我们知道这个文件放在哪里.而我接下来要做的操作知识针对文件路径,而不是文件本身.</p><p>针对路径golang中有一个专门的包<code>path</code></p><p>常用方法如下</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>filepath.IsAbs()</td><td>判断是否为绝对路径</td></tr><tr><td>filepath.Rel()</td><td>获取相对路径</td></tr><tr><td>filepath.Abs()</td><td>获取绝对路径</td></tr><tr><td>path.Join()</td><td>拼接路径</td></tr></tbody></table><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;path&quot;</span></span><br><span class="line"><span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">path1 := <span class="string">&quot;/home/kain/Documents/code/go_module/file_io/main.go&quot;</span></span><br><span class="line">path2 := <span class="string">&quot;./go.mod&quot;</span></span><br><span class="line">path3 := <span class="string">&quot;go.mod&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(filepath.IsAbs(path1))<span class="comment">// true</span></span><br><span class="line">fmt.Println(filepath.IsAbs(path2))  <span class="comment">// false</span></span><br><span class="line">fmt.Println(filepath.IsAbs(path3))  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">fmt.Println(filepath.Rel(<span class="string">&quot;/home/kain&quot;</span>, path1))  <span class="comment">// Documents/code/go_module/file_io/main.go &lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(filepath.Abs(path1))<span class="comment">// /home/kain/Documents/code/go_module/file_io/main.go &lt;nil&gt;</span></span><br><span class="line">fmt.Println(filepath.Abs(path2))    <span class="comment">// /home/kain/Documents/code/go_module/file_io/go.mod &lt;nil&gt;</span></span><br><span class="line">fmt.Println(filepath.Abs(path3))    <span class="comment">// /home/kain/Documents/code/go_module/file_io/go.mod &lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(path.Join(path1, <span class="string">&quot;.&quot;</span>))  <span class="comment">// /home/kain/Documents/code/go_module/file_io/main.go</span></span><br><span class="line">fmt.Println(path.Join(path1, <span class="string">&quot;..&quot;</span>)) <span class="comment">// /home/kain/Documents/code/go_module/file_io</span></span><br><span class="line">fmt.Println(path.Join(<span class="string">&quot;/home&quot;</span>, path2)) <span class="comment">// /home/go.mod</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件创建删除（目录）"><a href="#文件创建删除（目录）" class="headerlink" title="文件创建删除（目录）"></a>文件创建删除（目录）</h1><h2 id="检查文件是否存在"><a href="#检查文件是否存在" class="headerlink" title="检查文件是否存在"></a>检查文件是否存在</h2><p>golang中通过<code>Stat</code>返回的错误,然后调用<code>IsExist</code>或<code>IsNotExist</code>来判断是否存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(PathExist(<span class="string">&quot;test.txt&quot;</span>))    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">println</span>(PathExist(<span class="string">&quot;go.mod&quot;</span>))       <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PathExist</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">_, err := os.Stat(path)</span><br><span class="line"><span class="keyword">return</span> os.IsNotExist(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><h3 id="os-MKdir"><a href="#os-MKdir" class="headerlink" title="os.MKdir()"></a>os.MKdir()</h3><p>该函数用于创建一层目录,定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mkdir creates a new directory with the specified name and permission</span></span><br><span class="line"><span class="comment">// bits (before umask).</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mkdir</span><span class="params">(name <span class="keyword">string</span>, perm FileMode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> runtime.GOOS == <span class="string">&quot;windows&quot;</span> &amp;&amp; isWindowsNulName(name) &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;PathError&#123;<span class="string">&quot;mkdir&quot;</span>, name, syscall.ENOTDIR&#125;</span><br><span class="line">&#125;</span><br><span class="line">e := syscall.Mkdir(fixLongPath(name), syscallMode(perm))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;PathError&#123;<span class="string">&quot;mkdir&quot;</span>, name, e&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mkdir(2) itself won&#x27;t handle the sticky bit on *BSD and Solaris</span></span><br><span class="line"><span class="keyword">if</span> !supportsCreateWithStickyBit &amp;&amp; perm&amp;ModeSticky != <span class="number">0</span> &#123;</span><br><span class="line">e = setStickyBit(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">Remove(name)</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := os.MKdir(<span class="string">&quot;demo&quot;</span>, <span class="number">0777</span>)</span><br></pre></td></tr></table></figure><h3 id="os-MKdirAll"><a href="#os-MKdirAll" class="headerlink" title="os.MKdirAll()"></a>os.MKdirAll()</h3><p>该函数用于创建多层目录,定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MkdirAll</span><span class="params">(path <span class="keyword">string</span>, perm FileMode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Fast path: if we can tell whether path is a directory or file, stop with success or error.</span></span><br><span class="line">dir, err := Stat(path)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> dir.IsDir() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;PathError&#123;<span class="string">&quot;mkdir&quot;</span>, path, syscall.ENOTDIR&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Slow path: make sure parent exists and then call Mkdir for path.</span></span><br><span class="line">i := <span class="built_in">len</span>(path)</span><br><span class="line"><span class="keyword">for</span> i &gt; <span class="number">0</span> &amp;&amp; IsPathSeparator(path[i<span class="number">-1</span>]) &#123; <span class="comment">// Skip trailing path separator.</span></span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">j := i</span><br><span class="line"><span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; !IsPathSeparator(path[j<span class="number">-1</span>]) &#123; <span class="comment">// Scan backward over element.</span></span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> j &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// Create parent.</span></span><br><span class="line">err = MkdirAll(fixRootDirectory(path[:j<span class="number">-1</span>]), perm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parent now exists; invoke Mkdir and use its result.</span></span><br><span class="line">err = Mkdir(path, perm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Handle arguments like &quot;foo/.&quot; by</span></span><br><span class="line"><span class="comment">// double-checking that directory doesn&#x27;t exist.</span></span><br><span class="line">dir, err1 := Lstat(path)</span><br><span class="line"><span class="keyword">if</span> err1 == <span class="literal">nil</span> &amp;&amp; dir.IsDir() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := os.MkdirAll(<span class="string">&quot;dir1/dir2/dir3&quot;</span>, os.ModePerm) <span class="comment">// os.ModePerm = 0777</span></span><br></pre></td></tr></table></figure><p>##　创建文件</p><h3 id="os-Creat"><a href="#os-Creat" class="headerlink" title="os.Creat()"></a>os.Creat()</h3><p>用该方法创建文本文件，如果文件已经存在，会将其覆盖，定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，他就是通过打开文件的方式来创建文件，通过 <code>O_TRUNC</code>标志，来覆盖原文件．</p><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Create(<span class="string">&quot;test.txt&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="删除文件（目录）"><a href="#删除文件（目录）" class="headerlink" title="删除文件（目录）"></a>删除文件（目录）</h2><h3 id="os-Remove"><a href="#os-Remove" class="headerlink" title="os.Remove()"></a>os.Remove()</h3><p>该方法用于删除文件或者空目录,定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// System call interface forces us to know</span></span><br><span class="line"><span class="comment">// whether name is a file or directory.</span></span><br><span class="line"><span class="comment">// Try both: it is cheaper on average than</span></span><br><span class="line"><span class="comment">// doing a Stat plus the right one.</span></span><br><span class="line">e := syscall.Unlink(name)</span><br><span class="line"><span class="keyword">if</span> e == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">e1 := syscall.Rmdir(name)</span><br><span class="line"><span class="keyword">if</span> e1 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Both failed: figure out which error to return.</span></span><br><span class="line"><span class="comment">// OS X and Linux differ on whether unlink(dir)</span></span><br><span class="line"><span class="comment">// returns EISDIR, so can&#x27;t use that. However,</span></span><br><span class="line"><span class="comment">// both agree that rmdir(file) returns ENOTDIR,</span></span><br><span class="line"><span class="comment">// so we can use that to decide which error is real.</span></span><br><span class="line"><span class="comment">// Rmdir might also return ENOTDIR if given a bad</span></span><br><span class="line"><span class="comment">// file path, like /etc/passwd/foo, but in that case,</span></span><br><span class="line"><span class="comment">// both errors will be ENOTDIR, so it&#x27;s okay to</span></span><br><span class="line"><span class="comment">// use the error from unlink.</span></span><br><span class="line"><span class="keyword">if</span> e1 != syscall.ENOTDIR &#123;</span><br><span class="line">e = e1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;PathError&#123;<span class="string">&quot;remove&quot;</span>, name, e&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := os.Remove(<span class="string">&quot;demo&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="os-RemoveAll"><a href="#os-RemoveAll" class="headerlink" title="os.RemoveAll()"></a>os.RemoveAll()</h3><p>该方法用于删除目录下面所有子节点,定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RemoveAll removes path and any children it contains.</span></span><br><span class="line"><span class="comment">// It removes everything it can but returns the first error</span></span><br><span class="line"><span class="comment">// it encounters. If the path does not exist, RemoveAll</span></span><br><span class="line"><span class="comment">// returns nil (no error).</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveAll</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> removeAll(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeAll()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeAll</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> path == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="comment">// fail silently to retain compatibility with previous behavior</span></span><br><span class="line"><span class="comment">// of RemoveAll. See issue 28830.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The rmdir system call does not permit removing &quot;.&quot;,</span></span><br><span class="line"><span class="comment">// so we don&#x27;t permit it either.</span></span><br><span class="line"><span class="keyword">if</span> endsWithDot(path) &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;PathError&#123;<span class="string">&quot;RemoveAll&quot;</span>, path, syscall.EINVAL&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple case: if Remove works, we&#x27;re done.</span></span><br><span class="line">err := Remove(path)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> || IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RemoveAll recurses by deleting the path base from</span></span><br><span class="line"><span class="comment">// its parent directory</span></span><br><span class="line">parentDir, base := splitPath(path)</span><br><span class="line"></span><br><span class="line">parent, err := Open(parentDir)</span><br><span class="line"><span class="keyword">if</span> IsNotExist(err) &#123;</span><br><span class="line"><span class="comment">// If parent does not exist, base cannot exist. Fail silently</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> parent.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := removeAllFrom(parent, base); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> pathErr, ok := err.(*PathError); ok &#123;</span><br><span class="line">pathErr.Path = parentDir + <span class="keyword">string</span>(PathSeparator) + pathErr.Path</span><br><span class="line">err = pathErr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := os.RemoveAll(<span class="string">&quot;dir1&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><p>对文件进行读写操作肯定要先打开文件</p><h2 id="打开关闭文件"><a href="#打开关闭文件" class="headerlink" title="打开关闭文件"></a>打开关闭文件</h2><h3 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h3><p>前面在创建文件时我们已经了解过了文件的打开,使用函数<code>os.OpenFile()</code>来实现,定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenFile is the generalized open call; most users will use Open</span></span><br><span class="line"><span class="comment">// or Create instead. It opens the named file with specified flag</span></span><br><span class="line"><span class="comment">// (O_RDONLY etc.). If the file does not exist, and the O_CREATE flag</span></span><br><span class="line"><span class="comment">// is passed, it is created with mode perm (before umask). If successful,</span></span><br><span class="line"><span class="comment">// methods on the returned File can be used for I/O.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line">   testlog.Open(name)</span><br><span class="line">   f, err := openFileNolog(name, flag, perm)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   f.appendMode = flag&amp;O_APPEND != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的内部是调用<code>openFileNolog</code>函数来实现,有兴趣的同学可以去了解一下</p><p>它接收的三个参数分别是文件路径,标志和权限,</p><p>标志就是打开方式,可以一种或多种,golang中的标志如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flags to OpenFile wrapping those of the underlying system. Not all</span></span><br><span class="line"><span class="comment">// flags may be implemented on a given system.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.</span></span><br><span class="line">O_RDONLY <span class="keyword">int</span> = syscall.O_RDONLY <span class="comment">// open the file read-only.</span></span><br><span class="line">O_WRONLY <span class="keyword">int</span> = syscall.O_WRONLY <span class="comment">// open the file write-only.</span></span><br><span class="line">O_RDWR   <span class="keyword">int</span> = syscall.O_RDWR   <span class="comment">// open the file read-write.</span></span><br><span class="line"><span class="comment">// The remaining values may be or&#x27;ed in to control behavior.</span></span><br><span class="line">O_APPEND <span class="keyword">int</span> = syscall.O_APPEND <span class="comment">// append data to the file when writing.</span></span><br><span class="line">O_CREATE <span class="keyword">int</span> = syscall.O_CREAT  <span class="comment">// create a new file if none exists.</span></span><br><span class="line">O_EXCL   <span class="keyword">int</span> = syscall.O_EXCL   <span class="comment">// used with O_CREATE, file must not exist.</span></span><br><span class="line">O_SYNC   <span class="keyword">int</span> = syscall.O_SYNC   <span class="comment">// open for synchronous I/O.</span></span><br><span class="line">O_TRUNC  <span class="keyword">int</span> = syscall.O_TRUNC  <span class="comment">// truncate regular writable file when opened.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>权限只在文件不存在时创建文件需要,如果只是普通打开文件,权限填0即可,再如果知识简单得到只读一个已存在的文件,可以使用<code>os.Open()</code>函数来实现,这是它的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open opens the named file for reading. If successful, methods on</span></span><br><span class="line"><span class="comment">// the returned file can be used for reading; the associated file</span></span><br><span class="line"><span class="comment">// descriptor has mode O_RDONLY.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> OpenFile(name, O_RDONLY, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道你们有没有发现,上述介绍的几个函数的第一个返回值是<code>os.File</code>类型的指针,这究竟是什么呢?</p><p>让我们来看看它的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File represents an open file descriptor.</span></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">*file <span class="comment">// os specific</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它又指向了<code>file</code>类型指针,那就看看这个<code>file</code>吧</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file is the real representation of *File.</span></span><br><span class="line"><span class="comment">// The extra level of indirection ensures that no clients of os</span></span><br><span class="line"><span class="comment">// can overwrite this data, which could cause the finalizer</span></span><br><span class="line"><span class="comment">// to close the wrong file descriptor.</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">pfd         poll.FD</span><br><span class="line">name        <span class="keyword">string</span></span><br><span class="line">dirinfo     *dirInfo <span class="comment">// nil unless directory being read</span></span><br><span class="line">nonblock    <span class="keyword">bool</span>     <span class="comment">// whether we set nonblocking mode</span></span><br><span class="line">stdoutOrErr <span class="keyword">bool</span>     <span class="comment">// whether this is stdout or stderr</span></span><br><span class="line">appendMode  <span class="keyword">bool</span>     <span class="comment">// whether file is opened for appending</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那个<code>FD</code>是文件描述符(file descriptor),有兴趣的同学可以展开看看<code>file</code>结构体的内部</p><p>下面我们来看看<code>File</code>结构体都支持哪些操作(这些方法可以在<code>file.go, stat_unix.go, file_unix.g, file_posix.go, dir.go</code>中找到)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">f.Fd()</span><br><span class="line">f.Stat()</span><br><span class="line">f.Name()</span><br><span class="line">f.Close()</span><br><span class="line">f.Write()</span><br><span class="line">f.Chdir()</span><br><span class="line">f.Chmod()</span><br><span class="line">f.Chown()</span><br><span class="line">f.Read()</span><br><span class="line">f.ReadAt()</span><br><span class="line">f.Readdir()</span><br><span class="line">f.Readdirnames()</span><br><span class="line">f.Seek()</span><br><span class="line">f.SetDeadline()</span><br><span class="line">f.SetReadDeadline()</span><br><span class="line">f.Sync()</span><br><span class="line">f.SyscallConn()</span><br><span class="line">f.Truncate()</span><br><span class="line">f.WriteAt()</span><br><span class="line">f.WriteString()</span><br></pre></td></tr></table></figure><p>虽然方法很多,但是常用的也就几个,无非是读写和关闭.下面我将介绍几个常用的函数,其余的你们有兴趣就去了解吧</p><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p><code>f.Close()</code>关闭一个打开的文件,方法定义如下,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ErrInvalid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f.file.<span class="built_in">close</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>f.file.close()</code>来关闭文件,这里就不深入了</p><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p><code>f.Read()</code>读取文件内容,方法定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read reads up to len(b) bytes from the File.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes read and any error encountered.</span></span><br><span class="line"><span class="comment">// At end of file, Read returns 0, io.EOF.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := f.checkValid(<span class="string">&quot;read&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line">n, e := f.read(b)</span><br><span class="line"><span class="keyword">return</span> n, f.wrapErr(<span class="string">&quot;read&quot;</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>n代表实际读取的字节数,其本质是调用read函数来实现读取,继续深入发现 <code>read</code>函数调用了<code>f.pfd.Read()</code>,该函数最后调用了<code>fd.eofError()</code>方法,在该方法内部,如果读取到最末尾,返回<code>io.EOF</code>错误.</p><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f *os.File</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span><span class="comment">// 存放读取字节数</span></span><br><span class="line"><span class="comment">// 初始化一个切片用于存放读取的数据</span></span><br><span class="line">bs := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">8</span>, <span class="number">1024</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">f,err = os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;文件打开失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意关闭文件</span></span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err = f.Read(bs)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> || err == io.EOF&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;文件读取结束&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(bs[:n]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><h3 id="f-Write"><a href="#f-Write" class="headerlink" title="f.Write()"></a>f.Write()</h3><p>该方法用字节切片的方式写入文件,定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write writes len(b) bytes to the File.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes written and an error, if any.</span></span><br><span class="line"><span class="comment">// Write returns a non-nil error when n != len(b).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := f.checkValid(<span class="string">&quot;write&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line">n, e := f.write(b)</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n != <span class="built_in">len</span>(b) &#123;</span><br><span class="line">err = io.ErrShortWrite</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">epipecheck(f, e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">err = f.wrapErr(<span class="string">&quot;write&quot;</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f *os.File</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span><span class="comment">// 存放写入字节数</span></span><br><span class="line"></span><br><span class="line">f, err = os.OpenFile(<span class="string">&quot;test.txt&quot;</span>, os.O_RDWR|os.O_CREATE|os.O_APPEND, os.ModePerm)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;文件打开失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 别忘了关闭文件</span></span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">n, err = f.Write([]<span class="keyword">byte</span>(<span class="string">&quot;123abc你好&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;写入文件失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;成功写入%d个字节\n&quot;</span>, n)　<span class="comment">// 一个汉字3个字节</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意, 写文件就不能通过<code>Open</code>函数来打开了,<code>Open</code>函数是只读的</p><p>利用标志<code>os.O_CREATE</code>,会在文件不存在时创建</p><p>利用标志<code>os.O_APPEND</code>,表示追加写入</p><h3 id="f-WriteString"><a href="#f-WriteString" class="headerlink" title="f.WriteString()"></a>f.WriteString()</h3><p>该方法用字符串的方式写入文件,定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteString is like Write, but writes the contents of string s rather than</span></span><br><span class="line"><span class="comment">// a slice of bytes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> f.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到他的本质就是给你转换成字节切片,这个示例我就不演示了,相信大家都能看懂</p><p>留个思考题:<em>请大家阅读相关源码并说明<code>os.fileState</code>和<code>os.file</code>这两个结构体有何不同,各自的使用场景又是什么?</em></p><p> 有答案的可以在评论区留言</p><p><strong>如果你看到这里你应该知道了如何使用golang来实现文件的相关操作,但是你们肯定和我一样,觉得golang的文件读写操作很麻烦.下面我们来了解一下文件操作的另外两种方法 <code>ioutil</code>和<code>bufio</code></strong>,下面内容部分参考了GO语言中文文档,但文档中的有些内容已经过时,我已经将它更新.</p><h1 id="ioutil"><a href="#ioutil" class="headerlink" title="ioutil"></a>ioutil</h1><p>正如其名字ioutil这是一个读写操作包,这里举例一些常用的方法</p><ul><li><p><code>func ReadFile(filename string) ([]byte, error)</code></p><p>ReadFile 从filename指定的文件中读取数据并返回文件的内容。成功的调用返回的err为nil而非EOF。因为本函数定义为读取整个文件，它不会将读取返回的EOF视为应报告的错误。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">f, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"><span class="comment">// It&#x27;s a good but not certain bet that FileInfo will tell us exactly how much to</span></span><br><span class="line"><span class="comment">// read, so let&#x27;s try it but be prepared for the answer to be wrong.</span></span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int64</span> = bytes.MinRead</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fi, err := f.Stat(); err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// As initial capacity for readAll, use Size + a little extra in case Size</span></span><br><span class="line"><span class="comment">// is zero, and to avoid another allocation after Read has filled the</span></span><br><span class="line"><span class="comment">// buffer. The readAll call will read into its allocated internal buffer</span></span><br><span class="line"><span class="comment">// cheaply. If the size was wrong, we&#x27;ll either waste some space off the end</span></span><br><span class="line"><span class="comment">// or reallocate as needed, but in the overwhelmingly common case we&#x27;ll get</span></span><br><span class="line"><span class="comment">// it just right.</span></span><br><span class="line"><span class="keyword">if</span> size := fi.Size() + bytes.MinRead; size &gt; n &#123;</span><br><span class="line">n = size</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> readAll(f, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出,ReadFile函数本质也是利用os.File结构体,并调用<code>readAll</code>函数处理,这里就不深入了,感兴趣的同学可以去看看,</p><p>例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">bs, err := ioutil.ReadFile(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;文件打开出错&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="keyword">string</span>(bs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>func WriteFile(filename string, data []byte, perm os.FileMode) error</code></p><p>函数向filename指定的文件中写入数据。如果文件不存在将按给出的权限创建文件，否则在写入数据之前清空文件。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteFile writes data to a file named by filename.</span></span><br><span class="line"><span class="comment">// If the file does not exist, WriteFile creates it with permissions perm</span></span><br><span class="line"><span class="comment">// (before umask); otherwise WriteFile truncates it before writing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="keyword">string</span>, data []<span class="keyword">byte</span>, perm os.FileMode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">f, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">_, err = f.Write(data)</span><br><span class="line"><span class="keyword">if</span> err1 := f.Close(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">err = err1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你没看错这就是这个函数的源码,是不是非常眼熟,这和我们之前写的代码十分相似.</p><p>例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := ioutil.WriteFile(<span class="string">&quot;hello.txt&quot;</span>, []<span class="keyword">byte</span>(<span class="string">&quot;hello世界&quot;</span>),os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;文件打开失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>func ReadDir(dirname string) ([]os.FileInfo, error)</code></p><p>返回dirname指定的目录的目录信息的有序列表。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadDir reads the directory named by dirname and returns</span></span><br><span class="line"><span class="comment">// a list of directory entries sorted by filename.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadDir</span><span class="params">(dirname <span class="keyword">string</span>)</span> <span class="params">([]os.FileInfo, error)</span></span> &#123;</span><br><span class="line">f, err := os.Open(dirname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">list, err := f.Readdir(<span class="number">-1</span>)</span><br><span class="line">f.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">sort.Slice(list, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> list[i].Name() &lt; list[j].Name() &#125;)</span><br><span class="line"><span class="keyword">return</span> list, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的底层也是利用<code>os.File</code>结构体,然后调用os.File的Readdir方法,并对结构进行排序输出</p><p>例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fs, err := ioutil.ReadDir(<span class="string">&quot;dir1&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;文件打开失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> fs&#123;</span><br><span class="line">fmt.Println(i, v.Name(), v.IsDir(), v.Size(), v.ModTime())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>func ReadAll(r io.Reader) ([]byte, error)</code></p><p>ReadAll读取数据直到EOF或遇到error，返回读取的数据和遇到的错误。成功的调用返回的err为nil而非EOF。因为本函数定义为读取r直到EOF，它不会将读取返回的EOF视为应报告的错误。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadAll reads from r until an error or EOF and returns the data it read.</span></span><br><span class="line"><span class="comment">// A successful call returns err == nil, not err == EOF. Because ReadAll is</span></span><br><span class="line"><span class="comment">// defined to read from src until EOF, it does not treat an EOF from Read</span></span><br><span class="line"><span class="comment">// as an error to be reported.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> readAll(r, bytes.MinRead)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它接收一个参数类型为<code>io.Reader</code>,通过读源码可以看出它就是一个实现了<code>Read</code>函数的接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经知道<code>os.File</code>就是实现了<code>Read</code>方法,所以我们可以将一个<code>os.File</code>结构体传进去,</p><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> bs []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> f *os.File</span><br><span class="line"></span><br><span class="line">f, err = os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;打开文件失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">bs, err = ioutil.ReadAll(f)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;文件读取失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="keyword">string</span>(bs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现<code>ReadFile</code>和<code>ReadAll</code>方法非常的像,只不过<code>ReadFile</code>方法内部对文件进打开操作,而<code>ReadAll</code>是在外面手动打开文件然后传进去</p></li><li><p><code>func TempDir(dir, pattern string) (name string, err error) </code></p><p>在dir目录里创建一个新的临时文件夹(其实本质就是普通文件,用作临时存储场景,需要手动删除),该文件夹的命名规则如下,使用将<code>pattern</code>用<code>*</code>分开,取最后一个做后缀,前面的做前缀,中间拼接随机数字,该操作可在其源码中看到,如下</p></li></ul>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">(dir, pattern <span class="keyword">string</span>)</span> <span class="params">(name <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> dir == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">dir = os.TempDir()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prefix, suffix := prefixAndSuffix(pattern)</span><br><span class="line"></span><br><span class="line">nconflict := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">try := filepath.Join(dir, prefix+nextRandom()+suffix)</span><br><span class="line">err = os.Mkdir(try, <span class="number">0700</span>)</span><br><span class="line"><span class="keyword">if</span> os.IsExist(err) &#123;</span><br><span class="line"><span class="keyword">if</span> nconflict++; nconflict &gt; <span class="number">10</span> &#123;</span><br><span class="line">randmu.Lock()</span><br><span class="line">rand = reseed()</span><br><span class="line">randmu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := os.Stat(dir); os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">name = try</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其中<code>prefixAndSuffix</code>函数定义如下</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prefixAndSuffix</span><span class="params">(pattern <span class="keyword">string</span>)</span> <span class="params">(prefix, suffix <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pos := strings.LastIndex(pattern, <span class="string">&quot;*&quot;</span>); pos != <span class="number">-1</span> &#123;</span><br><span class="line">prefix, suffix = pattern[:pos], pattern[pos+<span class="number">1</span>:]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prefix = pattern</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  举个例子</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name, err := ioutil.TempDir(<span class="string">&quot;dir1&quot;</span>, <span class="string">&quot;kain*huck&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;文件夹创建失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(name) <span class="comment">// dir1/kain037615429huck</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>func TempFile(dir, pattern string) (f *os.File, err error)</code></p><p>在dir目录下创建一个新的临时文件,文件名是通过使用pattern并在末尾添加一个随机字符串生成的。如果pattern包含一个“*”，随机字符串将替换最后一个“*”。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempFile</span><span class="params">(dir, pattern <span class="keyword">string</span>)</span> <span class="params">(f *os.File, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> dir == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">dir = os.TempDir()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prefix, suffix := prefixAndSuffix(pattern)</span><br><span class="line"></span><br><span class="line">nconflict := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">name := filepath.Join(dir, prefix+nextRandom()+suffix)</span><br><span class="line">f, err = os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, <span class="number">0600</span>)</span><br><span class="line"><span class="keyword">if</span> os.IsExist(err) &#123;</span><br><span class="line"><span class="keyword">if</span> nconflict++; nconflict &gt; <span class="number">10</span> &#123;</span><br><span class="line">randmu.Lock()</span><br><span class="line">rand = reseed()</span><br><span class="line">randmu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, err := ioutil.TempFile(<span class="string">&quot;dir1&quot;</span>, <span class="string">&quot;kain*huck&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;文件创建失败&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(f.Name())<span class="comment">// dir1/kain115329465huck</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bufio"><a href="#bufio" class="headerlink" title="bufio"></a>bufio</h1><p>bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，创建另一个也实现了该接口，且同时还提供了缓冲和一些文本I/O的帮助函数的对象。</p><h2 id="bufio-Reader"><a href="#bufio-Reader" class="headerlink" title="bufio.Reader"></a><code>bufio.Reader</code></h2><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reader implements buffering for an io.Reader object.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">buf          []<span class="keyword">byte</span></span><br><span class="line">rd           io.Reader <span class="comment">// reader provided by the client</span></span><br><span class="line">r, w         <span class="keyword">int</span>       <span class="comment">// buf read and write positions</span></span><br><span class="line">err          error</span><br><span class="line">lastByte     <span class="keyword">int</span> <span class="comment">// last byte read for UnreadByte; -1 means invalid</span></span><br><span class="line">lastRuneSize <span class="keyword">int</span> <span class="comment">// size of last rune read for UnreadRune; -1 means invalid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用方法</p><ul><li><p><code>func NewReader(rd io.Reader) *Reader</code></p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewReader returns a new Reader whose buffer has the default size.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewReaderSize(rd, defaultBufSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NewReader调用<code>NewReaderSize</code>创建一个具有默认大小缓冲的Reader指针</p><p>defauleBufSize</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">defaultBufSize = <span class="number">4096</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><code>func NewReaderSize(rd io.Reader, size int) *Reader</code></p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewReaderSize returns a new Reader whose buffer has at least the specified</span></span><br><span class="line"><span class="comment">// size. If the argument io.Reader is already a Reader with large enough</span></span><br><span class="line"><span class="comment">// size, it returns the underlying Reader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="keyword">int</span>)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line"><span class="comment">// Is it already a Reader?</span></span><br><span class="line">b, ok := rd.(*Reader)</span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; <span class="built_in">len</span>(b.buf) &gt;= size &#123;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> size &lt; minReadBufferSize &#123;</span><br><span class="line">size = minReadBufferSize</span><br><span class="line">&#125;</span><br><span class="line">r := <span class="built_in">new</span>(Reader)</span><br><span class="line">r.reset(<span class="built_in">make</span>([]<span class="keyword">byte</span>, size), rd)</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数就是上述<code>NewReader</code>中被调用的函数,他可以让我们手动的提供缓冲大小,从代码可以看到,所谓缓冲就是一个byte切片,该切片会被赋值给<code>Reader</code>结构体的<code>buf</code>,</p><p>reset</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">reset</span><span class="params">(buf []<span class="keyword">byte</span>, r io.Reader)</span></span> &#123;</span><br><span class="line">*b = Reader&#123;</span><br><span class="line">buf:          buf,</span><br><span class="line">rd:           r,</span><br><span class="line">lastByte:     <span class="number">-1</span>,</span><br><span class="line">lastRuneSize: <span class="number">-1</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>func (b *Reader) Reset(r io.Reader)</code></p><p>Reset丢弃缓冲中的数据，清除任何错误，将b重设为其下层从r读取数据。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reset discards any buffered data, resets all state, and switches</span></span><br><span class="line"><span class="comment">// the buffered reader to read from r.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Reset</span><span class="params">(r io.Reader)</span></span> &#123;</span><br><span class="line">b.reset(b.buf, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部实现非常简单,就是调用函数<code>reset</code>(这个函数在上面已经看过了),将当前的<code>Reader</code>中的<code>rd</code>属性(io.Reader)重新重设为<code>r</code></p></li><li><p><code>func (b *Reader) Buffered() int</code></p><p>Buffered返回缓冲中现有的可读取的字节数。</p><p>定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffered returns the number of bytes that can be read from the current buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> b.w - b.r &#125;</span><br></pre></td></tr></table></figure><p>这个就不解释了</p></li><li><p><code>func (b *Reader) Peek(n int) ([]byte, error)</code></p><p>Peek返回输入流的下n个字节，而不会移动读取位置。返回的[]byte只在下一次调用读取操作前合法。如果Peek返回的切片长度比n小，它也会返会一个错误说明原因。如果n比缓冲尺寸还大，返回的错误将是ErrBufferFull。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Peek</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrNegativeCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.lastByte = <span class="number">-1</span></span><br><span class="line">b.lastRuneSize = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> b.w-b.r &lt; n &amp;&amp; b.w-b.r &lt; <span class="built_in">len</span>(b.buf) &amp;&amp; b.err == <span class="literal">nil</span> &#123;</span><br><span class="line">b.fill() <span class="comment">// b.w-b.r &lt; len(b.buf) =&gt; buffer is not full</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="built_in">len</span>(b.buf) &#123;</span><br><span class="line"><span class="keyword">return</span> b.buf[b.r:b.w], ErrBufferFull</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 &lt;= n &lt;= len(b.buf)</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> avail := b.w - b.r; avail &lt; n &#123;</span><br><span class="line"><span class="comment">// not enough data in buffer</span></span><br><span class="line">n = avail</span><br><span class="line">err = b.readErr()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">err = ErrBufferFull</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b.buf[b.r : b.r+n], err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别看前面这么多,那都是一些特殊情况的判断处理,看最后一句得知其实该函数就是返回了缓冲区的切</p></li><li><p><code>func (b *Reader) Read(p []byte) (n int, err error)</code></p><p>Read读取数据写入p。本方法返回写入p的字节数。本方法一次调用最多会调用下层Reader接口一次Read方法，因此返回值n可能小于len(p)。读取到达结尾时，返回值n将为0而err将为io.EOF。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">n = <span class="built_in">len</span>(p)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> b.Buffered() &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, b.readErr()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b.r == b.w &#123;</span><br><span class="line"><span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, b.readErr()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= <span class="built_in">len</span>(b.buf) &#123;</span><br><span class="line"><span class="comment">// Large read, empty buffer.</span></span><br><span class="line"><span class="comment">// Read directly into p to avoid copy.</span></span><br><span class="line">n, b.err = b.rd.Read(p)</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(errNegativeRead)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">b.lastByte = <span class="keyword">int</span>(p[n<span class="number">-1</span>])</span><br><span class="line">b.lastRuneSize = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n, b.readErr()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// One read.</span></span><br><span class="line"><span class="comment">// Do not use b.fill, which will loop.</span></span><br><span class="line">b.r = <span class="number">0</span></span><br><span class="line">b.w = <span class="number">0</span></span><br><span class="line">n, b.err = b.rd.Read(b.buf)</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(errNegativeRead)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, b.readErr()</span><br><span class="line">&#125;</span><br><span class="line">b.w += n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy as much as we can</span></span><br><span class="line">n = <span class="built_in">copy</span>(p, b.buf[b.r:b.w])</span><br><span class="line">b.r += n</span><br><span class="line">b.lastByte = <span class="keyword">int</span>(b.buf[b.r<span class="number">-1</span>])</span><br><span class="line">b.lastRuneSize = <span class="number">-1</span></span><br><span class="line"><span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中可以看到<code>n, b.err = b.rd.Read(p)</code>,说明这内部是调用io.Read方法.然后将buf中的可用内容尽可能的复制给p.</p><p>鉴于篇幅过长,以下其他常用方法就留给读者自己去分析吧,</p><ul><li><p><code>func (b *Reader) ReadByte() (c byte, err error)</code></p><p>ReadByte读取并返回一个字节。如果没有可用的数据，会返回错误。</p></li><li><p><code>func (b *Reader) ReadRune() (r rune, size int, err error)</code></p><p>ReadRune读取一个utf-8编码的unicode码值，返回该码值、其编码长度和可能的错误。如果utf-8编码非法，读取位置只移动1字节，返回U+FFFD，返回值size为1而err为nil。如果没有可用的数据，会返回错误。</p></li><li><p><code>func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</code></p><p>ReadLine是一个低水平的行数据读取原语。大多数调用者应使用ReadBytes(‘\n’)或ReadString(‘\n’)代替，或者使用Scanner。</p><p>ReadLine尝试返回一行数据，不包括行尾标志的字节。如果行太长超过了缓冲，返回值isPrefix会被设为true，并返回行的前面一部分。该行剩下的部分将在之后的调用中返回。返回值isPrefix会在返回该行最后一个片段时才设为false。返回切片是缓冲的子切片，只在下一次读取操作之前有效。ReadLine要么返回一个非nil的line，要么返回一个非nil的err，两个返回值至少一个非nil。</p><p>返回的文本不包含行尾的标志字节（”\r\n”或”\n”）。如果输入流结束时没有行尾标志字节，方法不会出错，也不会指出这一情况。在调用ReadLine之后调用UnreadByte会总是吐出最后一个读取的字节（很可能是该行的行尾标志字节），即使该字节不是ReadLine返回值的一部分。</p></li><li><p><code>func (b *Reader) ReadString(delim byte) (string, error)</code></p><p>ReadString读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的字符串。如果ReadString方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadString方法返回的切片不以delim结尾时，会返回一个非nil的错误。</p></li><li><p><code>func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</code></p><p>ReadSlice读取直到第一次遇到delim字节，返回缓冲里的包含已读取的数据和delim字节的切片。该返回值只在下一次读取操作之前合法。如果ReadSlice放在在读取到delim之前遇到了错误，它会返回在错误之前读取的数据在缓冲中的切片以及该错误（一般是io.EOF）。如果在读取到delim之前缓冲就被写满了，ReadSlice失败并返回ErrBufferFull。因为ReadSlice的返回值会被下一次I/O操作重写，调用者应尽量使用ReadBytes或ReadString替代本法功法。当且仅当ReadBytes方法返回的切片不以delim结尾时，会返回一个非nil的错误。</p></li><li><p><code>func (b *Reader) ReadBytes(delim byte) ([]byte, error)</code></p><p>ReadBytes读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的切片。如果ReadBytes方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadBytes方法返回的切片不以delim结尾时，会返回一个非nil的错误。</p></li></ul><p>例子1:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f,err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">reader := bufio.NewReader(f)</span><br><span class="line">p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">12</span>)</span><br><span class="line">n, err :=reader.Read(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp;  err != io.EOF &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(n)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(p))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子2:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f,err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line">reader := bufio.NewReader(f)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF&#123;</span><br><span class="line">fmt.Println(str)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(str)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="bufio-Writer"><a href="#bufio-Writer" class="headerlink" title="bufio.Writer"></a><code>bufio.Writer</code></h2><p><code>bufio.Writer</code>其实和<code>bufio.Reader</code>操作很对应.</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Writer implements buffering for an io.Writer object.</span></span><br><span class="line"><span class="comment">// If an error occurs writing to a Writer, no more data will be</span></span><br><span class="line"><span class="comment">// accepted and all subsequent writes, and Flush, will return the error.</span></span><br><span class="line"><span class="comment">// After all data has been written, the client should call the</span></span><br><span class="line"><span class="comment">// Flush method to guarantee all data has been forwarded to</span></span><br><span class="line"><span class="comment">// the underlying io.Writer.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">struct</span> &#123;</span><br><span class="line">err error</span><br><span class="line">buf []<span class="keyword">byte</span></span><br><span class="line">n   <span class="keyword">int</span></span><br><span class="line">wr  io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面列举几个最最常用的方法</p><ul><li><p><code>func NewWriter(w io.Writer) *Writer</code></p><p>NewWriter创建一个具有默认大小缓冲、写入w的*Writer。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewWriter returns a new Writer whose buffer has the default size.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span> *<span class="title">Writer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewWriterSize(w, defaultBufSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法调用<code>NewWriterSize</code>,返回一个带有默认缓冲区的<code>Writer</code>指针</p><p>defaultBufSize</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">defaultBufSize = <span class="number">4096</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><code>func NewWriterSize(w io.Writer, size int) *Writer</code></p><p>NewWriterSize创建一个具有最少有size尺寸的缓冲、写入w的<em>Writer。如果参数w已经是一个具有足够大缓冲的</em>Writer类型值，会返回w。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewWriterSize returns a new Writer whose buffer has at least the specified</span></span><br><span class="line"><span class="comment">// size. If the argument io.Writer is already a Writer with large enough</span></span><br><span class="line"><span class="comment">// size, it returns the underlying Writer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriterSize</span><span class="params">(w io.Writer, size <span class="keyword">int</span>)</span> *<span class="title">Writer</span></span> &#123;</span><br><span class="line"><span class="comment">// Is it already a Writer?</span></span><br><span class="line">b, ok := w.(*Writer)</span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; <span class="built_in">len</span>(b.buf) &gt;= size &#123;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> size &lt;= <span class="number">0</span> &#123;</span><br><span class="line">size = defaultBufSize</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;Writer&#123;</span><br><span class="line">buf: <span class="built_in">make</span>([]<span class="keyword">byte</span>, size),</span><br><span class="line">wr:  w,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的实现过程和<code>NewReaderSize</code>如出一辙,只不过<code>NewReaderSize</code>中调用了<code>reset</code>方法,这里直接初始化指针对象</p></li><li><p><code>func (b *Writer) Reset(w io.Writer)</code></p><p>Reset丢弃缓冲中的数据，清除任何错误，将b重设为将其输出写入w。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reset discards any unflushed buffered data, clears any error, and</span></span><br><span class="line"><span class="comment">// resets b to write its output to w.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Reset</span><span class="params">(w io.Writer)</span></span> &#123;</span><br><span class="line">b.err = <span class="literal">nil</span></span><br><span class="line">b.n = <span class="number">0</span></span><br><span class="line">b.wr = w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就不多做解释了,一眼就明白</p></li><li><p><code>func (b *Writer) Buffered()</code></p><p>Buffered返回缓冲中已使用的字节数。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Buffered returns the number of bytes that have been written into the current buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> b.n &#125;</span><br></pre></td></tr></table></figure><p>这个方法就更不用解释了</p></li><li><p><code>func (b *Writer) Available() int</code></p><p>Available返回缓冲中还有多少字节未使用。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Available returns how many bytes are unused in the buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Available</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(b.buf) - b.n &#125;</span><br></pre></td></tr></table></figure><p>不解释</p></li><li><p><code>func (b *Writer) Write(p []byte) (nn int, err error)</code></p><p>Write将p的内容写入缓冲。返回写入的字节数。如果返回值nn &lt; len(p)，还会返回一个错误说明原因。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(nn <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(p) &gt; b.Available() &amp;&amp; b.err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> b.Buffered() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Large write, empty buffer.</span></span><br><span class="line"><span class="comment">// Write directly from p to avoid copy.</span></span><br><span class="line">n, b.err = b.wr.Write(p)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">n = <span class="built_in">copy</span>(b.buf[b.n:], p)</span><br><span class="line">b.n += n</span><br><span class="line">b.Flush()</span><br><span class="line">&#125;</span><br><span class="line">nn += n</span><br><span class="line">p = p[n:]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nn, b.err</span><br><span class="line">&#125;</span><br><span class="line">n := <span class="built_in">copy</span>(b.buf[b.n:], p)</span><br><span class="line">b.n += n</span><br><span class="line">nn += n</span><br><span class="line"><span class="keyword">return</span> nn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>n, b.err = b.wr.Write(p)</code>可得这是通过调用<code>io.Writer</code>接口中的<code>Write</code>方法,</p><p><code>n := copy(b.buf[b.n:], p)</code>这一句和前面Read方法刚好相反,这是将p复制给buf的可用部分</p></li><li><p><code>func (b *Writer) WriteString(s string) (int, error)</code></p><p>WriteString写入一个字符串。返回写入的字节数。如果返回值nn &lt; len(s)，还会返回一个错误说明原因。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">nn := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(s) &gt; b.Available() &amp;&amp; b.err == <span class="literal">nil</span> &#123;</span><br><span class="line">n := <span class="built_in">copy</span>(b.buf[b.n:], s)</span><br><span class="line">b.n += n</span><br><span class="line">nn += n</span><br><span class="line">s = s[n:]</span><br><span class="line">b.Flush()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nn, b.err</span><br><span class="line">&#125;</span><br><span class="line">n := <span class="built_in">copy</span>(b.buf[b.n:], s)</span><br><span class="line">b.n += n</span><br><span class="line">nn += n</span><br><span class="line"><span class="keyword">return</span> nn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键语句<code>n := copy(b.buf[b.n:], s)</code>不解释</p></li><li><p><code>func (b *Writer) Flush() error</code></p><p>Flush方法将缓冲中的数据写入下层的io.Writer接口。</p><p>定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Flush</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> b.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> b.err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b.n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">n, err := b.wr.Write(b.buf[<span class="number">0</span>:b.n])</span><br><span class="line"><span class="keyword">if</span> n &lt; b.n &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">err = io.ErrShortWrite</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; n &lt; b.n &#123;</span><br><span class="line"><span class="built_in">copy</span>(b.buf[<span class="number">0</span>:b.n-n], b.buf[n:b.n])</span><br><span class="line">&#125;</span><br><span class="line">b.n -= n</span><br><span class="line">b.err = err</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">b.n = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下,如果b有错误就直接返回错误,如果b中没有写入值,则不做任何处理,否则就将缓冲中的n个值写进底层io.Writer中,如果写入的值数量小于缓冲取的值并且没有出错,则将err定义为<code>io.ErrShortWrite</code>错误,如果err不为空,并且写进底层<code>io.Writer</code>中的数据小于缓冲中原有的数据时,将剩余的数据写进缓冲区开头,将缓冲区已用空间设置为原来大小减去写人底层大小.如果err为空则代表成功将所有缓冲数据写入<code>io.Writer</code>将已用空间置为0</p></li></ul><p>其他<code>bufio</code>中的方法就留给读者自己去探索吧!</p><p>举个例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, err := os.OpenFile(<span class="string">&quot;test.txt&quot;</span>, os.O_RDWR|os.O_CREATE|os.O_APPEND, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">writer := bufio.NewWriter(f)</span><br><span class="line">writer.WriteString(<span class="string">&quot;让我康康是哪位靓仔看到了这句话\n&quot;</span>)</span><br><span class="line">writer.Write([]<span class="keyword">byte</span>(<span class="string">&quot;原来是你!\n&quot;</span>))</span><br><span class="line"></span><br><span class="line">writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:最后一定要flush一下,否则数据就不会写入文件,注意使用<code>OpenFile</code>函数打开文件并指定可写,否则将写不进去.</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-堆排序</title>
      <link href="/2020/05/27/python-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/05/27/python-%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序算法流程"><a href="#堆排序算法流程" class="headerlink" title="堆排序算法流程"></a>堆排序算法流程</h2><p>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong> </p><h2 id="用python实现"><a href="#用python实现" class="headerlink" title="用python实现"></a>用python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span>(<span class="params">intList: [int]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    end = len(intList) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> end &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 进行大顶堆的构造</span></span><br><span class="line">        heap(intList, end)</span><br><span class="line">        <span class="comment"># 交换第一个与最后一个的位置</span></span><br><span class="line">        intList[<span class="number">0</span>], intList[end] = intList[end], intList[<span class="number">0</span>]</span><br><span class="line">        end -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap</span>(<span class="params">intList: [int], end: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    i = end</span><br><span class="line">    <span class="comment"># 判断end是否是孤立</span></span><br><span class="line">    <span class="keyword">if</span> end % <span class="number">2</span>:</span><br><span class="line">        <span class="comment"># 孤立</span></span><br><span class="line">        <span class="comment"># 判断end和父元素的大小</span></span><br><span class="line">        <span class="keyword">if</span> intList[int((end<span class="number">-1</span>)/<span class="number">2</span>)] &lt; intList[end]:</span><br><span class="line">            intList[int((end<span class="number">-1</span>)/<span class="number">2</span>)</span><br><span class="line">                    ], intList[end] = intList[end], intList[int((end<span class="number">-1</span>)/<span class="number">2</span>)]</span><br><span class="line">        i = end<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 判断两个孩纸节点和父元素的大小</span></span><br><span class="line">        father = intList[int((i<span class="number">-2</span>)/<span class="number">2</span>)]</span><br><span class="line">        leftChild = intList[i<span class="number">-1</span>]</span><br><span class="line">        rightChild = intList[i]</span><br><span class="line">        maxIndex = i <span class="keyword">if</span> rightChild &gt; leftChild <span class="keyword">else</span> i<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> father &lt; intList[maxIndex]:</span><br><span class="line">            intList[int(</span><br><span class="line">                (i<span class="number">-2</span>)/<span class="number">2</span>)], intList[maxIndex] = intList[maxIndex],  intList[int((i<span class="number">-2</span>)/<span class="number">2</span>)]</span><br><span class="line">        i -= <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang-堆排序</title>
      <link href="/2020/05/27/golang-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/05/27/golang-%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序算法流程"><a href="#堆排序算法流程" class="headerlink" title="堆排序算法流程"></a>堆排序算法流程</h2><p>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong> </p><h2 id="用golang实现"><a href="#用golang实现" class="headerlink" title="用golang实现"></a>用golang实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(intList []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">end := <span class="built_in">len</span>(intList) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> end &gt;= <span class="number">0</span>&#123;</span><br><span class="line">heap(intList, end)</span><br><span class="line">intList[<span class="number">0</span>], intList[end] = intList[end], intList[<span class="number">0</span>]</span><br><span class="line">end--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heap</span><span class="params">(intList []<span class="keyword">int</span>, end <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">i := end</span><br><span class="line"><span class="comment">// 判断end是否是奇数</span></span><br><span class="line"><span class="keyword">if</span> end%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// 比较end和其父亲的大小</span></span><br><span class="line"><span class="keyword">if</span> intList[end] &gt; intList[(end<span class="number">-1</span>)/<span class="number">2</span>] &#123;</span><br><span class="line"><span class="comment">// 和父亲交换位置</span></span><br><span class="line">intList[end], intList[(end<span class="number">-1</span>)/<span class="number">2</span>] = intList[(end<span class="number">-1</span>)/<span class="number">2</span>], intList[end]</span><br><span class="line">&#125;</span><br><span class="line">i = end - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ; i &gt; <span class="number">0</span>; i -= <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 判断孩子和父亲的大小</span></span><br><span class="line">father := intList[(i<span class="number">-2</span>)/<span class="number">2</span>]</span><br><span class="line">leftChild := intList[i<span class="number">-1</span>]</span><br><span class="line">rightChild := intList[i]</span><br><span class="line">maxIndex := i <span class="comment">// 两个孩子中大的一个的下标</span></span><br><span class="line"><span class="keyword">if</span> leftChild &gt; rightChild&#123;</span><br><span class="line">maxIndex = i<span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> father &lt; intList[maxIndex] &#123;</span><br><span class="line">intList[(i<span class="number">-2</span>)/<span class="number">2</span>], intList[maxIndex] = intList[maxIndex], intList[(i<span class="number">-2</span>)/<span class="number">2</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
